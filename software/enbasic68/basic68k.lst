F00:0001       LED	EQU	$70000
F00:0002       STATUS	EQU	$60000
F00:0003       SERIALOUT  EQU	$50000
F00:0004       SERIALIN   EQU	$40000
F00:0005       RAMBASE	EQU	$E00000
F00:0006       
F00:0007       ACIA_1   	= $A00000	     	 * Console ACIA base address
F00:0008       RHR         = 0				     * receive holding register (read) 
F00:0009       THR         = 0      			 * transmit holding register (write) 
F00:0010       LSR         = 10				 * line status register 
F00:0011       
F00:0012       	nopage
F00:0013       
F00:0014       *************************************************************************************
F00:0015       *														*
F00:0016       *	Enhanced BASIC for the Motorola MC680xx							*
F00:0017       *														*
F00:0018       *	This version for the EASy68k editor/simulator.						*
F00:0019       *	Includes new simulator graphics commands 2002/3/4/5/6/7				*
F00:0020       *														*
F00:0021       *************************************************************************************
F00:0022       *														*
F00:0023       *	Copyright(C) 2002-12 by Lee Davison. This program may be freely distributed	*
F00:0024       *	for personal use only. All commercial rights are reserved.				*
F00:0025       *														*
F00:0026       *	More 68000 and other projects can be found on my website at ..			*
F00:0027       *														*
F00:0028       *	 http://mycorner.no-ip.org/index.html							*
F00:0029       *														*
F00:0030       *	mail : leeedavison@googlemail.com								*
F00:0031       *														*
F00:0032       *************************************************************************************
F00:0033       
F00:0034       * EASy68k extensions Ver 2.33
F00:0035       
F00:0036       * Version 3.xx replaces the fixed RAM addressing from previous versions with a RAM
F00:0037       * pointer in a3. this means that this could now be run as a task on a multitasking
F00:0038       * system where memory resources may change.
F00:0039       
F00:0040       * Ver 3.52
F00:0041       
F00:0042       * Ver 3.52 stops USING$() from reading beyond the end of the format string
F00:0043       * Ver 3.51 fixes the UCASE$() and LCASE$() functions for null strings
F00:0044       * Ver 3.50 uniary minus in concatenate generates a type mismatch error
F00:0045       * Ver 3.49 doesn't tokenise 'DEF' or 'DEC' within a hex value
F00:0046       * Ver 3.48 allows scientific notation underflow in the USING$() function
F00:0047       * Ver 3.47 traps the use of array elements as the FOR loop variable
F00:0048       * Ver 3.46 updates function and function variable handling
F00:0049       
F00:0050       *************************************************************************************
F00:0051       *
F00:0052       * Ver 3.45 makes the handling of non existant variables consistent and gives the
F00:0053       * option of not returning an error for a non existant variable. If this is the
F00:0054       * behaviour you want just change novar to some non zero value
F00:0055       
F00:0056       novar		EQU	0				* non existant variables cause errors
F00:0057       
F00:0058       
F00:0059       *************************************************************************************
F00:0060       
F00:0061       * Ver 3.44 adds overflow indication to the USING$() function
F00:0062       * Ver 3.43 removes an undocumented feature of concatenating null strings
F00:0063       * Ver 3.42 reimplements backspace so that characters are overwritten with [SPACE]
F00:0064       * Ver 3.41 removes undocumented features of the USING$() function
F00:0065       * Ver 3.40 adds the USING$() function
F00:0066       * Ver 3.33 adds the file requester to LOAD and SAVE
F00:0067       * Ver 3.32 adds the optional ELSE clause to IF .. THEN
F00:0068       
F00:0069       *************************************************************************************
F00:0070       
F00:0071       * Version 3.25 adds the option to change the behaviour of INPUT so that a null
F00:0072       * response does not cause a program break. If this is the behaviour you want just
F00:0073       * change nobrk to some non zero value.
F00:0074       
F00:0075       nobrk		EQU	0				* null response to INPUT causes a break
F00:0076       
F00:0077       
F00:0078       *************************************************************************************
F00:0079       
F00:0080       *OPT	CRE
F00:0081       
F00:0082       	INCLUDE	"basic68k.inc"
F01:0001       
F01:0002       * This lot is in RAM
F01:0003       
F01:0004       	OFFSET	0			* start of RAM
F01:0005       
F01:0006       ram_strt	ds.l	$100			* allow 1K for the stack, this should be plenty
F01:0007       									* for any BASIC program that doesn't do something
F01:0008       									* silly, it could even be much less.
F01:0009       ram_base
F01:0010       LAB_WARM	ds.w	1			* BASIC warm start entry point
F01:0011       Wrmjpv	ds.l	1			* BASIC warm start jump vector
F01:0012       
F01:0013       Usrjmp	ds.w	1			* USR function JMP address
F01:0014       Usrjpv	ds.l	1			* USR function JMP vector
F01:0015       
F01:0016       * system dependant i/o vectors
F01:0017       * these are in RAM and are set at start-up
F01:0018       
F01:0019       V_INPT	ds.w	1			* non halting scan input device entry point
F01:0020       V_INPTv	ds.l	1			* non halting scan input device jump vector
F01:0021       
F01:0022       V_OUTP	ds.w	1			* send byte to output device entry point
F01:0023       V_OUTPv	ds.l	1			* send byte to output device jump vector
F01:0024       
F01:0025       V_LOAD	ds.w	1			* load BASIC program entry point
F01:0026       V_LOADv	ds.l	1			* load BASIC program jump vector
F01:0027       
F01:0028       V_SAVE	ds.w	1			* save BASIC program entry point
F01:0029       V_SAVEv	ds.l	1			* save BASIC program jump vector
F01:0030       
F01:0031       V_CTLC	ds.w	1			* save CTRL-C check entry point
F01:0032       V_CTLCv	ds.l	1			* save CTRL-C check jump vector
F01:0033       
F01:0034       Itemp		ds.l	1			* temporary integer	(for GOTO etc)
F01:0035       
F01:0036       Smeml		ds.l	1			* start of memory		(start of program)
F01:0037       
F01:0038       * the program is stored as a series of lines each line having the following format
F01:0039       *
F01:0040       *		ds.l	1			* pointer to the next line or $00000000 if [EOT]
F01:0041       *		ds.l	1			* line number
F01:0042       *		ds.b	n			* program bytes
F01:0043       *		dc.b	$00			* [EOL] marker, there will be a second $00 byte, if
F01:0044       *						* needed, to pad the line to an even number of bytes
F01:0045       
F01:0046       Sfncl		ds.l	1			* start of functions	(end of Program)
F01:0047       
F01:0048       * the functions are stored as function name, function execute pointer and function
F01:0049       * variable name
F01:0050       *
F01:0051       *		ds.l	1			* name
F01:0052       *		ds.l	1			* execute pointer
F01:0053       *		ds.l	1			* function variable
F01:0054       
F01:0055       Svarl		ds.l	1			* start of variables	(end of functions)
F01:0056       
F01:0057       * the variables are stored as variable name, variable value
F01:0058       *
F01:0059       *		ds.l	1			* name
F01:0060       *		ds.l	1			* packed float or integer value
F01:0061       
F01:0062       Sstrl		ds.l	1			* start of strings	(end of variables)
F01:0063       
F01:0064       * the strings are stored as string name, string pointer and string length
F01:0065       *
F01:0066       *		ds.l	1			* name
F01:0067       *		ds.l	1			* string pointer
F01:0068       *		ds.w	1			* string length
F01:0069       
F01:0070       Sarryl	ds.l	1			* start of arrays		(end of strings)
F01:0071       
F01:0072       * the arrays are stored as array name, array size, array dimensions count, array
F01:0073       * dimensions upper bounds and array elements
F01:0074       *
F01:0075       *		ds.l	1			* name
F01:0076       *		ds.l	1			* size including this header
F01:0077       *		ds.w	1			* dimensions count
F01:0078       *		ds.w	1			* 1st dimension upper bound
F01:0079       *		ds.w	1			* 2nd dimension upper bound
F01:0080       *		...				* ...
F01:0081       *		ds.w	1			* nth dimension upper bound
F01:0082       *
F01:0083       * then (i1+1)*(i2+1)...*(in+1) of either ..
F01:0084       *
F01:0085       *		ds.l	1			* packed float or integer value
F01:0086       *
F01:0087       * .. if float or integer, or ..
F01:0088       *
F01:0089       *		ds.l	1			* string pointer
F01:0090       *		ds.w	1			* string length
F01:0091       *
F01:0092       * .. if string
F01:0093       
F01:0094       Earryl	ds.l	1			* end of arrays		(start of free mem)
F01:0095       Sstorl	ds.l	1			* string storage		(moving down)
F01:0096       Ememl		ds.l	1			* end of memory		(upper bound of RAM)
F01:0097       Sutill	ds.l	1			* string utility ptr
F01:0098       Clinel	ds.l	1			* current line		(Basic line number)
F01:0099       Blinel	ds.l	1			* break line		(Basic line number)
F01:0100       
F01:0101       Cpntrl	ds.l	1			* continue pointer
F01:0102       Dlinel	ds.l	1			* current DATA line
F01:0103       Dptrl		ds.l	1			* DATA pointer
F01:0104       Rdptrl	ds.l	1			* read pointer
F01:0105       Varname	ds.l	1			* current var name
F01:0106       Cvaral	ds.l	1			* current var address
F01:0107       Lvarpl	ds.l	1			* variable pointer for LET and FOR/NEXT
F01:0108       
F01:0109       des_sk_e	ds.l	6			* descriptor stack end address
F01:0110       des_sk					* descriptor stack start address
F01:0111       						* use a4 for the descriptor pointer
F01:0112       		ds.w	1			
F01:0113       Ibuffs	ds.l	$40			* start of input buffer
F01:0114       Ibuffe
F01:0115       						* end of input buffer
F01:0116       
F01:0117       FAC1_m	ds.l	1			* FAC1 mantissa1
F01:0118       FAC1_e	ds.w	1			* FAC1 exponent
F01:0119       FAC1_s	EQU	FAC1_e+1		* FAC1 sign (b7)
F01:0120       		ds.w	1			
F01:0121       
F01:0122       FAC2_m	ds.l	1			* FAC2 mantissa1
F01:0123       FAC2_e	ds.l	1			* FAC2 exponent
F01:0124       FAC2_s	EQU	FAC2_e+1		* FAC2 sign (b7)
F01:0125       FAC_sc	EQU	FAC2_e+2		* FAC sign comparison, Acc#1 vs #2
F01:0126       flag		EQU	FAC2_e+3		* flag byte for divide routine
F01:0127       
F01:0128       PRNlword	ds.l	1			* PRNG seed long word
F01:0129       
F01:0130       ut1_pl	ds.l	1			* utility pointer 1
F01:0131       
F01:0132       Asptl		ds.l	1			* array size/pointer
F01:0133       Astrtl	ds.l	1			* array start pointer
F01:0134       
F01:0135       numexp	EQU	Astrtl			* string to float number exponent count
F01:0136       expcnt	EQU	Astrtl+1		* string to float exponent count
F01:0137       
F01:0138       expneg	EQU	Astrtl+3		* string to float eval exponent -ve flag
F01:0139       
F01:0140       func_l	ds.l	1			* function pointer
F01:0141       
F01:0142       
F01:0143       							* these two need to be a word aligned pair !
F01:0144       Defdim	ds.w	1			* default DIM flag
F01:0145       cosout	EQU	Defdim			* flag which CORDIC output (re-use byte)
F01:0146       Dtypef	EQU	Defdim+1		* data type flag, $80=string, $40=integer, $00=float
F01:0147       
F01:0148       
F01:0149       Binss		ds.l	4			* number to bin string start (32 chrs)
F01:0150       
F01:0151       Decss		ds.l	1			* number to decimal string start (16 chrs)
F01:0152       			ds.w	1			*
F01:0153       Usdss		ds.w	1			* unsigned decimal string start (10 chrs)
F01:0154       
F01:0155       Hexss		ds.l	2			* number to hex string start (8 chrs)
F01:0156       
F01:0157       BHsend		ds.w	1			* bin/decimal/hex string end
F01:0158       
F01:0159       
F01:0160       prstk		ds.b	1			* stacked function index
F01:0161       
F01:0162       tpower	ds.b	1			* remember CORDIC power
F01:0163       
F01:0164       Asrch		ds.b	1			* scan-between-quotes flag, alt search character
F01:0165       
F01:0166       Dimcnt	ds.b	1			* # of dimensions
F01:0167       
F01:0168       Breakf	ds.b	1			* break flag, $00=END else=break
F01:0169       Oquote	ds.b	1			* open quote flag (Flag: DATA; LIST; memory)
F01:0170       Gclctd	ds.b	1			* garbage collected flag
F01:0171       Sufnxf	ds.b	1			* subscript/FNX flag, 1xxx xxx = FN(0xxx xxx)
F01:0172       Imode		ds.b	1			* input mode flag, $00=INPUT, $98=READ
F01:0173       
F01:0174       Cflag		ds.b	1			* comparison evaluation flag
F01:0175       
F01:0176       TabSiz	ds.b	1			* TAB step size
F01:0177       
F01:0178       comp_f	ds.b	1			* compare function flag, bits 0,1 and 2 used
F01:0179       						* bit 2 set if >
F01:0180       						* bit 1 set if =
F01:0181       						* bit 0 set if <
F01:0182       
F01:0183       Nullct	ds.b	1			* nulls output after each line
F01:0184       TPos		ds.b	1			* BASIC terminal position byte
F01:0185       TWidth	ds.b	1			* BASIC terminal width byte
F01:0186       Iclim		ds.b	1			* input column limit
F01:0187       ccflag	ds.b	1			* CTRL-C check flag
F01:0188       ccbyte	ds.b	1			* CTRL-C last received byte
F01:0189       ccnull	ds.b	1			* CTRL-C last received byte 'life' timer
F01:0190       
F01:0191       * these variables for simulator load/save routines
F01:0192       
F01:0193       file_byte	ds.b	1			* load/save data byte
F01:0194       file_id	ds.l	1			* load/save file ID
F01:0195       
F01:0196       		dc.w	0			* dummy even value and zero pad byte
               S00:000005F0:  00 00
F01:0197       
F01:0198       prg_strt
F01:0199       
F01:0200       ;	ORG	*
F01:0201       
F01:0202       ram_addr	EQU	$C00000 ;$E00000		* RAM start address
F01:0203       ram_size	EQU	$100000 ;$80000		* RAM size
F01:0204       
F01:0205       
F00:0083       							* RAM offset definitions
F00:0084       	code
F00:0085       
F00:0086       	;ORG		$000400			* past the vectors in a real system
F00:0087       	ORG		$E00000
F00:0088       
F00:0089       code_start
F00:0090       	bra	start_here
               S01:00E00000:  60 00 01 5C
F00:0091       	
F00:0092       *************************************************************************************
F00:0093       *
F00:0094       * the following code is simulator specific, change to suit your system
F00:0095       
F00:0096       * output character to the console from register d0.b
F00:0097       
F00:0098       VEC_OUT
F00:0099       	*MOVEM.l	d0-d1,-(sp)			* save d0, d1
F00:0100       	*MOVE.b	d0,d1				* copy character
F00:0101       	*MOVEQ		#6,d0				* character out
F00:0102       	*TRAP		#15				* do I/O function
F00:0103       	*MOVEM.l	(sp)+,d0-d1			* restore d0, d1
F00:0104       	*RTS
F00:0105       *	MOVE.B	D0, SERIALOUT
F00:0106       *	RTS
F00:0107       
F00:0108       
F00:0109               MOVEM.L  A0/D1,-(A7)    * Save working registers
               S01:00E00004:  48 E7 40 80
F00:0110       
F00:0111       	    LEA.L   ACIA_1,A0
               S01:00E00008:  41 F9 00 A0 00 00
F00:0112       TXNOTREADY
F00:0113       	    BTST.B  #5,LSR(A0)		* Test TXRDY bit
               S01:00E0000E:  08 28 00 05 00 0A
F00:0114               BEQ     TXNOTREADY		* Until ACIA Tx ready
               S01:00E00014:  67 F8
F00:0115               MOVE.B  D0,THR(A0)
               S01:00E00016:  10 80
F00:0116       
F00:0117               MOVEM.L  (A7)+,A0/D1    * Restore working registers
               S01:00E00018:  4C DF 01 02
F00:0118               RTS	
               S01:00E0001C:  4E 75
F00:0119       
F00:0120       *************************************************************************************
F00:0121       *
F00:0122       * input a character from the console into register d0
F00:0123       * else return Cb=0 if there's no character available
F00:0124       
F00:0125       VEC_IN
F00:0126       *	MOVE.l	d1,-(sp)			* save d1
F00:0127       *	MOVEQ		#7,d0				* get the status
F00:0128       *	TRAP		#15				* do I/O function
F00:0129       
F00:0130       *	MOVE.b	d1,d0				* copy the returned status
F00:0131       *	BNE.s		RETCHR			* if a character is waiting go get it
F00:0132       
F00:0133       *	MOVE.l	(sp)+,d1			* else restore d1
F00:0134       *	TST.b		d0				* set the z flag
F00:0135       **	ANDI.b	#$FE,CCR			* clear the carry, flag we got no byte
F00:0136       **							* done by the TST.b
F00:0137       *	RTS
F00:0138       
F00:0139       *RETCHR
F00:0140       *	MOVEQ		#5,d0				* get byte form the keyboard
F00:0141       *	TRAP		#15				* do I/O function
F00:0142       
F00:0143       *	MOVE.b	d1,d0				* copy the returned byte
F00:0144       *	MOVE.l	(sp)+,d1			* restore d1
F00:0145       *	TST.b		d0				* set the z flag on the received byte
F00:0146       *	ORI.b		#1,CCR			* set the carry, flag we got a byte
F00:0147       *	RTS
F00:0148       
F00:0149       *	MOVE.B	STATUS, D0	; get serial status
F00:0150       *	AND.B	#1, D0 		; mask D0 - RXF (active low)
F00:0151       *	BEQ	RETCHR
F00:0152       *	ANDI.B	#$FE,CCR	; clear the carry, flag we got no byte								
F00:0153       *	RTS
F00:0154       
F00:0155       *RETCHR
F00:0156       *	MOVE.B	SERIALIN, D0
F00:0157       *	ORI.B	#1,CCR		; set the carry, flag we got a byte
F00:0158       *	RTS
F00:0159       
F00:0160               MOVEM.L  A0/D1,-(A7)    * Save working registers
               S01:00E0001E:  48 E7 40 80
F00:0161       
F00:0162               LEA.L    ACIA_1,A0      * A0 points to console ACIA
               S01:00E00022:  41 F9 00 A0 00 00
F00:0163               BTST.B   #0,LSR(A0)     * Test RCV bit
               S01:00E00028:  08 28 00 00 00 0A
F00:0164               BEQ.S    RXNOTREADY     * Branch If ACIA Rx not ready
               S01:00E0002E:  67 0C
F00:0165               MOVE.B   RHR(A0),D0     * Read character received
               S01:00E00030:  10 10
F00:0166               MOVEM.L  (A7)+,A0/D1    * Restore working registers
               S01:00E00032:  4C DF 01 02
F00:0167       		ORI.b	 #1,CCR	        * Set the carry, flag we got a byte
               S01:00E00036:  00 3C 00 01
F00:0168               RTS                     * Return
               S01:00E0003A:  4E 75
F00:0169       RXNOTREADY:
F00:0170               MOVEM.L  (A7)+,A0/D1    * Restore working registers
               S01:00E0003C:  4C DF 01 02
F00:0171       		ANDI.b	 #$FE,CCR		* Clear the carry, flag character available
               S01:00E00040:  02 3C 00 FE
F00:0172       		RTS	
               S01:00E00044:  4E 75
F00:0173       
F00:0174       *************************************************************************************
F00:0175       *
F00:0176       * LOAD routine for the Easy68k simulator
F00:0177       
F00:0178       VEC_LD
F00:0179       *	LEA		load_title(pc),a1		* set the LOAD request title string pointer
F00:0180       *	BSR		get_filename		* get the filename from the line or the request
F00:0181       *
F00:0182       *	BEQ		LAB_FCER			* if null do function call error then warm start
F00:0183       *
F00:0184       *	MOVE		#51,d0			* open existing file
F00:0185       *	TRAP		#15				* do I/O function
F00:0186       *
F00:0187       *	TST.w		d0				* test load result
F00:0188       *	BNE.s		LOAD_exit			* if error clear up and exit
F00:0189       
F00:0190       *	MOVE.l	d1,file_id(a3)		* save the file ID
F00:0191       
F00:0192       *	LEA		LOAD_in(pc),a1		* get byte from file vector
F00:0193       *	MOVE.l	a1,V_INPTv(a3)		* set the input vector
F00:0194       *	BRA		LAB_127D			* now we just wait for Basic command, no "Ready"
F00:0195       
F00:0196       LOAD_exit
F00:0197       	BSR		LAB_147A			* go do "CLEAR"
               S01:00E00046:  61 00 04 E0
F00:0198       	BRA		LAB_1274			* BASIC warm start entry, go wait for Basic
               S01:00E0004A:  60 00 02 5E
F00:0199       							* command
F00:0200       
F00:0201       * input character to register d0 from file
F00:0202       
F00:0203       LOAD_in
F00:0204       *	MOVEM.l	d1-d2/a1,-(sp)		* save d1, d2 & a1
F00:0205       *	MOVE.l	file_id(a3),d1		* get file ID back
F00:0206       *	LEA		file_byte(a3),a1		* point to byte buffer
F00:0207       *	MOVEQ		#1,d2				* set count for one byte
F00:0208       *	MOVEQ		#53,d0			* read from file
F00:0209       *	TRAP		#15				* do I/O function
F00:0210       
F00:0211       *	TST.w		d0				* test status
F00:0212       *	BNE.s		LOAD_eof			* branch if byte read failed
F00:0213       
F00:0214       *	MOVE.b	(a1),d0			* get byte
F00:0215       *	MOVEM.l	(sp)+,d1-d2/a1		* restore d1, d2 & a1
F00:0216       *	ORI.b		#1,CCR			* set carry, flag we got a byte
F00:0217       *	RTS
F00:0218       							* got an error on read so restore the input
F00:0219       							* vector and tidy up
F00:0220       LOAD_eof
F00:0221       *	MOVEQ		#50,d0			* close all files
F00:0222       *	TRAP		#15				* do I/O function
F00:0223       
F00:0224       	LEA		VEC_IN(pc),a1		* get byte from input device vector
               S01:00E0004E:  43 FA FF CE
F00:0225       	MOVE.l	a1,V_INPTv(a3)		* set input vector
               S01:00E00052:  27 49 04 0E
F00:0226       	MOVEQ		#0,d0				* clear byte
               S01:00E00056:  70 00
F00:0227       	MOVEM.l	(sp)+,d1-d2/a1		* restore d1, d2 & a1
               S01:00E00058:  4C DF 02 06
F00:0228       	BSR		LAB_147A			* do CLEAR, erase variables/functions and
               S01:00E0005C:  61 00 04 CA
F00:0229       							* flush stacks
F00:0230       	BRA		LAB_1274			* BASIC warm start entry, go wait for Basic
               S01:00E00060:  60 00 02 48
F00:0231       							* command
F00:0232       
F00:0233       
F00:0234       *************************************************************************************
F00:0235       *
F00:0236       * get the filename from the line or from the filename requester
F00:0237       *
F00:0238       * if the name is null, "", or there is nothing following then the requester is used
F00:0239       * to get a filename else the filename is got from the line. if the requester is used
F00:0240       * the name buffer is allocated in string space and is always null terminated before
F00:0241       * it is passed to the file requester
F00:0242       
F00:0243       get_filename
F00:0244       	BEQ.s		get_name			* if no following go use the requester
               S01:00E00064:  67 40
F00:0245       
F00:0246       get_file
F00:0247       	MOVE.l	a1,-(sp)			* save the title string pointer
               S01:00E00066:  2F 09
F00:0248       	SUBQ.w	#1,a5				* decrement the execute pointer
               S01:00E00068:  53 4D
F00:0249       	BSR		LAB_GVAL			* get value from line
               S01:00E0006A:  61 00 0D F8
F00:0250       	MOVEA.l	(sp)+,a1			* restore the title string pointer
               S01:00E0006E:  22 5F
F00:0251       	TST.b		Dtypef(a3)			* test the data type flag
               S01:00E00070:  4A 2B 05 B5
F00:0252       	BPL		LAB_TMER			* if not string type do type mismatch error
               S01:00E00074:  6A 00 01 D8
F00:0253       
F00:0254       	MOVEA.l	FAC1_m(a3),a2		* get the descriptor pointer
               S01:00E00078:  24 6B 05 90
F00:0255       	MOVE.w	4(a2),d1			* get the string length
               S01:00E0007C:  32 2A 00 04
F00:0256       	BEQ.s		get_name			* if null go use the file requester
               S01:00E00080:  67 24
F00:0257       
F00:0258       	MOVEA.l	(a2),a1			* get the string pointer
               S01:00E00082:  22 52
F00:0259       	MOVE.w	d1,d0				* copy the string length
               S01:00E00084:  30 01
F00:0260       	ADDQ.w	#1,d1				* increment the string length
               S01:00E00086:  52 41
F00:0261       	BSR		LAB_2115			* make space d1 bytes long
               S01:00E00088:  61 00 14 A8
F00:0262       
F00:0263       	MOVE.b	#$00,(a0,d0.w)		* null terminate the new string
               S01:00E0008C:  11 BC 00 00 00 00
F00:0264       	SUBQ.w	#1,d0				* decrement the string length
               S01:00E00092:  53 40
F00:0265       name_copy
F00:0266       	MOVE.b	(a1,d0.w),(a0,d0.w)	* copy a file name byte
               S01:00E00094:  11 B1 00 00 00 00
F00:0267       	DBF		d0,name_copy		* loop while more to do
               S01:00E0009A:  51 C8 FF F8
F00:0268       
F00:0269       	MOVEA.l	a0,a1				* copy the new, terminated, file name pointer
               S01:00E0009E:  22 48
F00:0270       
F00:0271       	MOVEA.l	a2,a0				* copy the old filename descriptor pointer
               S01:00E000A0:  20 4A
F00:0272       	BRA		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E000A2:  60 00 16 1A
F00:0273       							* returns with d0 = length, a0 = pointer
F00:0274       
F00:0275       * get a name with the file requester
F00:0276       
F00:0277       get_name
F00:0278       	MOVE.l	a3,-(sp)			* save the variables base pointer
               S01:00E000A6:  2F 0B
F00:0279       	MOVE.w	#$100,d1			* enough space for the request filename
               S01:00E000A8:  32 3C 01 00
F00:0280       	BSR		LAB_2115			* make space d1 bytes long
               S01:00E000AC:  61 00 14 84
F00:0281       	MOVEA.l	a0,a3				* copy the file name buffer pointer
               S01:00E000B0:  26 48
F00:0282       	LEA		file_list(pc),a2		* set the file types list pointer
               S01:00E000B2:  45 FA 00 26
F00:0283       	MOVEQ		#0,d1				* file open
               S01:00E000B6:  72 00
F00:0284       	MOVE.b	d1,(a3)			* ensure initial null file name
               S01:00E000B8:  16 81
F00:0285       	MOVEQ		#58,d0			* file I/O
               S01:00E000BA:  70 3A
F00:0286       	TRAP		#15
               S01:00E000BC:  4E 4F
F00:0287       
F00:0288       	MOVEA.l	a3,a1				* copy the file name pointer
               S01:00E000BE:  22 4B
F00:0289       	MOVEA.l	(sp)+,a3			* restore the variables pointer
               S01:00E000C0:  26 5F
F00:0290       	TST.l		d1				* did the user hit open
               S01:00E000C2:  4A 81
F00:0291       	RTS
               S01:00E000C4:  4E 75
F00:0292       
F00:0293       
F00:0294       load_title
F00:0295       	dc.b	'LOAD file',0			* LOAD file title string
               S01:00E000C6:  4C 4F 41 44 20 66 69 6C 65
               S01:00E000CF:  00
F00:0296       
F00:0297       save_title
F00:0298       	dc.b	'SAVE file',0			* SAVE file title string
               S01:00E000D0:  53 41 56 45 20 66 69 6C 65
               S01:00E000D9:  00
F00:0299       
F00:0300       file_list
F00:0301       	dc.b	'*.bas',0				* file type list
               S01:00E000DA:  2A 2E 62 61 73
               S01:00E000DF:  00
F00:0302       	ds.w	0					* ensure even
F00:0303       
F00:0304       
F00:0305       *************************************************************************************
F00:0306       *
F00:0307       * SAVE routine for the Easy68k simulator
F00:0308       
F00:0309       VEC_SV
F00:0310       	LEA		save_title(pc),a1		* set the SAVE request title string pointer
               S01:00E000E0:  43 FA FF EE
F00:0311       	PEA		SAVE_RTN(pc)		* set the return point
               S01:00E000E4:  48 7A 00 0E
F00:0312       	BEQ.s		get_name			* if no following go use the file requester
               S01:00E000E8:  67 BC
F00:0313       
F00:0314       	CMP.b		#',',d0			* compare the following byte with ","
               S01:00E000EA:  B0 3C 00 2C
F00:0315       	BNE		get_file			* if not "," get the filename from the line
               S01:00E000EE:  66 00 FF 76
F00:0316       
F00:0317       	BEQ.s		get_name			* else go use the file requester
               S01:00E000F2:  67 B2
F00:0318       
F00:0319       SAVE_RTN
F00:0320       	BEQ		LAB_FCER			* if null do function call error then warm start
               S01:00E000F4:  67 00 01 78
F00:0321       
F00:0322       	MOVEA.l	a0,a1				* copy filename pointer
               S01:00E000F8:  22 48
F00:0323       	MOVE		#52,d0			* open new file
               S01:00E000FA:  30 3C 00 34
F00:0324       	TRAP		#15				* do I/O function
               S01:00E000FE:  4E 4F
F00:0325       
F00:0326       	TST.w		d0				* test save result
               S01:00E00100:  4A 40
F00:0327       	BNE		LAB_FCER			* if error do function call error, warm start
               S01:00E00102:  66 00 01 6A
F00:0328       
F00:0329       	MOVE.l	d1,file_id(a3)		* save file ID
               S01:00E00106:  27 41 05 EC
F00:0330       
F00:0331       	MOVE.l	V_OUTPv(a3),-(sp)		* save the output vector
               S01:00E0010A:  2F 2B 04 14
F00:0332       	LEA		SAVE_OUT(pc),a1		* send byte to file vector
               S01:00E0010E:  43 FA 00 34
F00:0333       	MOVE.l	a1,V_OUTPv(a3)		* change the output vector
               S01:00E00112:  27 49 04 14
F00:0334       
F00:0335       	MOVE.b	TWidth(a3),-(sp)		* save the current line length
               S01:00E00116:  1F 2B 05 E6
F00:0336       	MOVE.b	#$00,TWidth(a3)		* set infinite length line for save
               S01:00E0011A:  17 7C 00 00 05 E6
F00:0337       
F00:0338       	BSR		LAB_GBYT			* get next BASIC byte
               S01:00E00120:  61 00 0D 96
F00:0339       	BEQ		SAVE_bas			* if no following go do SAVE
               S01:00E00124:  67 0C
F00:0340       
F00:0341       	CMP.b		#',',d0			* else compare with ","
               S01:00E00126:  B0 3C 00 2C
F00:0342       	BNE		LAB_SNER			* if not "," so go do syntax error/warm start
               S01:00E0012A:  66 00 01 4E
F00:0343       
F00:0344       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0012E:  61 00 0D 86
F00:0345       SAVE_bas
F00:0346       	BSR		LAB_LIST			* go do list (line numbers applicable)
               S01:00E00132:  61 00 04 34
F00:0347       	MOVE.b	(sp)+,TWidth(a3)		* restore the line length
               S01:00E00136:  17 5F 05 E6
F00:0348       
F00:0349       	MOVE.l	(sp)+,V_OUTPv(a3)		* restore the output vector
               S01:00E0013A:  27 5F 04 14
F00:0350       	MOVEQ		#50,d0			* close all files
               S01:00E0013E:  70 32
F00:0351       	TRAP		#15				* do I/O function
               S01:00E00140:  4E 4F
F00:0352       
F00:0353       	RTS
               S01:00E00142:  4E 75
F00:0354       	
F00:0355       
F00:0356       * output character to file from register d0
F00:0357       
F00:0358       SAVE_OUT
F00:0359       	MOVEM.l	d0-d2/a1,-(sp)		* save d0, d1, d2 & a1
               S01:00E00144:  48 E7 E0 40
F00:0360       	MOVE.l	file_id(a3),d1		* get file ID back
               S01:00E00148:  22 2B 05 EC
F00:0361       	LEA		file_byte(a3),a1		* point to byte buffer
               S01:00E0014C:  43 EB 05 EB
F00:0362       	MOVE.b	d0,(a1)			* save byte
               S01:00E00150:  12 80
F00:0363       	MOVEQ		#1,d2				* set byte count
               S01:00E00152:  74 01
F00:0364       	MOVEQ		#54,d0			* write to file
               S01:00E00154:  70 36
F00:0365       	TRAP		#15				* do I/O function
               S01:00E00156:  4E 4F
F00:0366       
F00:0367       	MOVEM.l	(sp)+,d0-d2/a1		* restore d0, d1, d2 & a1
               S01:00E00158:  4C DF 02 07
F00:0368       	RTS
               S01:00E0015C:  4E 75
F00:0369       
F00:0370       
F00:0371       *************************************************************************************
F00:0372       *
F00:0373       * turn off simulator key echo
F00:0374       
F00:0375       start_here
F00:0376       	*MOVEQ		#12,d0			* keyboard echo
F00:0377       	*MOVEQ		#0,d1				* turn off echo
F00:0378       	*TRAP		#15				* do I/O function
F00:0379       
F00:0380       * to tell EhBASIC where and how much RAM it has pass the address in a0 and the size
F00:0381       * in d0. these values are at the end of the .inc file
F00:0382       
F00:0383       	MOVEA.l	#ram_addr,a0		* tell BASIC where RAM starts
               S01:00E0015E:  20 7C 00 C0 00 00
F00:0384       	MOVE.l	#ram_size,d0		* tell BASIC how big RAM is
               S01:00E00164:  70 10 48 40
F00:0385       
F00:0386       * end of simulator specific code
F00:0387       
F00:0388       
F00:0389       ****************************************************************************************
F00:0390       ****************************************************************************************
F00:0391       ****************************************************************************************
F00:0392       ****************************************************************************************
F00:0393       *
F00:0394       * Register use :- (must improve this !!)
F00:0395       *
F00:0396       *	a6 -	temp Bpntr				* temporary BASIC execute pointer
F00:0397       *	a5 -	Bpntr					* BASIC execute (get byte) pointer
F00:0398       *	a4 -	des_sk				* descriptor stack pointer
F00:0399       *	a3 -	ram_strt				* start of RAM. all RAM references are offsets
F00:0400       *							* from this value
F00:0401       *
F00:0402       
F00:0403       *************************************************************************************
F00:0404       *
F00:0405       * BASIC cold start entry point. assume entry with RAM address in a0 and RAM length
F00:0406       * in d0
F00:0407       
F00:0408       LAB_COLD
F00:0409       	CMP.l		#$4000,d0			* compare size with 16k
               S01:00E00168:  B0 BC 00 00 40 00
F00:0410       	BGE.s		LAB_sizok			* branch if >= 16k
               S01:00E0016E:  6C 04
F00:0411       
F00:0412       	MOVEQ		#5,d0				* error 5 - not enough RAM
               S01:00E00170:  70 05
F00:0413       	RTS						* just exit. this as stands will never execute
               S01:00E00172:  4E 75
F00:0414       							* but could be used to exit to an OS
F00:0415       
F00:0416       LAB_sizok
F00:0417       	MOVEA.l	a0,a3				* copy RAM base to a3
               S01:00E00174:  26 48
F00:0418       	ADDA.l	d0,a0				* a0 is top of RAM
               S01:00E00176:  D1 C0
F00:0419       	MOVE.l	a0,Ememl(a3)		* set end of mem
               S01:00E00178:  27 48 04 4A
F00:0420       	LEA		ram_base(a3),sp		* set stack to RAM start + 1k
               S01:00E0017C:  4F EB 04 00
F00:0421       
F00:0422       	MOVE.w	#$4EF9,d0			* JMP opcode
               S01:00E00180:  30 3C 4E F9
F00:0423       	MOVEA.l	sp,a0				* point to start of vector table
               S01:00E00184:  20 4F
F00:0424       
F00:0425       	MOVE.w	d0,(a0)+			* LAB_WARM
               S01:00E00186:  30 C0
F00:0426       	LEA		LAB_COLD(pc),a1		* initial warm start vector
               S01:00E00188:  43 FA FF DE
F00:0427       	MOVE.l	a1,(a0)+			* set vector
               S01:00E0018C:  20 C9
F00:0428       
F00:0429       	MOVE.w	d0,(a0)+			* Usrjmp
               S01:00E0018E:  30 C0
F00:0430       	LEA		LAB_FCER(pc),a1		* initial user function vector
               S01:00E00190:  43 FA 00 DC
F00:0431       							* "Function call" error
F00:0432       	MOVE.l	a1,(a0)+			* set vector
               S01:00E00194:  20 C9
F00:0433       
F00:0434       	MOVE.w	d0,(a0)+			* V_INPT JMP opcode
               S01:00E00196:  30 C0
F00:0435       	LEA		VEC_IN(pc),a1		* get byte from input device vector
               S01:00E00198:  43 FA FE 84
F00:0436       	MOVE.l	a1,(a0)+			* set vector
               S01:00E0019C:  20 C9
F00:0437       
F00:0438       	MOVE.w	d0,(a0)+			* V_OUTP JMP opcode
               S01:00E0019E:  30 C0
F00:0439       	LEA		VEC_OUT(pc),a1		* send byte to output device vector
               S01:00E001A0:  43 FA FE 62
F00:0440       	MOVE.l	a1,(a0)+			* set vector
               S01:00E001A4:  20 C9
F00:0441       
F00:0442       	MOVE.w	d0,(a0)+			* V_LOAD JMP opcode
               S01:00E001A6:  30 C0
F00:0443       	LEA		VEC_LD(pc),a1		* load BASIC program vector
               S01:00E001A8:  43 FA FE 9C
F00:0444       	MOVE.l	a1,(a0)+			* set vector
               S01:00E001AC:  20 C9
F00:0445       
F00:0446       	MOVE.w	d0,(a0)+			* V_SAVE JMP opcode
               S01:00E001AE:  30 C0
F00:0447       	LEA		VEC_SV(pc),a1		* save BASIC program vector
               S01:00E001B0:  43 FA FF 2E
F00:0448       	MOVE.l	a1,(a0)+			* set vector
               S01:00E001B4:  20 C9
F00:0449       
F00:0450       	MOVE.w	d0,(a0)+			* V_CTLC JMP opcode
               S01:00E001B6:  30 C0
F00:0451       	LEA		VEC_CC(pc),a1		* save CTRL-C check vector
               S01:00E001B8:  43 FA 28 24
F00:0452       	MOVE.l	a1,(a0)+			* set vector
               S01:00E001BC:  20 C9
F00:0453       
F00:0454       * set-up start values
F00:0455       
F00:0456       LAB_GMEM
F00:0457       	MOVEQ		#$00,d0			* clear d0
               S01:00E001BE:  70 00
F00:0458       	MOVE.b	d0,Nullct(a3)		* default NULL count
               S01:00E001C0:  17 40 05 E4
F00:0459       	MOVE.b	d0,TPos(a3)			* clear terminal position
               S01:00E001C4:  17 40 05 E5
F00:0460       	MOVE.b	d0,ccflag(a3)		* allow CTRL-C check
               S01:00E001C8:  17 40 05 E8
F00:0461       	MOVE.w	d0,prg_strt-2(a3)		* clear start word
               S01:00E001CC:  37 40 05 F0
F00:0462       	MOVE.w	d0,BHsend(a3)		* clear value to string end word
               S01:00E001D0:  37 40 05 D6
F00:0463       
F00:0464       	MOVE.b	#$50,TWidth(a3)		* default terminal width byte for simulator *##
               S01:00E001D4:  17 7C 00 50 05 E6
F00:0465       *##	MOVE.b	d0,TWidth(a3)		* default terminal width byte
F00:0466       
F00:0467       	MOVE.b	#$0E,TabSiz(a3)		* save default tab size = 14
               S01:00E001DA:  17 7C 00 0E 05 E2
F00:0468       
F00:0469       	MOVE.b	#$38,Iclim(a3)		* default limit for TAB = 14 for simulator *##
               S01:00E001E0:  17 7C 00 38 05 E7
F00:0470       *##	MOVE.b	#$F2,Iclim(a3)		* default limit for TAB = 14
F00:0471       
F00:0472       	LEA		des_sk(a3),a4		* set descriptor stack start
               S01:00E001E6:  49 EB 04 8E
F00:0473       
F00:0474       	LEA		prg_strt(a3),a0		* get start of mem
               S01:00E001EA:  41 EB 05 F2
F00:0475       	MOVE.l	a0,Smeml(a3)		* save start of mem
               S01:00E001EE:  27 48 04 2E
F00:0476       
F00:0477       	BSR		LAB_1463			* do "NEW" and "CLEAR"
               S01:00E001F2:  61 00 03 22
F00:0478       	BSR		LAB_CRLF			* print CR/LF
               S01:00E001F6:  61 00 08 96
F00:0479       	MOVE.l	Ememl(a3),d0		* get end of mem
               S01:00E001FA:  20 2B 04 4A
F00:0480       	SUB.l		Smeml(a3),d0		* subtract start of mem
               S01:00E001FE:  90 AB 04 2E
F00:0481       
F00:0482       	BSR		LAB_295E			* print d0 as unsigned integer (bytes free)
               S01:00E00202:  61 00 1D DA
F00:0483       	LEA		LAB_SMSG(pc),a0		* point to start message
               S01:00E00206:  41 FA 36 86
F00:0484       	BSR		LAB_18C3			* print null terminated string from memory
               S01:00E0020A:  61 00 08 E0
F00:0485       
F00:0486       	LEA		LAB_RSED(pc),a0		* get pointer to value
               S01:00E0020E:  41 FA 2B D6
F00:0487       	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
               S01:00E00212:  61 00 1C 76
F00:0488       
F00:0489       	LEA		LAB_1274(pc),a0		* get warm start vector
               S01:00E00216:  41 FA 00 92
F00:0490       	MOVE.l	a0,Wrmjpv(a3)		* set warm start vector
               S01:00E0021A:  27 48 04 02
F00:0491       	BSR		LAB_RND			* initialise
               S01:00E0021E:  61 00 21 E0
F00:0492       	JMP		LAB_WARM(a3)		* go do warm start
               S01:00E00222:  4E EB 04 00
F00:0493       
F00:0494       
F00:0495       *************************************************************************************
F00:0496       *
F00:0497       * do format error
F00:0498       
F00:0499       LAB_FOER
F00:0500       	MOVEQ		#$2C,d7			* error code $2C "Format" error
               S01:00E00226:  7E 2C
F00:0501       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00228:  60 56
F00:0502       
F00:0503       
F00:0504       *************************************************************************************
F00:0505       *
F00:0506       * do address error
F00:0507       
F00:0508       LAB_ADER
F00:0509       	MOVEQ		#$2A,d7			* error code $2A "Address" error
               S01:00E0022A:  7E 2A
F00:0510       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0022C:  60 52
F00:0511       
F00:0512       
F00:0513       *************************************************************************************
F00:0514       *
F00:0515       * do wrong dimensions error
F00:0516       
F00:0517       LAB_WDER
F00:0518       	MOVEQ		#$28,d7			* error code $28 "Wrong dimensions" error
               S01:00E0022E:  7E 28
F00:0519       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00230:  60 4E
F00:0520       
F00:0521       
F00:0522       *************************************************************************************
F00:0523       *
F00:0524       * do undimensioned array error
F00:0525       
F00:0526       LAB_UDER
F00:0527       	MOVEQ		#$26,d7			* error code $26 "undimensioned array" error
               S01:00E00232:  7E 26
F00:0528       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00234:  60 4A
F00:0529       
F00:0530       
F00:0531       *************************************************************************************
F00:0532       *
F00:0533       * do undefined variable error
F00:0534       
F00:0535       LAB_UVER
F00:0536       
F00:0537       * if you do want a non existant variable to return an error then leave the novar
F00:0538       * value at the top of this file set to zero
F00:0539       
F00:0540        ifeq	novar
F00:0541       
F00:0542       	MOVEQ		#$24,d7			* error code $24 "undefined variable" error
               S01:00E00236:  7E 24
F00:0543       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00238:  60 46
F00:0544       
F00:0545        endc
F00:0546       
F00:0547       * if you want a non existant variable to return a null value then set the novar
F00:0548       * value at the top of this file to some non zero value
F00:0549       
F00:0550        ifne	novar
F00:0551       
F00:0552       	ADD.l		d0,d0				* .......$ .......& ........ .......0
F00:0553       	SWAP		d0				* ........ .......0 .......$ .......&
F00:0554       	ROR.b		#1,d0				* ........ .......0 .......$ &.......
F00:0555       	LSR.w		#1,d0				* ........ .......0 0....... $&.....ï¿½.
F00:0556       	AND.b		#$C0,d0			* mask the type bits
F00:0557       	MOVE.b	d0,Dtypef(a3)		* save the data type
F00:0558       
F00:0559       	MOVEQ		#0,d0				* clear d0 and set the zero flag
F00:0560       	MOVEA.l	d0,a0				* return a null address
F00:0561       	RTS
F00:0562       
F00:0563        endc
F00:0564       
F00:0565       
F00:0566       *************************************************************************************
F00:0567       *
F00:0568       * do loop without do error
F00:0569       
F00:0570       LAB_LDER
F00:0571       	MOVEQ		#$22,d7			* error code $22 "LOOP without DO" error
               S01:00E0023A:  7E 22
F00:0572       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0023C:  60 42
F00:0573       
F00:0574       
F00:0575       *************************************************************************************
F00:0576       *
F00:0577       * do undefined function error
F00:0578       
F00:0579       LAB_UFER
F00:0580       	MOVEQ		#$20,d7			* error code $20 "Undefined function" error
               S01:00E0023E:  7E 20
F00:0581       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00240:  60 3E
F00:0582       
F00:0583       
F00:0584       *************************************************************************************
F00:0585       *
F00:0586       * do can't continue error
F00:0587       
F00:0588       LAB_CCER
F00:0589       	MOVEQ		#$1E,d7			* error code $1E "Can't continue" error
               S01:00E00242:  7E 1E
F00:0590       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00244:  60 3A
F00:0591       
F00:0592       
F00:0593       *************************************************************************************
F00:0594       *
F00:0595       * do string too complex error
F00:0596       
F00:0597       LAB_SCER
F00:0598       	MOVEQ		#$1C,d7			* error code $1C "String too complex" error
               S01:00E00246:  7E 1C
F00:0599       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00248:  60 36
F00:0600       
F00:0601       
F00:0602       *************************************************************************************
F00:0603       *
F00:0604       * do string too long error
F00:0605       
F00:0606       LAB_SLER
F00:0607       	MOVEQ		#$1A,d7			* error code $1A "String too long" error
               S01:00E0024A:  7E 1A
F00:0608       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0024C:  60 32
F00:0609       
F00:0610       
F00:0611       *************************************************************************************
F00:0612       *
F00:0613       * do type missmatch error
F00:0614       
F00:0615       LAB_TMER
F00:0616       	MOVEQ		#$18,d7			* error code $18 "Type mismatch" error
               S01:00E0024E:  7E 18
F00:0617       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00250:  60 2E
F00:0618       
F00:0619       
F00:0620       *************************************************************************************
F00:0621       *
F00:0622       * do illegal direct error
F00:0623       
F00:0624       LAB_IDER
F00:0625       	MOVEQ		#$16,d7			* error code $16 "Illegal direct" error
               S01:00E00252:  7E 16
F00:0626       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00254:  60 2A
F00:0627       
F00:0628       
F00:0629       *************************************************************************************
F00:0630       *
F00:0631       * do divide by zero error
F00:0632       
F00:0633       LAB_DZER
F00:0634       	MOVEQ		#$14,d7			* error code $14 "Divide by zero" error
               S01:00E00256:  7E 14
F00:0635       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00258:  60 26
F00:0636       
F00:0637       
F00:0638       *************************************************************************************
F00:0639       *
F00:0640       * do double dimension error
F00:0641       
F00:0642       LAB_DDER
F00:0643       	MOVEQ		#$12,d7			* error code $12 "Double dimension" error
               S01:00E0025A:  7E 12
F00:0644       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0025C:  60 22
F00:0645       
F00:0646       
F00:0647       *************************************************************************************
F00:0648       *
F00:0649       * do array bounds error
F00:0650       
F00:0651       LAB_ABER
F00:0652       	MOVEQ		#$10,d7			* error code $10 "Array bounds" error
               S01:00E0025E:  7E 10
F00:0653       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00260:  60 1E
F00:0654       
F00:0655       
F00:0656       *************************************************************************************
F00:0657       *
F00:0658       * do undefine satement error
F00:0659       
F00:0660       LAB_USER
F00:0661       	MOVEQ		#$0E,d7			* error code $0E "Undefined statement" error
               S01:00E00262:  7E 0E
F00:0662       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00264:  60 1A
F00:0663       
F00:0664       
F00:0665       *************************************************************************************
F00:0666       *
F00:0667       * do out of memory error
F00:0668       
F00:0669       LAB_OMER
F00:0670       	MOVEQ		#$0C,d7			* error code $0C "Out of memory" error
               S01:00E00266:  7E 0C
F00:0671       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00268:  60 16
F00:0672       
F00:0673       
F00:0674       *************************************************************************************
F00:0675       *
F00:0676       * do overflow error
F00:0677       
F00:0678       LAB_OFER
F00:0679       	MOVEQ		#$0A,d7			* error code $0A "Overflow" error
               S01:00E0026A:  7E 0A
F00:0680       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0026C:  60 12
F00:0681       
F00:0682       
F00:0683       *************************************************************************************
F00:0684       *
F00:0685       * do function call error
F00:0686       
F00:0687       LAB_FCER
F00:0688       	MOVEQ		#$08,d7			* error code $08 "Function call" error
               S01:00E0026E:  7E 08
F00:0689       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00270:  60 0E
F00:0690       
F00:0691       
F00:0692       *************************************************************************************
F00:0693       *
F00:0694       * do out of data error
F00:0695       
F00:0696       LAB_ODER
F00:0697       	MOVEQ		#$06,d7			* error code $06 "Out of DATA" error
               S01:00E00272:  7E 06
F00:0698       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00274:  60 0A
F00:0699       
F00:0700       
F00:0701       *************************************************************************************
F00:0702       *
F00:0703       * do return without gosub error
F00:0704       
F00:0705       LAB_RGER
F00:0706       	MOVEQ		#$04,d7			* error code $04 "RETURN without GOSUB" error
               S01:00E00276:  7E 04
F00:0707       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E00278:  60 06
F00:0708       
F00:0709       
F00:0710       *************************************************************************************
F00:0711       *
F00:0712       * do syntax error
F00:0713       
F00:0714       LAB_SNER
F00:0715       	MOVEQ		#$02,d7			* error code $02 "Syntax" error
               S01:00E0027A:  7E 02
F00:0716       	BRA.s		LAB_XERR			* do error #d7, then warm start
               S01:00E0027C:  60 02
F00:0717       
F00:0718       
F00:0719       *************************************************************************************
F00:0720       *
F00:0721       * do next without for error
F00:0722       
F00:0723       LAB_NFER
F00:0724       	MOVEQ		#$00,d7			* error code $00 "NEXT without FOR" error
               S01:00E0027E:  7E 00
F00:0725       
F00:0726       
F00:0727       *************************************************************************************
F00:0728       *
F00:0729       * do error #d7, then warm start
F00:0730       
F00:0731       LAB_XERR
F00:0732       	BSR		LAB_1491			* flush stack & clear continue flag
               S01:00E00280:  61 00 02 CA
F00:0733       	BSR		LAB_CRLF			* print CR/LF
               S01:00E00284:  61 00 08 08
F00:0734       	LEA		LAB_BAER(pc),a1		* start of error message pointer table
               S01:00E00288:  43 FA 32 46
F00:0735       	MOVE.w	(a1,d7.w),d7		* get error message offset
               S01:00E0028C:  3E 31 70 00
F00:0736       	LEA		(a1,d7.w),a0		* get error message address
               S01:00E00290:  41 F1 70 00
F00:0737       	BSR		LAB_18C3			* print null terminated string from memory
               S01:00E00294:  61 00 08 56
F00:0738       	LEA		LAB_EMSG(pc),a0		* point to " Error" message
               S01:00E00298:  41 FA 35 B7
F00:0739       LAB_1269
F00:0740       	BSR		LAB_18C3			* print null terminated string from memory
               S01:00E0029C:  61 00 08 4E
F00:0741       	MOVE.l	Clinel(a3),d0		* get current line
               S01:00E002A0:  20 2B 04 52
F00:0742       	BMI.s		LAB_1274			* go do warm start if -ve # (was immediate mode)
               S01:00E002A4:  6B 04
F00:0743       
F00:0744       							* else print line number
F00:0745       	BSR		LAB_2953			* print " in line [LINE #]"
               S01:00E002A6:  61 00 1D 2A
F00:0746       
F00:0747       * BASIC warm start entry point, wait for Basic command
F00:0748       
F00:0749       LAB_1274
F00:0750       	;MOVEQ		#16,d1			* turn off double buffering
F00:0751       	;MOVEQ		#92,d0			* set draw mode
F00:0752       	;TRAP		#15				* do I/O function
F00:0753       
F00:0754       	LEA		LAB_RMSG(pc),a0		* point to "Ready" message
               S01:00E002AA:  41 FA 35 D8
F00:0755       	BSR		LAB_18C3			* go do print string
               S01:00E002AE:  61 00 08 3C
F00:0756       
F00:0757       * wait for Basic command (no "Ready")
F00:0758       
F00:0759       LAB_127D
F00:0760       	MOVEQ		#-1,d1			* set to -1
               S01:00E002B2:  72 FF
F00:0761       	MOVE.l	d1,Clinel(a3)		* set current line #
               S01:00E002B4:  27 41 04 52
F00:0762       	MOVE.b	d1,Breakf(a3)		* set break flag
               S01:00E002B8:  17 41 05 DC
F00:0763       	LEA		Ibuffs(a3),a5		* set BASIC execute pointer ready for new line
               S01:00E002BC:  4B EB 04 90
F00:0764       LAB_127E
F00:0765       	BSR		LAB_1357			* call for BASIC input
               S01:00E002C0:  61 00 00 EC
F00:0766       	BSR		LAB_GBYT			* scan memory
               S01:00E002C4:  61 00 0B F2
F00:0767       	BEQ.s		LAB_127E			* loop while null
               S01:00E002C8:  67 F6
F00:0768       
F00:0769       * got to interpret input line now ....
F00:0770       
F00:0771       	BCS.s		LAB_1295			* branch if numeric character, handle new
               S01:00E002CA:  65 08
F00:0772       							* BASIC line
F00:0773       
F00:0774       							* no line number so do immediate mode, a5
F00:0775       							* points to the buffer start
F00:0776       	BSR		LAB_13A6			* crunch keywords into Basic tokens
               S01:00E002CC:  61 00 01 56
F00:0777       							* crunch from (a5), output to (a0)
F00:0778       							* returns ..
F00:0779       							* d2 is length, d1 trashed, d0 trashed,
F00:0780       							* a1 trashed
F00:0781       	BRA		LAB_15F6			* go scan & interpret code
               S01:00E002D0:  60 00 03 C2
F00:0782       
F00:0783       
F00:0784       *************************************************************************************
F00:0785       *
F00:0786       * handle a new BASIC line
F00:0787       
F00:0788       LAB_1295
F00:0789       	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E002D4:  61 00 06 38
F00:0790       	BSR		LAB_13A6			* crunch keywords into Basic tokens
               S01:00E002D8:  61 00 01 4A
F00:0791       							* crunch from (a5), output to (a0)
F00:0792       							* returns .. d2 is length,
F00:0793       							* d1 trashed, d0 trashed, a1 trashed
F00:0794       	MOVE.l	Itemp(a3),d1		* get required line #
               S01:00E002DC:  22 2B 04 2A
F00:0795       	BSR		LAB_SSLN			* search BASIC for d1 line number
               S01:00E002E0:  61 00 02 18
F00:0796       							* returns pointer in a0
F00:0797       	BCS.s		LAB_12E6			* branch if not found
               S01:00E002E4:  65 32
F00:0798       
F00:0799       							* aroooogah! line # already exists! delete it
F00:0800       	MOVEA.l	(a0),a1			* get start of block (next line pointer)
               S01:00E002E6:  22 50
F00:0801       	MOVE.l	Sfncl(a3),d0		* get end of block (start of functions)
               S01:00E002E8:  20 2B 04 32
F00:0802       	SUB.l		a1,d0				* subtract start of block ( = bytes to move)
               S01:00E002EC:  90 89
F00:0803       	LSR.l		#1,d0				* /2 (word move)
               S01:00E002EE:  E2 88
F00:0804       	SUBQ.l	#1,d0				* adjust for DBF loop
               S01:00E002F0:  53 80
F00:0805       	SWAP		d0				* swap high word to low word
               S01:00E002F2:  48 40
F00:0806       	MOVEA.l	a0,a2				* copy destination
               S01:00E002F4:  24 48
F00:0807       LAB_12AE
F00:0808       	SWAP		d0				* swap high word to low word
               S01:00E002F6:  48 40
F00:0809       LAB_12B0
F00:0810       	MOVE.w	(a1)+,(a2)+			* copy word
               S01:00E002F8:  34 D9
F00:0811       	DBF		d0,LAB_12B0			* decrement low count and loop until done
               S01:00E002FA:  51 C8 FF FC
F00:0812       
F00:0813       	SWAP		d0				* swap high word to low word
               S01:00E002FE:  48 40
F00:0814       	DBF		d0,LAB_12AE			* decrement high count and loop until done
               S01:00E00300:  51 C8 FF F4
F00:0815       
F00:0816       	MOVE.l	a2,Sfncl(a3)		* start of functions
               S01:00E00304:  27 4A 04 32
F00:0817       	MOVE.l	a2,Svarl(a3)		* save start of variables
               S01:00E00308:  27 4A 04 36
F00:0818       	MOVE.l	a2,Sstrl(a3)		* start of strings
               S01:00E0030C:  27 4A 04 3A
F00:0819       	MOVE.l	a2,Sarryl(a3)		* save start of arrays
               S01:00E00310:  27 4A 04 3E
F00:0820       	MOVE.l	a2,Earryl(a3)		* save end of arrays
               S01:00E00314:  27 4A 04 42
F00:0821       
F00:0822       							* got new line in buffer and no existing same #
F00:0823       LAB_12E6
F00:0824       	MOVE.b	Ibuffs(a3),d0		* get byte from start of input buffer
               S01:00E00318:  10 2B 04 90
F00:0825       	BEQ.s		LAB_1325			* if null line go do line chaining
               S01:00E0031C:  67 64
F00:0826       
F00:0827       							* got new line and it isn't empty line
F00:0828       	MOVEA.l	Sfncl(a3),a1		* get start of functions (end of block to move)
               S01:00E0031E:  22 6B 04 32
F00:0829       	LEA		8(a1,d2),a2			* copy it, add line length and add room for
               S01:00E00322:  45 F1 20 08
F00:0830       							* pointer and line number
F00:0831       
F00:0832       	MOVE.l	a2,Sfncl(a3)		* start of functions
               S01:00E00326:  27 4A 04 32
F00:0833       	MOVE.l	a2,Svarl(a3)		* save start of variables
               S01:00E0032A:  27 4A 04 36
F00:0834       	MOVE.l	a2,Sstrl(a3)		* start of strings
               S01:00E0032E:  27 4A 04 3A
F00:0835       	MOVE.l	a2,Sarryl(a3)		* save start of arrays
               S01:00E00332:  27 4A 04 3E
F00:0836       	MOVE.l	a2,Earryl(a3)		* save end of arrays
               S01:00E00336:  27 4A 04 42
F00:0837       	MOVE.l	Ememl(a3),Sstorl(a3)	* copy end of mem to start of strings, clear
               S01:00E0033A:  27 6B 04 4A 04 46
F00:0838       							* strings
F00:0839       
F00:0840       	MOVE.l	a1,d1				* copy end of block to move
               S01:00E00340:  22 09
F00:0841       	SUB.l		a0,d1				* subtract start of block to move
               S01:00E00342:  92 88
F00:0842       	LSR.l		#1,d1				* /2 (word copy)
               S01:00E00344:  E2 89
F00:0843       	SUBQ.l	#1,d1				* correct for loop end on -1
               S01:00E00346:  53 81
F00:0844       	SWAP		d1				* swap high word to low word
               S01:00E00348:  48 41
F00:0845       LAB_12FF
F00:0846       	SWAP		d1				* swap high word to low word
               S01:00E0034A:  48 41
F00:0847       LAB_1301
F00:0848       	MOVE.w	-(a1),-(a2)			* decrement pointers and copy word
               S01:00E0034C:  35 21
F00:0849       	DBF		d1,LAB_1301			* decrement & loop
               S01:00E0034E:  51 C9 FF FC
F00:0850       
F00:0851       	SWAP		d1				* swap high word to low word
               S01:00E00352:  48 41
F00:0852       	DBF		d1,LAB_12FF			* decrement high count and loop until done
               S01:00E00354:  51 C9 FF F4
F00:0853       
F00:0854       * space is opened up, now copy the crunched line from the input buffer into the space
F00:0855       
F00:0856       	LEA		Ibuffs(a3),a1		* source is input buffer
               S01:00E00358:  43 EB 04 90
F00:0857       	MOVEA.l	a0,a2				* copy destination
               S01:00E0035C:  24 48
F00:0858       	MOVEQ		#-1,d1			* set to allow re-chaining
               S01:00E0035E:  72 FF
F00:0859       	MOVE.l	d1,(a2)+			* set next line pointer (allow re-chaining)
               S01:00E00360:  24 C1
F00:0860       	MOVE.l	Itemp(a3),(a2)+		* save line number
               S01:00E00362:  24 EB 04 2A
F00:0861       	LSR.w		#1,d2				* /2 (word copy)
               S01:00E00366:  E2 4A
F00:0862       	SUBQ.w	#1,d2				* correct for loop end on -1
               S01:00E00368:  53 42
F00:0863       LAB_1303
F00:0864       	MOVE.w	(a1)+,(a2)+			* copy word
               S01:00E0036A:  34 D9
F00:0865       	DBF		d2,LAB_1303			* decrement & loop
               S01:00E0036C:  51 CA FF FC
F00:0866       
F00:0867       	BRA.s		LAB_1325			* go test for end of prog
               S01:00E00370:  60 10
F00:0868       
F00:0869       * rebuild chaining of Basic lines
F00:0870       
F00:0871       LAB_132E
F00:0872       	ADDQ.w	#8,a0				* point to first code byte of line, there is
               S01:00E00372:  50 48
F00:0873       							* always 1 byte + [EOL] as null entries are
F00:0874       							* deleted
F00:0875       LAB_1330
F00:0876       	TST.b		(a0)+				* test byte	
               S01:00E00374:  4A 18
F00:0877       	BNE.s		LAB_1330			* loop if not [EOL]
               S01:00E00376:  66 FC
F00:0878       
F00:0879       							* was [EOL] so get next line start
F00:0880       	MOVE.w	a0,d1				* past pad byte(s)
               S01:00E00378:  32 08
F00:0881       	ANDI.w	#1,d1				* mask odd bit
               S01:00E0037A:  02 41 00 01
F00:0882       	ADD.w		d1,a0				* add back to ensure even
               S01:00E0037E:  D0 C1
F00:0883       	MOVE.l	a0,(a1)			* save next line pointer to current line
               S01:00E00380:  22 88
F00:0884       LAB_1325
F00:0885       	MOVEA.l	a0,a1				* copy pointer for this line
               S01:00E00382:  22 48
F00:0886       	TST.l		(a0)				* test pointer to next line
               S01:00E00384:  4A 90
F00:0887       	BNE.s		LAB_132E			* not end of program yet so we must
               S01:00E00386:  66 EA
F00:0888       							* go and fix the pointers
F00:0889       
F00:0890       	BSR		LAB_1477			* reset execution to start, clear variables
               S01:00E00388:  61 00 01 98
F00:0891       							* and flush stack
F00:0892       	BRA		LAB_127D			* now we just wait for Basic command, no "Ready"
               S01:00E0038C:  60 00 FF 24
F00:0893       
F00:0894       
F00:0895       *************************************************************************************
F00:0896       *
F00:0897       * receive a line from the keyboard
F00:0898       							* character $08 as delete key, BACKSPACE on
F00:0899       							* standard keyboard
F00:0900       LAB_134B
F00:0901       	BSR		LAB_PRNA			* go print the character
               S01:00E00390:  61 00 07 74
F00:0902       	MOVEQ		#' ',d0			* load [SPACE]
               S01:00E00394:  70 20
F00:0903       	BSR		LAB_PRNA			* go print
               S01:00E00396:  61 00 07 6E
F00:0904       	MOVEQ		#$08,d0			* load [BACKSPACE]
               S01:00E0039A:  70 08
F00:0905       	BSR		LAB_PRNA			* go print
               S01:00E0039C:  61 00 07 68
F00:0906       	SUBQ.w	#$01,d1			* decrement the buffer index (delete)
               S01:00E003A0:  53 41
F00:0907       	BRA.s		LAB_1359			* re-enter loop
               S01:00E003A2:  60 10
F00:0908       
F00:0909       * print "? " and get BASIC input
F00:0910       * return a0 pointing to the buffer start
F00:0911       
F00:0912       LAB_INLN
F00:0913       	BSR		LAB_18E3			* print "?" character
               S01:00E003A4:  61 00 07 5E
F00:0914       	MOVEQ		#' ',d0			* load " "
               S01:00E003A8:  70 20
F00:0915       	BSR		LAB_PRNA			* go print
               S01:00E003AA:  61 00 07 5A
F00:0916       
F00:0917       * call for BASIC input (main entry point)
F00:0918       * return a0 pointing to the buffer start
F00:0919       
F00:0920       LAB_1357
F00:0921       	MOVEQ		#$00,d1			* clear buffer index
               S01:00E003AE:  72 00
F00:0922       	LEA		Ibuffs(a3),a0		* set buffer base pointer
               S01:00E003B0:  41 EB 04 90
F00:0923       LAB_1359
F00:0924       	JSR		V_INPT(a3)			* call scan input device
               S01:00E003B4:  4E AB 04 0C
F00:0925       	BCC.s		LAB_1359			* loop if no byte
               S01:00E003B8:  64 FA
F00:0926       
F00:0927       	BEQ.s		LAB_1359			* loop if null byte
               S01:00E003BA:  67 F8
F00:0928       
F00:0929       	CMP.b		#$07,d0			* compare with [BELL]
               S01:00E003BC:  B0 3C 00 07
F00:0930       	BEQ.s		LAB_1378			* branch if [BELL]
               S01:00E003C0:  67 18
F00:0931       
F00:0932       	CMP.b		#$0D,d0			* compare with [CR]
               S01:00E003C2:  B0 3C 00 0D
F00:0933       	BEQ		LAB_1866			* do CR/LF exit if [CR]
               S01:00E003C6:  67 00 06 C0
F00:0934       
F00:0935       	TST.w		d1				* set flags on buffer index
               S01:00E003CA:  4A 41
F00:0936       	BNE.s		LAB_1374			* branch if not empty
               S01:00E003CC:  66 06
F00:0937       
F00:0938       * the next two lines ignore any non printing character and [SPACE] if the input buffer
F00:0939       * is empty
F00:0940       
F00:0941       	CMP.b		#' ',d0			* compare with [SP]+1
               S01:00E003CE:  B0 3C 00 20
F00:0942       	BLS.s		LAB_1359			* if < ignore character
               S01:00E003D2:  63 E0
F00:0943       
F00:0944       *##	CMP.b		#' '+1,d0			* compare with [SP]+1
F00:0945       *##	BCS.s		LAB_1359			* if < ignore character
F00:0946       
F00:0947       LAB_1374
F00:0948       	CMP.b		#$08,d0			* compare with [BACKSPACE]
               S01:00E003D4:  B0 3C 00 08
F00:0949       	BEQ.s		LAB_134B			* go delete last character
               S01:00E003D8:  67 B6
F00:0950       
F00:0951       LAB_1378
F00:0952       	CMP.w		#(Ibuffe-Ibuffs-1),d1	* compare character count with max-1
               S01:00E003DA:  B2 7C 00 FF
F00:0953       	BCC.s		LAB_138E			* skip store & do [BELL] if buffer full
               S01:00E003DE:  64 0C
F00:0954       
F00:0955       	MOVE.b	d0,(a0,d1.w)		* else store in buffer
               S01:00E003E0:  11 80 10 00
F00:0956       	ADDQ.w	#$01,d1			* increment index
               S01:00E003E4:  52 41
F00:0957       LAB_137F
F00:0958       	BSR		LAB_PRNA			* go print the character
               S01:00E003E6:  61 00 07 1E
F00:0959       	BRA.s		LAB_1359			* always loop for next character
               S01:00E003EA:  60 C8
F00:0960       
F00:0961       * announce buffer full
F00:0962       
F00:0963       LAB_138E
F00:0964       	MOVEQ		#$07,d0			* [BELL] character into d0
               S01:00E003EC:  70 07
F00:0965       	BRA.s		LAB_137F			* go print the [BELL] but ignore input character
               S01:00E003EE:  60 F6
F00:0966       
F00:0967       
F00:0968       *************************************************************************************
F00:0969       *
F00:0970       * copy a hex value without crunching
F00:0971       
F00:0972       LAB_1392
F00:0973       	MOVE.b	d0,(a0,d2.w)		* save the byte to the output
               S01:00E003F0:  11 80 20 00
F00:0974       	ADDQ.w	#1,d2				* increment the buffer save index
               S01:00E003F4:  52 42
F00:0975       
F00:0976       	ADDQ.w	#1,d1				* increment the buffer read index
               S01:00E003F6:  52 41
F00:0977       	MOVE.b	(a5,d1.w),d0		* get a byte from the input buffer
               S01:00E003F8:  10 35 10 00
F00:0978       	BEQ		LAB_13EC			* if [EOL] go save it without crunching
               S01:00E003FC:  67 00 00 94
F00:0979       
F00:0980       	CMP.b		#' ',d0			* compare the character with " "
               S01:00E00400:  B0 3C 00 20
F00:0981       	BEQ.s		LAB_1392			* if [SPACE] just go save it and get another
               S01:00E00404:  67 EA
F00:0982       
F00:0983       	CMP.b		#'0',d0			* compare the character with "0"
               S01:00E00406:  B0 3C 00 30
F00:0984       	BCS.s		LAB_13C6			* if < "0" quit the hex save loop
               S01:00E0040A:  65 4A
F00:0985       
F00:0986       	CMP.b		#'9',d0			* compare with "9"
               S01:00E0040C:  B0 3C 00 39
F00:0987       	BLS.s		LAB_1392			* if it is "0" to "9" save it and get another
               S01:00E00410:  63 DE
F00:0988       
F00:0989       	MOVEQ		#-33,d5			* mask xx0x xxxx, ASCII upper case
               S01:00E00412:  7A DF
F00:0990       	AND.b		d0,d5				* mask the character
               S01:00E00414:  CA 00
F00:0991       
F00:0992       	CMP.b		#'A',d5			* compare with "A"
               S01:00E00416:  BA 3C 00 41
F00:0993       	BCS.s		LAB_13CC			* if < "A" quit the hex save loop
               S01:00E0041A:  65 40
F00:0994       
F00:0995       	CMP.b		#'F',d5			* compare with "F"
               S01:00E0041C:  BA 3C 00 46
F00:0996       	BLS.s		LAB_1392			* if it is "A" to "F" save it and get another
               S01:00E00420:  63 CE
F00:0997       
F00:0998       	BRA.s		LAB_13CC			* else continue crunching
               S01:00E00422:  60 38
F00:0999       
F00:1000       * crunch keywords into Basic tokens
F00:1001       * crunch from (a5), output to (a0)
F00:1002       * returns ..
F00:1003       * d4 trashed
F00:1004       * d3 trashed
F00:1005       * d2 is length
F00:1006       * d1 trashed
F00:1007       * d0 trashed
F00:1008       * a1 trashed
F00:1009       
F00:1010       * this is the improved BASIC crunch routine and is 10 to 100 times faster than the
F00:1011       * old list search
F00:1012       
F00:1013       LAB_13A6
F00:1014       	MOVEQ		#0,d1				* clear the read index
               S01:00E00424:  72 00
F00:1015       	MOVE.l	d1,d2				* clear the save index
               S01:00E00426:  24 01
F00:1016       	MOVE.b	d1,Oquote(a3)		* clear the open quote/DATA flag
               S01:00E00428:  17 41 05 DD
F00:1017       LAB_13AC
F00:1018       	MOVEQ		#0,d0				* clear word
               S01:00E0042C:  70 00
F00:1019       	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
               S01:00E0042E:  10 35 10 00
F00:1020       	BEQ.s		LAB_13EC			* if null save byte then continue crunching
               S01:00E00432:  67 5E
F00:1021       
F00:1022       	CMP.b		#'_',d0			* compare with "_"
               S01:00E00434:  B0 3C 00 5F
F00:1023       	BCC.s		LAB_13EC			* if >= "_" save byte then continue crunching
               S01:00E00438:  64 58
F00:1024       
F00:1025       	CMP.b		#'<',d0			* compare with "<"
               S01:00E0043A:  B0 3C 00 3C
F00:1026       	BCC.s		LAB_13CC			* if >= "<" go crunch
               S01:00E0043E:  64 1C
F00:1027       
F00:1028       	CMP.b		#'0',d0			* compare with "0"
               S01:00E00440:  B0 3C 00 30
F00:1029       	BCC.s		LAB_13EC			* if >= "0" save byte then continue crunching
               S01:00E00444:  64 4C
F00:1030       
F00:1031       	MOVE.b	d0,Asrch(a3)		* save buffer byte as search character
               S01:00E00446:  17 40 05 DA
F00:1032       	CMP.b		#$22,d0			* is it quote character?
               S01:00E0044A:  B0 3C 00 22
F00:1033       	BEQ.s		LAB_1410			* branch if so (copy quoted string)
               S01:00E0044E:  67 76
F00:1034       
F00:1035       	CMP.b		#'$',d0			* is it the hex value character?
               S01:00E00450:  B0 3C 00 24
F00:1036       	BEQ.s		LAB_1392			* if so go copy a hex value
               S01:00E00454:  67 9A
F00:1037       
F00:1038       LAB_13C6
F00:1039       	CMP.b		#'*',d0			* compare with "*"
               S01:00E00456:  B0 3C 00 2A
F00:1040       	BCS.s		LAB_13EC			* if <= "*" save byte then continue crunching
               S01:00E0045A:  65 36
F00:1041       
F00:1042       							* crunch rest
F00:1043       LAB_13CC
F00:1044       	BTST.b	#6,Oquote(a3)		* test open quote/DATA token flag
               S01:00E0045C:  08 2B 00 06 05 DD
F00:1045       	BNE.s		LAB_13EC			* branch if b6 of Oquote set (was DATA)
               S01:00E00462:  66 2E
F00:1046       							* go save byte then continue crunching
F00:1047       
F00:1048       	SUB.b		#$2A,d0			* normalise byte
               S01:00E00464:  90 3C 00 2A
F00:1049       	ADD.w		d0,d0				* *2 makes word offset (high byte=$00)
               S01:00E00468:  D0 40
F00:1050       	LEA		TAB_CHRT(pc),a1		* get keyword offset table address
               S01:00E0046A:  43 FA 2E 2A
F00:1051       	MOVE.w	(a1,d0.w),d0		* get offset into keyword table
               S01:00E0046E:  30 31 00 00
F00:1052       	BMI.s		LAB_141F			* branch if no keywords for character
               S01:00E00472:  6B 6E
F00:1053       
F00:1054       	LEA		TAB_STAR(pc),a1		* get keyword table address
               S01:00E00474:  43 FA 31 E0
F00:1055       	ADDA.w	d0,a1				* add keyword offset
               S01:00E00478:  D2 C0
F00:1056       	MOVEQ		#-1,d3			* clear index
               S01:00E0047A:  76 FF
F00:1057       	MOVE.w	d1,d4				* copy read index
               S01:00E0047C:  38 01
F00:1058       LAB_13D6
F00:1059       	ADDQ.w	#1,d3				* increment table index
               S01:00E0047E:  52 43
F00:1060       	MOVE.b	(a1,d3.w),d0		* get byte from table
               S01:00E00480:  10 31 30 00
F00:1061       LAB_13D8
F00:1062       	BMI.s		LAB_13EA			* branch if is token, save token and continue
               S01:00E00484:  6B 0A
F00:1063       							* crunching
F00:1064       
F00:1065       	ADDQ.w	#1,d4				* increment read index
               S01:00E00486:  52 44
F00:1066       	CMP.b		(a5,d4.w),d0		* compare byte from input buffer
               S01:00E00488:  B0 35 40 00
F00:1067       	BEQ.s		LAB_13D6			* loop if character match
               S01:00E0048C:  67 F0
F00:1068       
F00:1069       	BRA.s		LAB_1417			* branch if no match
               S01:00E0048E:  60 40
F00:1070       
F00:1071       LAB_13EA
F00:1072       	MOVE.w	d4,d1				* update read index
               S01:00E00490:  32 04
F00:1073       LAB_13EC
F00:1074       	MOVE.b	d0,(a0,d2.w)		* save byte to output
               S01:00E00492:  11 80 20 00
F00:1075       	ADDQ.w	#1,d2				* increment buffer save index
               S01:00E00496:  52 42
F00:1076       	ADDQ.w	#1,d1				* increment buffer read index
               S01:00E00498:  52 41
F00:1077       	TST.b		d0				* set flags
               S01:00E0049A:  4A 00
F00:1078       	BEQ.s		LAB_142A			* branch if was null [EOL]
               S01:00E0049C:  67 4A
F00:1079       
F00:1080       							* d0 holds token or byte here
F00:1081       	SUB.b		#$3A,d0			* subtract ":"
               S01:00E0049E:  90 3C 00 3A
F00:1082       	BEQ.s		LAB_13FF			* branch if it was ":" (is now $00)
               S01:00E004A2:  67 06
F00:1083       
F00:1084       							* d0 now holds token-$3A
F00:1085       	CMP.b		#(TK_DATA-$3A),d0		* compare with DATA token - $3A
               S01:00E004A4:  B0 3C 00 49
F00:1086       	BNE.s		LAB_1401			* branch if not DATA
               S01:00E004A8:  66 04
F00:1087       
F00:1088       							* token was : or DATA
F00:1089       LAB_13FF
F00:1090       	MOVE.b	d0,Oquote(a3)		* save token-$3A ($00 for ":", TK_DATA-$3A for
               S01:00E004AA:  17 40 05 DD
F00:1091       							* DATA)
F00:1092       LAB_1401
F00:1093       	SUB.b		#(TK_REM-$3A),d0		* subtract REM token offset
               S01:00E004AE:  90 3C 00 55
F00:1094       	BNE		LAB_13AC			* If wasn't REM then go crunch rest of line
               S01:00E004B2:  66 00 FF 78
F00:1095       
F00:1096       	MOVE.b	d0,Asrch(a3)		* else was REM so set search for [EOL]
               S01:00E004B6:  17 40 05 DA
F00:1097       
F00:1098       							* loop for REM, "..." etc.
F00:1099       LAB_1408
F00:1100       	MOVE.b	(a5,d1.w),d0		* get byte from input buffer
               S01:00E004BA:  10 35 10 00
F00:1101       	BEQ.s		LAB_13EC			* branch if null [EOL]
               S01:00E004BE:  67 D2
F00:1102       
F00:1103       	CMP.b		Asrch(a3),d0		* compare with stored character
               S01:00E004C0:  B0 2B 05 DA
F00:1104       	BEQ.s		LAB_13EC			* branch if match (end quote, REM, :, or DATA)
               S01:00E004C4:  67 CC
F00:1105       
F00:1106       							* entry for copy string in quotes, don't crunch
F00:1107       LAB_1410
F00:1108       	MOVE.b	d0,(a0,d2.w)		* save byte to output
               S01:00E004C6:  11 80 20 00
F00:1109       	ADDQ.w	#1,d2				* increment buffer save index
               S01:00E004CA:  52 42
F00:1110       	ADDQ.w	#1,d1				* increment buffer read index
               S01:00E004CC:  52 41
F00:1111       	BRA.s		LAB_1408			* loop
               S01:00E004CE:  60 EA
F00:1112       
F00:1113       * not found keyword this go so find the end of this word in the table
F00:1114       
F00:1115       LAB_1417
F00:1116       	MOVE.w	d1,d4				* reset read pointer
               S01:00E004D0:  38 01
F00:1117       LAB_141B
F00:1118       	ADDQ.w	#1,d3				* increment keyword table pointer, flag
               S01:00E004D2:  52 43
F00:1119       							* unchanged
F00:1120       	MOVE.b	(a1,d3.w),d0		* get keyword table byte
               S01:00E004D4:  10 31 30 00
F00:1121       	BPL.s		LAB_141B			* if not end of keyword go do next byte
               S01:00E004D8:  6A F8
F00:1122       
F00:1123       	ADDQ.w	#1,d3				* increment keyword table pointer flag
               S01:00E004DA:  52 43
F00:1124       							* unchanged
F00:1125       	MOVE.b	(a1,d3.w),d0		* get keyword table byte
               S01:00E004DC:  10 31 30 00
F00:1126       	BNE.s		LAB_13D8			* go test next word if not zero byte (table end)
               S01:00E004E0:  66 A2
F00:1127       
F00:1128       							* reached end of table with no match
F00:1129       LAB_141F
F00:1130       	MOVE.b	(a5,d1.w),d0		* restore byte from input buffer
               S01:00E004E2:  10 35 10 00
F00:1131       	BRA.s		LAB_13EC			* go save byte in output and continue crunching
               S01:00E004E6:  60 AA
F00:1132       
F00:1133       							* reached [EOL]
F00:1134       LAB_142A
F00:1135       	MOVEQ		#0,d0				* ensure longword clear
               S01:00E004E8:  70 00
F00:1136       	BTST		d0,d2				* test odd bit (fastest)
               S01:00E004EA:  01 02
F00:1137       	BEQ.s		LAB_142C			* branch if no bytes to fill
               S01:00E004EC:  67 06
F00:1138       
F00:1139       	MOVE.b	d0,(a0,d2.w)		* clear next byte
               S01:00E004EE:  11 80 20 00
F00:1140       	ADDQ.w	#1,d2				* increment buffer save index
               S01:00E004F2:  52 42
F00:1141       LAB_142C
F00:1142       	MOVE.l	d0,(a0,d2.w)		* clear next line pointer, EOT in immediate mode
               S01:00E004F4:  21 80 20 00
F00:1143       	RTS
               S01:00E004F8:  4E 75
F00:1144       
F00:1145       
F00:1146       *************************************************************************************
F00:1147       *
F00:1148       * search Basic for d1 line number from start of mem
F00:1149       
F00:1150       LAB_SSLN
F00:1151       	MOVEA.l	Smeml(a3),a0		* get start of program mem
               S01:00E004FA:  20 6B 04 2E
F00:1152       	BRA.s		LAB_SCLN			* go search for required line from a0
               S01:00E004FE:  60 02
F00:1153       
F00:1154       LAB_145F
F00:1155       	MOVEA.l	d0,a0				* copy next line pointer
               S01:00E00500:  20 40
F00:1156       
F00:1157       * search Basic for d1 line number from a0
F00:1158       * returns Cb=0 if found
F00:1159       * returns a0 pointer to found or next higher (not found) line
F00:1160       
F00:1161       LAB_SCLN
F00:1162       	MOVE.l	(a0)+,d0			* get next line pointer and point to line #
               S01:00E00502:  20 18
F00:1163       	BEQ.s		LAB_145E			* is end marker so we're done, do 'no line' exit
               S01:00E00504:  67 08
F00:1164       
F00:1165       	CMP.l		(a0),d1			* compare this line # with required line #
               S01:00E00506:  B2 90
F00:1166       	BGT.s		LAB_145F			* loop if required # > this #
               S01:00E00508:  6E F6
F00:1167       
F00:1168       	SUBQ.w	#4,a0				* adjust pointer, flags not changed
               S01:00E0050A:  59 48
F00:1169       	RTS
               S01:00E0050C:  4E 75
F00:1170       
F00:1171       LAB_145E
F00:1172       	SUBQ.w	#4,a0				* adjust pointer, flags not changed
               S01:00E0050E:  59 48
F00:1173       	SUBQ.l	#1,d0				* make end program found = -1, set carry
               S01:00E00510:  53 80
F00:1174       	RTS
               S01:00E00512:  4E 75
F00:1175       
F00:1176       
F00:1177       *************************************************************************************
F00:1178       *
F00:1179       * perform NEW
F00:1180       
F00:1181       LAB_NEW
F00:1182       	BNE.s		RTS_005			* exit if not end of statement (do syntax error)
               S01:00E00514:  66 4C
F00:1183       
F00:1184       LAB_1463
F00:1185       	MOVEA.l	Smeml(a3),a0		* point to start of program memory
               S01:00E00516:  20 6B 04 2E
F00:1186       	MOVEQ		#0,d0				* clear longword
               S01:00E0051A:  70 00
F00:1187       	MOVE.l	d0,(a0)+			* clear first line, next line pointer
               S01:00E0051C:  20 C0
F00:1188       	MOVE.l	a0,Sfncl(a3)		* set start of functions
               S01:00E0051E:  27 48 04 32
F00:1189       
F00:1190       * reset execution to start, clear variables and flush stack
F00:1191       
F00:1192       LAB_1477
F00:1193       	MOVEA.l	Smeml(a3),a5		* reset BASIC execute pointer
               S01:00E00522:  2A 6B 04 2E
F00:1194       	SUBQ.w	#1,a5				* -1 (as end of previous line)
               S01:00E00526:  53 4D
F00:1195       
F00:1196       * "CLEAR" command gets here
F00:1197       
F00:1198       LAB_147A
F00:1199       	MOVE.l	Ememl(a3),Sstorl(a3)	* save end of mem as bottom of string space
               S01:00E00528:  27 6B 04 4A 04 46
F00:1200       	MOVE.l	Sfncl(a3),d0		* get start of functions
               S01:00E0052E:  20 2B 04 32
F00:1201       	MOVE.l	d0,Svarl(a3)		* start of variables
               S01:00E00532:  27 40 04 36
F00:1202       	MOVE.l	d0,Sstrl(a3)		* start of strings
               S01:00E00536:  27 40 04 3A
F00:1203       	MOVE.l	d0,Sarryl(a3)		* set start of arrays
               S01:00E0053A:  27 40 04 3E
F00:1204       	MOVE.l	d0,Earryl(a3)		* set end of arrays
               S01:00E0053E:  27 40 04 42
F00:1205       	MOVEQ		#0,d0				* set Zb
               S01:00E00542:  70 00
F00:1206       	MOVE.b	d0,ccnull(a3)		* clear get byte countdown
               S01:00E00544:  17 40 05 EA
F00:1207       	BSR		LAB_RESTORE			* perform RESTORE command
               S01:00E00548:  61 00 01 CC
F00:1208       
F00:1209       * flush stack & clear continue flag
F00:1210       
F00:1211       LAB_1491
F00:1212       	LEA		des_sk(a3),a4		* reset descriptor stack pointer
               S01:00E0054C:  49 EB 04 8E
F00:1213       
F00:1214       	MOVE.l	(sp)+,d0			* pull return address
               S01:00E00550:  20 1F
F00:1215       	LEA		ram_base(a3),sp		* set stack to RAM start + 1k, flush stack
               S01:00E00552:  4F EB 04 00
F00:1216       	MOVE.l	d0,-(sp)			* restore return address
               S01:00E00556:  2F 00
F00:1217       
F00:1218       	MOVEQ		#0,d0				* clear longword
               S01:00E00558:  70 00
F00:1219       	MOVE.l	d0,Cpntrl(a3)		* clear continue pointer
               S01:00E0055A:  27 40 04 5A
F00:1220       	MOVE.b	d0,Sufnxf(a3)		* clear subscript/FNX flag
               S01:00E0055E:  17 40 05 DF
F00:1221       RTS_005
F00:1222       	RTS
               S01:00E00562:  4E 75
F00:1223       
F00:1224       
F00:1225       *************************************************************************************
F00:1226       *
F00:1227       * perform CLEAR
F00:1228       
F00:1229       LAB_CLEAR
F00:1230       	BEQ.s		LAB_147A			* if no following byte go do "CLEAR"
               S01:00E00564:  67 C2
F00:1231       
F00:1232       	RTS						* was following byte (go do syntax error)
               S01:00E00566:  4E 75
F00:1233       
F00:1234       
F00:1235       *************************************************************************************
F00:1236       *
F00:1237       * perform LIST [n][-m]
F00:1238       
F00:1239       LAB_LIST
F00:1240       	BCS.s		LAB_14BD			* branch if next character numeric (LIST n...)
               S01:00E00568:  65 12
F00:1241       
F00:1242       	MOVEQ		#-1,d1			* set end to $FFFFFFFF
               S01:00E0056A:  72 FF
F00:1243       	MOVE.l	d1,Itemp(a3)		* save to Itemp
               S01:00E0056C:  27 41 04 2A
F00:1244       
F00:1245       	MOVEQ		#0,d1				* set start to $00000000
               S01:00E00570:  72 00
F00:1246       	TST.b		d0				* test next byte
               S01:00E00572:  4A 00
F00:1247       	BEQ.s		LAB_14C0			* branch if next character [NULL] (LIST)
               S01:00E00574:  67 0A
F00:1248       
F00:1249       	CMP.b		#TK_MINUS,d0		* compare with token for -
               S01:00E00576:  B0 3C 00 C0
F00:1250       	BNE.s		RTS_005			* exit if not - (LIST -m)
               S01:00E0057A:  66 E6
F00:1251       
F00:1252       							* LIST [[n]-[m]] this sets the n, if present,
F00:1253       							* as the start and end
F00:1254       LAB_14BD
F00:1255       	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E0057C:  61 00 03 90
F00:1256       LAB_14C0
F00:1257       	BSR		LAB_SSLN			* search BASIC for d1 line number
               S01:00E00580:  61 00 FF 78
F00:1258       							* (pointer in a0)
F00:1259       	BSR		LAB_GBYT			* scan memory
               S01:00E00584:  61 00 09 32
F00:1260       	BEQ.s		LAB_14D4			* branch if no more characters
               S01:00E00588:  67 16
F00:1261       
F00:1262       							* this bit checks the - is present
F00:1263       	CMP.b		#TK_MINUS,d0		* compare with token for -
               S01:00E0058A:  B0 3C 00 C0
F00:1264       	BNE.s		RTS_005			* return if not "-" (will be Syntax error)
               S01:00E0058E:  66 D2
F00:1265       
F00:1266       	MOVEQ		#-1,d1			* set end to $FFFFFFFF
               S01:00E00590:  72 FF
F00:1267       	MOVE.l	d1,Itemp(a3)		* save Itemp
               S01:00E00592:  27 41 04 2A
F00:1268       
F00:1269       							* LIST [n]-[m] the - was there so see if
F00:1270       							* there is an m to set as the end value
F00:1271       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E00596:  61 00 09 1E
F00:1272       	BEQ.s		LAB_14D4			* branch if was [NULL] (LIST n-)
               S01:00E0059A:  67 04
F00:1273       
F00:1274       	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E0059C:  61 00 03 70
F00:1275       LAB_14D4
F00:1276       	MOVE.b	#$00,Oquote(a3)		* clear open quote flag
               S01:00E005A0:  17 7C 00 00 05 DD
F00:1277       	BSR		LAB_CRLF			* print CR/LF
               S01:00E005A6:  61 00 04 E6
F00:1278       	MOVE.l	(a0)+,d0			* get next line pointer
               S01:00E005AA:  20 18
F00:1279       	BEQ.s		RTS_005			* if null all done so exit
               S01:00E005AC:  67 B4
F00:1280       
F00:1281       	MOVEA.l	d0,a1				* copy next line pointer
               S01:00E005AE:  22 40
F00:1282       	BSR		LAB_1629			* do CRTL-C check vector
               S01:00E005B0:  61 00 01 2A
F00:1283       
F00:1284       	MOVE.l	(a0)+,d0			* get this line #
               S01:00E005B4:  20 18
F00:1285       	CMP.l		Itemp(a3),d0		* compare end line # with this line #
               S01:00E005B6:  B0 AB 04 2A
F00:1286       	BHI.s		RTS_005			* if this line greater all done so exit
               S01:00E005BA:  62 A6
F00:1287       
F00:1288       LAB_14E2
F00:1289       	MOVEM.l	a0-a1,-(sp)			* save registers
               S01:00E005BC:  48 E7 00 C0
F00:1290       	BSR		LAB_295E			* print d0 as unsigned integer
               S01:00E005C0:  61 00 1A 1C
F00:1291       	MOVEM.l	(sp)+,a0-a1			* restore registers
               S01:00E005C4:  4C DF 03 00
F00:1292       	MOVEQ		#$20,d0			* space is the next character
               S01:00E005C8:  70 20
F00:1293       LAB_150C
F00:1294       	BSR		LAB_PRNA			* go print the character
               S01:00E005CA:  61 00 05 3A
F00:1295       	CMP.b		#$22,d0			* was it " character
               S01:00E005CE:  B0 3C 00 22
F00:1296       	BNE.s		LAB_1519			* branch if not
               S01:00E005D2:  66 04
F00:1297       
F00:1298       							* we're either entering or leaving quotes
F00:1299       	EOR.b		#$FF,Oquote(a3)		* toggle open quote flag
               S01:00E005D4:  46 2B 05 DD
F00:1300       LAB_1519
F00:1301       	MOVE.b	(a0)+,d0			* get byte and increment pointer
               S01:00E005D8:  10 18
F00:1302       	BNE.s		LAB_152E			* branch if not [EOL] (go print)
               S01:00E005DA:  66 08
F00:1303       
F00:1304       							* was [EOL]
F00:1305       	MOVEA.l	a1,a0				* copy next line pointer
               S01:00E005DC:  20 49
F00:1306       	MOVE.l	a0,d0				* copy to set flags
               S01:00E005DE:  20 08
F00:1307       	BNE.s		LAB_14D4			* go do next line if not [EOT]
               S01:00E005E0:  66 BE
F00:1308       
F00:1309       	RTS
               S01:00E005E2:  4E 75
F00:1310       
F00:1311       LAB_152E
F00:1312       	BPL.s		LAB_150C			* just go print it if not token byte
               S01:00E005E4:  6A E4
F00:1313       
F00:1314       							* else it was a token byte so maybe uncrunch it
F00:1315       	TST.b		Oquote(a3)			* test the open quote flag
               S01:00E005E6:  4A 2B 05 DD
F00:1316       	BMI.s		LAB_150C			* just go print character if open quote set
               S01:00E005EA:  6B DE
F00:1317       
F00:1318       							* else uncrunch BASIC token
F00:1319       	LEA		LAB_KEYT(pc),a2		* get keyword table address
               S01:00E005EC:  45 FA 2D 12
F00:1320       	MOVEQ		#$7F,d1			* mask into d1
               S01:00E005F0:  72 7F
F00:1321       	AND.b		d0,d1				* copy and mask token
               S01:00E005F2:  C2 00
F00:1322       	LSL.w		#2,d1				* *4
               S01:00E005F4:  E5 49
F00:1323       	LEA		(a2,d1.w),a2		* get keyword entry address
               S01:00E005F6:  45 F2 10 00
F00:1324       	MOVE.b	(a2)+,d0			* get byte from keyword table
               S01:00E005FA:  10 1A
F00:1325       	BSR		LAB_PRNA			* go print the first character
               S01:00E005FC:  61 00 05 08
F00:1326       	MOVEQ		#0,d1				* clear d1
               S01:00E00600:  72 00
F00:1327       	MOVE.b	(a2)+,d1			* get remaining length byte from keyword table
               S01:00E00602:  12 1A
F00:1328       	BMI.s		LAB_1519			* if -ve done so go get next byte
               S01:00E00604:  6B D2
F00:1329       
F00:1330       	MOVE.w	(a2),d0			* get offset to rest
               S01:00E00606:  30 12
F00:1331       	LEA		TAB_STAR(pc),a2		* get keyword table address
               S01:00E00608:  45 FA 30 4C
F00:1332       	LEA		(a2,d0.w),a2		* get address of rest
               S01:00E0060C:  45 F2 00 00
F00:1333       LAB_1540
F00:1334       	MOVE.b	(a2)+,d0			* get byte from keyword table
               S01:00E00610:  10 1A
F00:1335       	BSR		LAB_PRNA			* go print the character
               S01:00E00612:  61 00 04 F2
F00:1336       	DBF		d1,LAB_1540			* decrement and loop if more to do
               S01:00E00616:  51 C9 FF F8
F00:1337       
F00:1338       	BRA.s		LAB_1519			* go get next byte
               S01:00E0061A:  60 BC
F00:1339       
F00:1340       
F00:1341       *************************************************************************************
F00:1342       *
F00:1343       * perform FOR
F00:1344       
F00:1345       LAB_FOR
F00:1346       	BSR		LAB_LET			* go do LET
               S01:00E0061C:  61 00 03 90
F00:1347       
F00:1348       	MOVE.l	Lvarpl(a3),d0		* get the loop variable pointer
               S01:00E00620:  20 2B 04 72
F00:1349       	CMP.l		Sstrl(a3),d0		* compare it with the end of vars memory
               S01:00E00624:  B0 AB 04 3A
F00:1350       	BGE		LAB_TMER			* if greater go do type mismatch error
               S01:00E00628:  6C 00 FC 24
F00:1351       
F00:1352       * test for not less than the start of variables memory if needed
F00:1353       *
F00:1354       *	CMP.l		Svarl(a3),d0		* compare it with the start of variables memory
F00:1355       *	BLT		LAB_TMER			* if not variables memory do type mismatch error
F00:1356       
F00:1357       *	MOVEQ		#28,d0			* we need 28 bytes !
F00:1358       *	BSR.s		LAB_1212			* check room on stack for d0 bytes
F00:1359       	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
               S01:00E0062C:  61 00 02 14
F00:1360       							* returns a0 as pointer to [:] or [EOL]
F00:1361       	MOVE.l	a0,(sp)			* push onto stack (and dump the return address)
               S01:00E00630:  2E 88
F00:1362       	MOVE.l	Clinel(a3),-(sp)		* push current line onto stack
               S01:00E00632:  2F 2B 04 52
F00:1363       
F00:1364       	MOVEQ		#TK_TO-$100,d0		* set "TO" token
               S01:00E00636:  70 B7
F00:1365       	BSR		LAB_SCCA			* scan for CHR$(d0) else syntax error/warm start
               S01:00E00638:  61 00 08 74
F00:1366       	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
               S01:00E0063C:  61 00 07 02
F00:1367       	MOVE.b	Dtypef(a3),-(sp)		* push the FOR variable data type onto stack
               S01:00E00640:  1F 2B 05 B5
F00:1368       	BSR		LAB_EVNM			* evaluate expression and check is numeric else
               S01:00E00644:  61 00 06 F8
F00:1369       							* do type mismatch
F00:1370       
F00:1371       	MOVE.l	FAC1_m(a3),-(sp)		* push TO value mantissa
               S01:00E00648:  2F 2B 05 90
F00:1372       	MOVE.w	FAC1_e(a3),-(sp)		* push TO value exponent and sign
               S01:00E0064C:  3F 2B 05 94
F00:1373       
F00:1374       	MOVE.l	#$80000000,FAC1_m(a3)	* set default STEP size mantissa
               S01:00E00650:  27 7C 80 00 00 00 05 90
F00:1375       	MOVE.w	#$8100,FAC1_e(a3)		* set default STEP size exponent and sign
               S01:00E00658:  37 7C 81 00 05 94
F00:1376       
F00:1377       	BSR		LAB_GBYT			* scan memory
               S01:00E0065E:  61 00 08 58
F00:1378       	CMP.b		#TK_STEP,d0			* compare with STEP token
               S01:00E00662:  B0 3C 00 BC
F00:1379       	BNE.s		LAB_15B3			* jump if not "STEP"
               S01:00E00666:  66 08
F00:1380       
F00:1381       							* was STEP token so ....
F00:1382       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E00668:  61 00 08 4C
F00:1383       	BSR		LAB_EVNM			* evaluate expression & check is numeric
               S01:00E0066C:  61 00 06 D0
F00:1384       							* else do type mismatch
F00:1385       LAB_15B3
F00:1386       	MOVE.l	FAC1_m(a3),-(sp)		* push STEP value mantissa
               S01:00E00670:  2F 2B 05 90
F00:1387       	MOVE.w	FAC1_e(a3),-(sp)		* push STEP value exponent and sign
               S01:00E00674:  3F 2B 05 94
F00:1388       
F00:1389       	MOVE.l	Lvarpl(a3),-(sp)		* push variable pointer for FOR/NEXT
               S01:00E00678:  2F 2B 04 72
F00:1390       	MOVE.w	#TK_FOR,-(sp)		* push FOR token on stack
               S01:00E0067C:  3F 3C 00 81
F00:1391       
F00:1392       	BRA.s		LAB_15C2			* go do interpreter inner loop
               S01:00E00680:  60 18
F00:1393       
F00:1394       LAB_15DC						* have reached [EOL]+1
F00:1395       	MOVE.w	a5,d0				* copy BASIC execute pointer
               S01:00E00682:  30 0D
F00:1396       	AND.w		#1,d0				* and make line start address even
               S01:00E00684:  C0 7C 00 01
F00:1397       	ADD.w		d0,a5				* add to BASIC execute pointer
               S01:00E00688:  DA C0
F00:1398       	MOVE.l	(a5)+,d0			* get next line pointer
               S01:00E0068A:  20 1D
F00:1399       	BEQ		LAB_1274			* if null go to immediate mode, no "BREAK"
               S01:00E0068C:  67 00 FC 1C
F00:1400       							* message (was immediate or [EOT] marker)
F00:1401       
F00:1402       	MOVE.l	(a5)+,Clinel(a3)		* save (new) current line #
               S01:00E00690:  27 5D 04 52
F00:1403       LAB_15F6
F00:1404       	BSR		LAB_GBYT			* get BASIC byte
               S01:00E00694:  61 00 08 22
F00:1405       	BSR.s		LAB_15FF			* go interpret BASIC code from (a5)
               S01:00E00698:  61 1A
F00:1406       
F00:1407       * interpreter inner loop (re)entry point
F00:1408       
F00:1409       LAB_15C2
F00:1410       	BSR.s		LAB_1629			* do CRTL-C check vector
               S01:00E0069A:  61 40
F00:1411       	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
               S01:00E0069C:  4A 2B 04 52
F00:1412       	BMI.s		LAB_15D1			* branch if immediate mode
               S01:00E006A0:  6B 04
F00:1413       
F00:1414       	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
               S01:00E006A2:  27 4D 04 5A
F00:1415       LAB_15D1
F00:1416       	MOVE.b	(a5)+,d0			* get this byte & increment pointer
               S01:00E006A6:  10 1D
F00:1417       	BEQ.s		LAB_15DC			* loop if [EOL]
               S01:00E006A8:  67 D8
F00:1418       
F00:1419       	CMP.b		#$3A,d0			* compare with ":"
               S01:00E006AA:  B0 3C 00 3A
F00:1420       	BEQ.s		LAB_15F6			* loop if was statement separator
               S01:00E006AE:  67 E4
F00:1421       
F00:1422       	BRA		LAB_SNER			* else syntax error, then warm start
               S01:00E006B0:  60 00 FB C8
F00:1423       
F00:1424       
F00:1425       *************************************************************************************
F00:1426       *
F00:1427       * interpret BASIC code from (a5)
F00:1428       
F00:1429       LAB_15FF
F00:1430       	BEQ		RTS_006			* exit if zero [EOL]
               S01:00E006B4:  67 00 00 8C
F00:1431       
F00:1432       LAB_1602
F00:1433       	EORI.b	#$80,d0			* normalise token
               S01:00E006B8:  0A 00 00 80
F00:1434       	BMI		LAB_LET			* if not token, go do implied LET
               S01:00E006BC:  6B 00 02 F0
F00:1435       
F00:1436       	CMP.b		#(TK_TAB-$80),d0		* compare normalised token with TAB
               S01:00E006C0:  B0 3C 00 35
F00:1437       	BCC		LAB_SNER			* branch if d0>=TAB, syntax error/warm start
               S01:00E006C4:  64 00 FB B4
F00:1438       							* only tokens before TAB can start a statement
F00:1439       
F00:1440       	EXT.w		d0				* byte to word (clear high byte)
               S01:00E006C8:  48 80
F00:1441       	ADD.w		d0,d0				* *2
               S01:00E006CA:  D0 40
F00:1442       	LEA		LAB_CTBL(pc),a0		* get vector table base address
               S01:00E006CC:  41 FA 2A 6E
F00:1443       	MOVE.w	(a0,d0.w),d0		* get offset to vector
               S01:00E006D0:  30 30 00 00
F00:1444       	PEA		(a0,d0.w)			* push vector
               S01:00E006D4:  48 70 00 00
F00:1445       	BRA		LAB_IGBY			* get following byte & execute vector
               S01:00E006D8:  60 00 07 DC
F00:1446       
F00:1447       
F00:1448       *************************************************************************************
F00:1449       *
F00:1450       * CTRL-C check jump. this is called as a subroutine but exits back via a jump if a
F00:1451       * key press is detected.
F00:1452       
F00:1453       LAB_1629
F00:1454       	JMP		V_CTLC(a3)			* ctrl c check vector
               S01:00E006DC:  4E EB 04 24
F00:1455       
F00:1456       * if there was a key press it gets back here .....
F00:1457       
F00:1458       LAB_1636
F00:1459       	CMP.b		#$03,d0			* compare with CTRL-C
               S01:00E006E0:  B0 3C 00 03
F00:1460       	BEQ.s		LAB_163B			* STOP if was CTRL-C
               S01:00E006E4:  67 0C
F00:1461       
F00:1462       LAB_1639
F00:1463       	RTS
               S01:00E006E6:  4E 75
F00:1464       
F00:1465       
F00:1466       *************************************************************************************
F00:1467       *
F00:1468       * perform END
F00:1469       
F00:1470       LAB_END
F00:1471       	BNE.s		LAB_1639			* exit if something follows STOP
               S01:00E006E8:  66 FC
F00:1472       	MOVE.b	#0,Breakf(a3)		* clear break flag, indicate program end
               S01:00E006EA:  17 7C 00 00 05 DC
F00:1473       
F00:1474       
F00:1475       *************************************************************************************
F00:1476       *
F00:1477       * perform STOP
F00:1478       
F00:1479       LAB_STOP
F00:1480       	BNE.s		LAB_1639			* exit if something follows STOP
               S01:00E006F0:  66 F4
F00:1481       
F00:1482       LAB_163B
F00:1483       	LEA		Ibuffe(a3),a1		* get buffer end
               S01:00E006F2:  43 EB 05 90
F00:1484       	CMPA.l	a1,a5				* compare execute address with buffer end
               S01:00E006F6:  BB C9
F00:1485       	BCS.s		LAB_164F			* branch if BASIC pointer is in buffer
               S01:00E006F8:  65 0A
F00:1486       							* can't continue in immediate mode
F00:1487       
F00:1488       							* else...
F00:1489       	MOVE.l	a5,Cpntrl(a3)		* save BASIC execute pointer as continue pointer
               S01:00E006FA:  27 4D 04 5A
F00:1490       LAB_1647
F00:1491       	MOVE.l	Clinel(a3),Blinel(a3)	* save break line
               S01:00E006FE:  27 6B 04 52 04 56
F00:1492       LAB_164F
F00:1493       	ADDQ.w	#4,sp				* dump return address, don't return to execute
               S01:00E00704:  58 4F
F00:1494       							* loop
F00:1495       	MOVE.b	Breakf(a3),d0		* get break flag
               S01:00E00706:  10 2B 05 DC
F00:1496       	BEQ		LAB_1274			* go do warm start if was program end
               S01:00E0070A:  67 00 FB 9E
F00:1497       
F00:1498       	LEA		LAB_BMSG(pc),a0		* point to "Break"
               S01:00E0070E:  41 FA 31 39
F00:1499       	BRA		LAB_1269			* print "Break" and do warm start
               S01:00E00712:  60 00 FB 88
F00:1500       
F00:1501       
F00:1502       *************************************************************************************
F00:1503       *
F00:1504       * perform RESTORE
F00:1505       
F00:1506       LAB_RESTORE
F00:1507       	MOVEA.l	Smeml(a3),a0		* copy start of memory
               S01:00E00716:  20 6B 04 2E
F00:1508       	BEQ.s		LAB_1624			* branch if next character null (RESTORE)
               S01:00E0071A:  67 20
F00:1509       
F00:1510       	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E0071C:  61 00 01 F0
F00:1511       	CMP.l		Clinel(a3),d1		* compare current line # with required line #
               S01:00E00720:  B2 AB 04 52
F00:1512       	BLS.s		LAB_GSCH			* branch if >= (start search from beginning)
               S01:00E00724:  63 0E
F00:1513       
F00:1514       	MOVEA.l	a5,a0				* copy BASIC execute pointer
               S01:00E00726:  20 4D
F00:1515       LAB_RESs
F00:1516       	TST.b		(a0)+				* test next byte & increment pointer
               S01:00E00728:  4A 18
F00:1517       	BNE.s		LAB_RESs			* loop if not EOL
               S01:00E0072A:  66 FC
F00:1518       
F00:1519       	MOVE.w	a0,d0				* copy pointer
               S01:00E0072C:  30 08
F00:1520       	AND.w		#1,d0				* mask odd bit
               S01:00E0072E:  C0 7C 00 01
F00:1521       	ADD.w		d0,a0				* add pointer
               S01:00E00732:  D0 C0
F00:1522       							* search for line in Itemp from (a0)
F00:1523       LAB_GSCH
F00:1524       	BSR		LAB_SCLN			* search for d1 line number from a0
               S01:00E00734:  61 00 FD CC
F00:1525       							* returns Cb=0 if found
F00:1526       	BCS		LAB_USER			* go do "Undefined statement" error if not found
               S01:00E00738:  65 00 FB 28
F00:1527       
F00:1528       LAB_1624
F00:1529       	TST.b		-(a0)				* decrement pointer (faster)
               S01:00E0073C:  4A 20
F00:1530       	MOVE.l	a0,Dptrl(a3)		* save DATA pointer
               S01:00E0073E:  27 48 04 62
F00:1531       RTS_006
F00:1532       	RTS
               S01:00E00742:  4E 75
F00:1533       
F00:1534       
F00:1535       *************************************************************************************
F00:1536       *
F00:1537       * perform NULL
F00:1538       
F00:1539       LAB_NULL
F00:1540       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E00744:  61 00 10 D8
F00:1541       	MOVE.b	d0,Nullct(a3)		* save new NULL count
               S01:00E00748:  17 40 05 E4
F00:1542       	RTS
               S01:00E0074C:  4E 75
F00:1543       
F00:1544       
F00:1545       *************************************************************************************
F00:1546       *
F00:1547       * perform CONT
F00:1548       
F00:1549       LAB_CONT
F00:1550       	BNE		LAB_SNER			* if following byte exit to do syntax error
               S01:00E0074E:  66 00 FB 2A
F00:1551       
F00:1552       	TST.b		Clinel(a3)			* test current line #, is -ve for immediate mode
               S01:00E00752:  4A 2B 04 52
F00:1553       	BPL		LAB_CCER			* if running go do can't continue error
               S01:00E00756:  6A 00 FA EA
F00:1554       
F00:1555       	MOVE.l	Cpntrl(a3),d0		* get continue pointer
               S01:00E0075A:  20 2B 04 5A
F00:1556       	BEQ		LAB_CCER			* go do can't continue error if we can't
               S01:00E0075E:  67 00 FA E2
F00:1557       
F00:1558       							* we can continue so ...
F00:1559       	MOVEA.l	d0,a5				* save continue pointer as BASIC execute pointer
               S01:00E00762:  2A 40
F00:1560       	MOVE.l	Blinel(a3),Clinel(a3)	* set break line as current line
               S01:00E00764:  27 6B 04 56 04 52
F00:1561       	RTS
               S01:00E0076A:  4E 75
F00:1562       
F00:1563       
F00:1564       *************************************************************************************
F00:1565       *
F00:1566       * perform RUN
F00:1567       
F00:1568       LAB_RUN
F00:1569       	BNE.s		LAB_RUNn			* if following byte do RUN n
               S01:00E0076C:  66 0C
F00:1570       
F00:1571       	BSR		LAB_1477			* execution to start, clear vars & flush stack
               S01:00E0076E:  61 00 FD B2
F00:1572       	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
               S01:00E00772:  27 4D 04 5A
F00:1573       	BRA		LAB_15C2			* go do interpreter inner loop
               S01:00E00776:  60 00 FF 22
F00:1574       							* (can't RTS, we flushed the stack!)
F00:1575       
F00:1576       LAB_RUNn
F00:1577       	BSR		LAB_147A			* go do "CLEAR"
               S01:00E0077A:  61 00 FD AC
F00:1578       	BRA.s		LAB_16B0			* get n and do GOTO n
               S01:00E0077E:  60 1C
F00:1579       
F00:1580       
F00:1581       *************************************************************************************
F00:1582       *
F00:1583       * perform DO
F00:1584       
F00:1585       LAB_DO
F00:1586       *	MOVE.l	#$05,d0			* need 5 bytes for DO 
F00:1587       *	BSR.s		LAB_1212			* check room on stack for A bytes
F00:1588       	MOVE.l	a5,-(sp)			* push BASIC execute pointer on stack
               S01:00E00780:  2F 0D
F00:1589       	MOVE.l	Clinel(a3),-(sp)		* push current line on stack
               S01:00E00782:  2F 2B 04 52
F00:1590       	MOVE.w	#TK_DO,-(sp)		* push token for DO on stack
               S01:00E00786:  3F 3C 00 9C
F00:1591       	PEA		LAB_15C2(pc)		* set return address
               S01:00E0078A:  48 7A FF 0E
F00:1592       	BRA		LAB_GBYT			* scan memory and return to interpreter inner
               S01:00E0078E:  60 00 07 28
F00:1593       							* loop
F00:1594       
F00:1595       
F00:1596       *************************************************************************************
F00:1597       *
F00:1598       * perform GOSUB
F00:1599       
F00:1600       LAB_GOSUB
F00:1601       *	MOVE.l	#10,d0			* need 10 bytes for GOSUB 
F00:1602       *	BSR.s		LAB_1212			* check room on stack for d0 bytes
F00:1603       	MOVE.l	a5,-(sp)			* push BASIC execute pointer
               S01:00E00792:  2F 0D
F00:1604       	MOVE.l	Clinel(a3),-(sp)		* push current line
               S01:00E00794:  2F 2B 04 52
F00:1605       	MOVE.w	#TK_GOSUB,-(sp)		* push token for GOSUB
               S01:00E00798:  3F 3C 00 8D
F00:1606       LAB_16B0
F00:1607       	BSR		LAB_GBYT			* scan memory
               S01:00E0079C:  61 00 07 1A
F00:1608       	PEA		LAB_15C2(pc)		* return to interpreter inner loop after GOTO n
               S01:00E007A0:  48 7A FE F8
F00:1609       
F00:1610       * this PEA is needed because either we just cleared the stack and have nowhere to return
F00:1611       * to or, in the case of GOSUB, we have just dropped a load on the stack and the address
F00:1612       * we whould have returned to is buried. This burried return address will be unstacked by
F00:1613       * the corresponding RETURN command
F00:1614       
F00:1615       
F00:1616       *************************************************************************************
F00:1617       *
F00:1618       * perform GOTO
F00:1619       
F00:1620       LAB_GOTO
F00:1621       	BSR		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E007A4:  61 00 01 68
F00:1622       	MOVEA.l	Smeml(a3),a0		* get start of memory
               S01:00E007A8:  20 6B 04 2E
F00:1623       	CMP.l		Clinel(a3),d1		* compare current line with wanted #
               S01:00E007AC:  B2 AB 04 52
F00:1624       	BLS.s		LAB_16D0			* branch if current # => wanted #
               S01:00E007B0:  63 0E
F00:1625       
F00:1626       	MOVEA.l	a5,a0				* copy BASIC execute pointer
               S01:00E007B2:  20 4D
F00:1627       LAB_GOTs
F00:1628       	TST.b		(a0)+				* test next byte & increment pointer
               S01:00E007B4:  4A 18
F00:1629       	BNE.s		LAB_GOTs			* loop if not EOL
               S01:00E007B6:  66 FC
F00:1630       
F00:1631       	MOVE.w	a0,d0				* past pad byte(s)
               S01:00E007B8:  30 08
F00:1632       	AND.w		#1,d0				* mask odd bit
               S01:00E007BA:  C0 7C 00 01
F00:1633       	ADD.w		d0,a0				* add to pointer
               S01:00E007BE:  D0 C0
F00:1634       
F00:1635       LAB_16D0
F00:1636       	BSR		LAB_SCLN			* search for d1 line number from a0
               S01:00E007C0:  61 00 FD 40
F00:1637       							* returns Cb=0 if found
F00:1638       	BCS		LAB_USER			* if carry set go do "Undefined statement" error
               S01:00E007C4:  65 00 FA 9C
F00:1639       
F00:1640       	MOVEA.l	a0,a5				* copy to BASIC execute pointer
               S01:00E007C8:  2A 48
F00:1641       	SUBQ.w	#1,a5				* decrement pointer
               S01:00E007CA:  53 4D
F00:1642       	MOVE.l	a5,Cpntrl(a3)		* save as continue pointer
               S01:00E007CC:  27 4D 04 5A
F00:1643       	RTS
               S01:00E007D0:  4E 75
F00:1644       
F00:1645       
F00:1646       *************************************************************************************
F00:1647       *
F00:1648       * perform LOOP
F00:1649       
F00:1650       LAB_LOOP
F00:1651       	CMP.w		#TK_DO,4(sp)		* compare token on stack with DO token
               S01:00E007D2:  0C 6F 00 9C 00 04
F00:1652       	BNE		LAB_LDER			* branch if no matching DO
               S01:00E007D8:  66 00 FA 60
F00:1653       
F00:1654       	MOVE.b	d0,d7				* copy following token (byte)
               S01:00E007DC:  1E 00
F00:1655       	BEQ.s		LoopAlways			* if no following token loop forever
               S01:00E007DE:  67 2E
F00:1656       
F00:1657       	CMP.b		#':',d7			* compare with ":"
               S01:00E007E0:  BE 3C 00 3A
F00:1658       	BEQ.s		LoopAlways			* if no following token loop forever
               S01:00E007E4:  67 28
F00:1659       
F00:1660       	SUB.b		#TK_UNTIL,d7		* subtract token for UNTIL
               S01:00E007E6:  9E 3C 00 BD
F00:1661       	BEQ.s		DoRest			* branch if was UNTIL
               S01:00E007EA:  67 08
F00:1662       
F00:1663       	SUBQ.b	#1,d7				* decrement result
               S01:00E007EC:  53 07
F00:1664       	BNE		LAB_SNER			* if not WHILE go do syntax error & warm start
               S01:00E007EE:  66 00 FA 8A
F00:1665       							* only if the token was WHILE will this fail
F00:1666       
F00:1667       	MOVEQ		#-1,d7			* set invert result longword
               S01:00E007F2:  7E FF
F00:1668       DoRest
F00:1669       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E007F4:  61 00 06 C0
F00:1670       	BSR		LAB_EVEX			* evaluate expression
               S01:00E007F8:  61 00 05 5C
F00:1671       	TST.b		FAC1_e(a3)			* test FAC1 exponent
               S01:00E007FC:  4A 2B 05 94
F00:1672       	BEQ.s		DoCmp				* if = 0 go do straight compare
               S01:00E00800:  67 06
F00:1673       
F00:1674       	MOVE.b	#$FF,FAC1_e(a3)		* else set all bits
               S01:00E00802:  17 7C 00 FF 05 94
F00:1675       DoCmp
F00:1676       	EOR.b		d7,FAC1_e(a3)		* EOR with invert byte
               S01:00E00808:  BF 2B 05 94
F00:1677       	BNE.s		LoopDone			* if <> 0 clear stack & back to interpreter loop
               S01:00E0080C:  66 14
F00:1678       
F00:1679       							* loop condition wasn't met so do it again
F00:1680       LoopAlways
F00:1681       	MOVE.l	6(sp),Clinel(a3)		* copy DO current line
               S01:00E0080E:  27 6F 00 06 04 52
F00:1682       	MOVE.l	10(sp),a5			* save BASIC execute pointer
               S01:00E00814:  2A 6F 00 0A
F00:1683       
F00:1684       	LEA		LAB_15C2(pc),a0		* get return address
               S01:00E00818:  41 FA FE 80
F00:1685       	MOVE.l	a0,(sp)			* dump the call to this routine and set the
               S01:00E0081C:  2E 88
F00:1686       							* return address
F00:1687       	BRA		LAB_GBYT			* scan memory and return to interpreter inner
               S01:00E0081E:  60 00 06 98
F00:1688       							* loop
F00:1689       
F00:1690       							* clear stack & back to interpreter loop
F00:1691       LoopDone
F00:1692       	LEA		14(sp),sp			* dump structure and call from stack
               S01:00E00822:  4F EF 00 0E
F00:1693       	BRA.s		LAB_DATA			* go perform DATA (find : or [EOL])
               S01:00E00826:  60 14
F00:1694       
F00:1695       
F00:1696       *************************************************************************************
F00:1697       *
F00:1698       * perform RETURN
F00:1699       
F00:1700       LAB_RETURN
F00:1701       	BNE.s		RTS_007			* exit if following token to allow syntax error
               S01:00E00828:  66 16
F00:1702       
F00:1703       	CMP.w		#TK_GOSUB,4(sp)		* compare token from stack with GOSUB
               S01:00E0082A:  0C 6F 00 8D 00 04
F00:1704       	BNE		LAB_RGER			* do RETURN without GOSUB error if no matching
               S01:00E00830:  66 00 FA 44
F00:1705       							* GOSUB
F00:1706       
F00:1707       	ADDQ.w	#6,sp				* dump calling address & token
               S01:00E00834:  5C 4F
F00:1708       	MOVE.l	(sp)+,Clinel(a3)		* pull current line
               S01:00E00836:  27 5F 04 52
F00:1709       	MOVE.l	(sp)+,a5			* pull BASIC execute pointer
               S01:00E0083A:  2A 5F
F00:1710       							* now do perform "DATA" statement as we could be
F00:1711       							* returning into the middle of an ON <var> GOSUB
F00:1712       							* n,m,p,q line (the return address used by the
F00:1713       							* DATA statement is the one pushed before the
F00:1714       							* GOSUB was executed!)
F00:1715       
F00:1716       
F00:1717       *************************************************************************************
F00:1718       *
F00:1719       * perform DATA
F00:1720       
F00:1721       LAB_DATA
F00:1722       	BSR.s		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
               S01:00E0083C:  61 04
F00:1723       							* returns a0 as pointer to [:] or [EOL]
F00:1724       	MOVEA.l	a0,a5				* skip rest of statement
               S01:00E0083E:  2A 48
F00:1725       RTS_007
F00:1726       	RTS
               S01:00E00840:  4E 75
F00:1727       
F00:1728       
F00:1729       *************************************************************************************
F00:1730       *
F00:1731       * scan for next BASIC statement ([:] or [EOL])
F00:1732       * returns a0 as pointer to [:] or [EOL]
F00:1733       
F00:1734       LAB_SNBS
F00:1735       	MOVEA.l	a5,a0				* copy BASIC execute pointer
               S01:00E00842:  20 4D
F00:1736       	MOVEQ		#$22,d1			* set string quote character
               S01:00E00844:  72 22
F00:1737       	MOVEQ		#$3A,d2			* set look for character = ":"
               S01:00E00846:  74 3A
F00:1738       	BRA.s		LAB_172D			* go do search
               S01:00E00848:  60 08
F00:1739       
F00:1740       LAB_172C
F00:1741       	CMP.b		d0,d2				* compare with ":"
               S01:00E0084A:  B4 00
F00:1742       	BEQ.s		RTS_007a			* exit if found
               S01:00E0084C:  67 08
F00:1743       
F00:1744       	CMP.b		d0,d1				* compare with '"'
               S01:00E0084E:  B2 00
F00:1745       	BEQ.s		LAB_1725			* if found go search for [EOL]
               S01:00E00850:  67 0C
F00:1746       
F00:1747       LAB_172D
F00:1748       	MOVE.b	(a0)+,d0			* get next byte
               S01:00E00852:  10 18
F00:1749       	BNE.s		LAB_172C			* loop if not null [EOL]
               S01:00E00854:  66 F4
F00:1750       
F00:1751       RTS_007a
F00:1752       	SUBQ.w	#1,a0				* correct pointer
               S01:00E00856:  53 48
F00:1753       	RTS
               S01:00E00858:  4E 75
F00:1754       
F00:1755       LAB_1723
F00:1756       	CMP.b		d0,d1				* compare with '"'
               S01:00E0085A:  B2 00
F00:1757       	BEQ.s		LAB_172D			* if found go search for ":" or [EOL]
               S01:00E0085C:  67 F4
F00:1758       
F00:1759       LAB_1725
F00:1760       	MOVE.b	(a0)+,d0			* get next byte
               S01:00E0085E:  10 18
F00:1761       	BNE.s		LAB_1723			* loop if not null [EOL]
               S01:00E00860:  66 F8
F00:1762       
F00:1763       	BRA.s		RTS_007a			* correct pointer & return
               S01:00E00862:  60 F2
F00:1764       
F00:1765       
F00:1766       *************************************************************************************
F00:1767       *
F00:1768       * perform IF
F00:1769       
F00:1770       LAB_IF
F00:1771       	BSR		LAB_EVEX			* evaluate expression
               S01:00E00864:  61 00 04 F0
F00:1772       	BSR		LAB_GBYT			* scan memory
               S01:00E00868:  61 00 06 4E
F00:1773       	CMP.b		#TK_THEN,d0			* compare with THEN token
               S01:00E0086C:  B0 3C 00 BA
F00:1774       	BEQ.s		LAB_174B			* if it was THEN then continue
               S01:00E00870:  67 14
F00:1775       
F00:1776       							* wasn't IF .. THEN so must be IF .. GOTO
F00:1777       	CMP.b		#TK_GOTO,d0			* compare with GOTO token
               S01:00E00872:  B0 3C 00 89
F00:1778       	BNE		LAB_SNER			* if not GOTO token do syntax error/warm start
               S01:00E00876:  66 00 FA 02
F00:1779       
F00:1780       							* was GOTO so check for GOTO <n>
F00:1781       	MOVE.l	a5,a0				* save the execute pointer
               S01:00E0087A:  20 4D
F00:1782       	BSR		LAB_IGBY			* scan memory, test for a numeric character
               S01:00E0087C:  61 00 06 38
F00:1783       	MOVE.l	a0,a5				* restore the execute pointer
               S01:00E00880:  2A 48
F00:1784       	BCC		LAB_SNER			* if not numeric do syntax error/warm start
               S01:00E00882:  64 00 F9 F6
F00:1785       
F00:1786       LAB_174B
F00:1787       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E00886:  10 2B 05 94
F00:1788       	BEQ.s		LAB_174E			* if result was zero go look for an ELSE
               S01:00E0088A:  67 1E
F00:1789       
F00:1790       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0088C:  61 00 06 28
F00:1791       	BCS		LAB_GOTO			* if numeric do GOTO n
               S01:00E00890:  65 00 FF 12
F00:1792       							* a GOTO <n> will never return to the IF
F00:1793       							* statement so there is no need to return
F00:1794       							* to this code
F00:1795       
F00:1796       	CMP.b		#TK_RETURN,d0		* compare with RETURN token
               S01:00E00894:  B0 3C 00 8E
F00:1797       	BEQ		LAB_1602			* if RETURN then interpret BASIC code from (a5)
               S01:00E00898:  67 00 FE 1E
F00:1798       							* and don't return here
F00:1799       
F00:1800       	BSR		LAB_15FF			* else interpret BASIC code from (a5)
               S01:00E0089C:  61 00 FE 16
F00:1801       
F00:1802       * the IF was executed and there may be a following ELSE so the code needs to return
F00:1803       * here to check and ignore the ELSE if present
F00:1804       
F00:1805       	MOVE.b	(a5),d0			* get the next basic byte
               S01:00E008A0:  10 15
F00:1806       	CMP.b		#TK_ELSE,d0			* compare it with the token for ELSE
               S01:00E008A2:  B0 3C 00 B6
F00:1807       	BEQ		LAB_DATA			* if ELSE ignore the following statement
               S01:00E008A6:  67 94
F00:1808       
F00:1809       * there was no ELSE so continue execution of IF <expr> THEN <stat> [: <stat>]. any
F00:1810       * following ELSE will, correctly, cause a syntax error
F00:1811       
F00:1812       	RTS						* else return to interpreter inner loop
               S01:00E008A8:  4E 75
F00:1813       
F00:1814       * perform ELSE after IF
F00:1815       
F00:1816       LAB_174E
F00:1817       	MOVE.b	(a5)+,d0			* faster increment past THEN
               S01:00E008AA:  10 1D
F00:1818       	MOVEQ		#TK_ELSE,d3			* set search for ELSE token
               S01:00E008AC:  76 B6
F00:1819       	MOVEQ		#TK_IF,d4			* set search for IF token
               S01:00E008AE:  78 8B
F00:1820       	MOVEQ		#0,d5				* clear the nesting depth
               S01:00E008B0:  7A 00
F00:1821       LAB_1750
F00:1822       	MOVE.b	(a5)+,d0			* get next BASIC byte & increment ptr
               S01:00E008B2:  10 1D
F00:1823       	BEQ.s		LAB_1754			* if EOL correct the pointer and return
               S01:00E008B4:  67 20
F00:1824       
F00:1825       	CMP.b		d4,d0				* compare with "IF" token
               S01:00E008B6:  B0 04
F00:1826       	BNE.s		LAB_1752			* skip if not nested IF
               S01:00E008B8:  66 04
F00:1827       
F00:1828       	ADDQ.w	#1,d5				* else increment the nesting depth ..
               S01:00E008BA:  52 45
F00:1829       	BRA.s		LAB_1750			* .. and continue looking
               S01:00E008BC:  60 F4
F00:1830       
F00:1831       LAB_1752
F00:1832       	CMP.b		d3,d0				* compare with ELSE token
               S01:00E008BE:  B0 03
F00:1833       	BNE.s		LAB_1750			* if not ELSE continue looking
               S01:00E008C0:  66 F0
F00:1834       
F00:1835       LAB_1756
F00:1836       	DBF		d5,LAB_1750			* loop if still nested
               S01:00E008C2:  51 CD FF EE
F00:1837       
F00:1838       * found the matching ELSE, now do <{n|statement}>
F00:1839       
F00:1840       	BSR		LAB_GBYT			* scan memory
               S01:00E008C6:  61 00 05 F0
F00:1841       	BCS		LAB_GOTO			* if numeric do GOTO n
               S01:00E008CA:  65 00 FE D8
F00:1842       							* code will return to the interpreter loop
F00:1843       							* at the tail end of the GOTO <n>
F00:1844       
F00:1845       	BRA		LAB_15FF			* else interpret BASIC code from (a5)
               S01:00E008CE:  60 00 FD E4
F00:1846       							* code will return to the interpreter loop
F00:1847       							* at the tail end of the <statement>
F00:1848       
F00:1849       
F00:1850       *************************************************************************************
F00:1851       *
F00:1852       * perform REM, skip (rest of) line
F00:1853       
F00:1854       LAB_REM
F00:1855       	TST.b		(a5)+				* test byte & increment pointer
               S01:00E008D2:  4A 1D
F00:1856       	BNE.s		LAB_REM			* loop if not EOL
               S01:00E008D4:  66 FC
F00:1857       
F00:1858       LAB_1754
F00:1859       	SUBQ.w	#1,a5				* correct the execute pointer
               S01:00E008D6:  53 4D
F00:1860       	RTS
               S01:00E008D8:  4E 75
F00:1861       
F00:1862       
F00:1863       *************************************************************************************
F00:1864       *
F00:1865       * perform ON
F00:1866       
F00:1867       LAB_ON
F00:1868       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E008DA:  61 00 0F 42
F00:1869       	MOVE.b	d0,d2				* copy byte
               S01:00E008DE:  14 00
F00:1870       	BSR		LAB_GBYT			* restore BASIC byte
               S01:00E008E0:  61 00 05 D6
F00:1871       	MOVE.w	d0,-(sp)			* push GOTO/GOSUB token
               S01:00E008E4:  3F 00
F00:1872       	CMP.b		#TK_GOSUB,d0		* compare with GOSUB token
               S01:00E008E6:  B0 3C 00 8D
F00:1873       	BEQ.s		LAB_176C			* branch if GOSUB
               S01:00E008EA:  67 08
F00:1874       
F00:1875       	CMP.b		#TK_GOTO,d0			* compare with GOTO token
               S01:00E008EC:  B0 3C 00 89
F00:1876       	BNE		LAB_SNER			* if not GOTO do syntax error, then warm start
               S01:00E008F0:  66 00 F9 88
F00:1877       
F00:1878       * next character was GOTO or GOSUB
F00:1879       
F00:1880       LAB_176C
F00:1881       	SUBQ.b	#1,d2				* decrement index (byte value)
               S01:00E008F4:  53 02
F00:1882       	BNE.s		LAB_1773			* branch if not zero
               S01:00E008F6:  66 06
F00:1883       
F00:1884       	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token
               S01:00E008F8:  30 1F
F00:1885       	BRA		LAB_1602			* go execute it
               S01:00E008FA:  60 00 FD BC
F00:1886       
F00:1887       LAB_1773
F00:1888       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E008FE:  61 00 05 B6
F00:1889       	BSR.s		LAB_GFPN			* get fixed-point number into temp integer & d1
               S01:00E00902:  61 0A
F00:1890       							* (skip this n)
F00:1891       	CMP.b		#$2C,d0			* compare next character with ","
               S01:00E00904:  B0 3C 00 2C
F00:1892       	BEQ.s		LAB_176C			* loop if ","
               S01:00E00908:  67 EA
F00:1893       
F00:1894       	MOVE.w	(sp)+,d0			* pull GOTO/GOSUB token (run out of options)
               S01:00E0090A:  30 1F
F00:1895       	RTS						* and exit
               S01:00E0090C:  4E 75
F00:1896       
F00:1897       
F00:1898       *************************************************************************************
F00:1899       *
F00:1900       * get fixed-point number into temp integer & d1
F00:1901       * interpret number from (a5), leave (a5) pointing to byte after #
F00:1902       
F00:1903       LAB_GFPN
F00:1904       	MOVEQ		#$00,d1			* clear integer register
               S01:00E0090E:  72 00
F00:1905       	MOVE.l	d1,d0				* clear d0
               S01:00E00910:  20 01
F00:1906       	BSR		LAB_GBYT			* scan memory, Cb=1 if "0"-"9", & get byte
               S01:00E00912:  61 00 05 A4
F00:1907       	BCC.s		LAB_1786			* return if carry clear, chr was not "0"-"9"
               S01:00E00916:  64 2E
F00:1908       
F00:1909       	MOVE.l	d2,-(sp)			* save d2
               S01:00E00918:  2F 02
F00:1910       LAB_1785
F00:1911       	MOVE.l	d1,d2				* copy integer register
               S01:00E0091A:  24 01
F00:1912       	ADD.l		d1,d1				* *2
               S01:00E0091C:  D2 81
F00:1913       	BCS		LAB_SNER			* if overflow do syntax error, then warm start
               S01:00E0091E:  65 00 F9 5A
F00:1914       
F00:1915       	ADD.l		d1,d1				* *4
               S01:00E00922:  D2 81
F00:1916       	BCS		LAB_SNER			* if overflow do syntax error, then warm start
               S01:00E00924:  65 00 F9 54
F00:1917       
F00:1918       	ADD.l		d2,d1				* *1 + *4
               S01:00E00928:  D2 82
F00:1919       	BCS		LAB_SNER			* if overflow do syntax error, then warm start
               S01:00E0092A:  65 00 F9 4E
F00:1920       
F00:1921       	ADD.l		d1,d1				* *10
               S01:00E0092E:  D2 81
F00:1922       	BCS		LAB_SNER			* if overflow do syntax error, then warm start
               S01:00E00930:  65 00 F9 48
F00:1923       
F00:1924       	SUB.b		#$30,d0			* subtract $30 from byte
               S01:00E00934:  90 3C 00 30
F00:1925       	ADD.l		d0,d1				* add to integer register, the top 24 bits are
               S01:00E00938:  D2 80
F00:1926       							* always clear
F00:1927       	BVS		LAB_SNER			* if overflow do syntax error, then warm start
               S01:00E0093A:  69 00 F9 3E
F00:1928       							* this makes the maximum line number 2147483647
F00:1929       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0093E:  61 00 05 76
F00:1930       	BCS.s		LAB_1785			* loop for next character if "0"-"9"
               S01:00E00942:  65 D6
F00:1931       
F00:1932       	MOVE.l	(sp)+,d2			* restore d2
               S01:00E00944:  24 1F
F00:1933       LAB_1786
F00:1934       	MOVE.l	d1,Itemp(a3)		* save Itemp
               S01:00E00946:  27 41 04 2A
F00:1935       	RTS
               S01:00E0094A:  4E 75
F00:1936       
F00:1937       
F00:1938       *************************************************************************************
F00:1939       *
F00:1940       * perform DEC
F00:1941       
F00:1942       LAB_DEC
F00:1943       	MOVE.w	#$8180,-(sp)		* set -1 sign/exponent
               S01:00E0094C:  3F 3C 81 80
F00:1944       	BRA.s		LAB_17B7			* go do DEC
               S01:00E00950:  60 0A
F00:1945       
F00:1946       
F00:1947       *************************************************************************************
F00:1948       *
F00:1949       * perform INC
F00:1950       
F00:1951       LAB_INC
F00:1952       	MOVE.w	#$8100,-(sp)		* set 1 sign/exponent
               S01:00E00952:  3F 3C 81 00
F00:1953       	BRA.s		LAB_17B7			* go do INC
               S01:00E00956:  60 04
F00:1954       
F00:1955       							* was "," so another INCR variable to do
F00:1956       LAB_17B8
F00:1957       	BSR		LAB_IGBY			* increment and scan memory
               S01:00E00958:  61 00 05 5C
F00:1958       LAB_17B7
F00:1959       	BSR		LAB_GVAR			* get variable address in a0
               S01:00E0095C:  61 00 07 6E
F00:1960       
F00:1961       * if you want a non existant variable to return a null value then set the novar
F00:1962       * value at the top of this file to some non zero value
F00:1963       
F00:1964        ifne	novar
F00:1965       
F00:1966       	BEQ.s		LAB_INCT			* if variable not found skip the inc/dec
F00:1967       
F00:1968        endc
F00:1969       
F00:1970       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00960:  4A 2B 05 B5
F00:1971       							* $00=float
F00:1972       	BMI		LAB_TMER			* if string do "Type mismatch" error/warm start
               S01:00E00964:  6B 00 F8 E8
F00:1973       
F00:1974       	BNE.s		LAB_INCI			* go do integer INC/DEC
               S01:00E00968:  66 36
F00:1975       
F00:1976       	MOVE.l	a0,Lvarpl(a3)		* save var address
               S01:00E0096A:  27 48 04 72
F00:1977       	BSR		LAB_UFAC			* unpack memory (a0) into FAC1
               S01:00E0096E:  61 00 15 1A
F00:1978       	MOVE.l	#$80000000,FAC2_m(a3)	* set FAC2 mantissa for 1
               S01:00E00972:  27 7C 80 00 00 00 05 98
F00:1979       	MOVE.w	(sp),d0			* move exponent & sign to d0
               S01:00E0097A:  30 17
F00:1980       	MOVE.w	d0,FAC2_e(a3)		* move exponent & sign to FAC2
               S01:00E0097C:  37 40 05 9C
F00:1981       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
               S01:00E00980:  17 6B 05 95 05 9E
F00:1982       	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
               S01:00E00986:  B1 2B 05 9E
F00:1983       	BSR		LAB_ADD			* add FAC2 to FAC1
               S01:00E0098A:  61 00 12 1C
F00:1984       	BSR		LAB_PFAC			* pack FAC1 into variable (Lvarpl)
               S01:00E0098E:  61 00 15 16
F00:1985       LAB_INCT
F00:1986       	BSR		LAB_GBYT			* scan memory
               S01:00E00992:  61 00 05 24
F00:1987       	CMPI.b	#$2C,d0			* compare with ","
               S01:00E00996:  0C 00 00 2C
F00:1988       	BEQ.s		LAB_17B8			* continue if "," (another variable to do)
               S01:00E0099A:  67 BC
F00:1989       
F00:1990       	ADDQ.w	#2,sp				* else dump sign & exponent
               S01:00E0099C:  54 4F
F00:1991       	RTS
               S01:00E0099E:  4E 75
F00:1992       
F00:1993       LAB_INCI
F00:1994       	TST.b		1(sp)				* test sign
               S01:00E009A0:  4A 2F 00 01
F00:1995       	BNE.s		LAB_DECI			* branch if DEC
               S01:00E009A4:  66 04
F00:1996       
F00:1997       	ADDQ.l	#1,(a0)			* increment variable
               S01:00E009A6:  52 90
F00:1998       	BRA.s		LAB_INCT			* go scan for more
               S01:00E009A8:  60 E8
F00:1999       
F00:2000       LAB_DECI
F00:2001       	SUBQ.l	#1,(a0)			* decrement variable
               S01:00E009AA:  53 90
F00:2002       	BRA.s		LAB_INCT			* go scan for more
               S01:00E009AC:  60 E4
F00:2003       
F00:2004       
F00:2005       *************************************************************************************
F00:2006       *
F00:2007       * perform LET
F00:2008       
F00:2009       LAB_LET
F00:2010       	BSR		LAB_SVAR			* search for or create a variable
               S01:00E009AE:  61 00 07 18
F00:2011       							* return the variable address in a0
F00:2012       	MOVE.l	a0,Lvarpl(a3)		* save variable address
               S01:00E009B2:  27 48 04 72
F00:2013       	MOVE.b	Dtypef(a3),-(sp)		* push var data type, $80=string, $40=integer,
               S01:00E009B6:  1F 2B 05 B5
F00:2014       							* $00=float
F00:2015       	MOVEQ		#TK_EQUAL-$100,d0		* get = token
               S01:00E009BA:  70 CA
F00:2016       	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
               S01:00E009BC:  61 00 04 F0
F00:2017       							* start
F00:2018       	BSR		LAB_EVEX			* evaluate expression
               S01:00E009C0:  61 00 03 94
F00:2019       	MOVE.b	Dtypef(a3),d0		* copy expression data type
               S01:00E009C4:  10 2B 05 B5
F00:2020       	MOVE.b	(sp)+,Dtypef(a3)		* pop variable data type
               S01:00E009C8:  17 5F 05 B5
F00:2021       	ROL.b		#1,d0				* set carry if expression type = string
               S01:00E009CC:  E3 18
F00:2022       	BSR		LAB_CKTM			* type match check, set C for string
               S01:00E009CE:  61 00 03 72
F00:2023       	BEQ		LAB_PFAC			* if number pack FAC1 into variable Lvarpl & RET
               S01:00E009D2:  67 00 14 D2
F00:2024       
F00:2025       * string LET
F00:2026       
F00:2027       LAB_17D5
F00:2028       	MOVEA.l	Lvarpl(a3),a2		* get pointer to variable
               S01:00E009D6:  24 6B 04 72
F00:2029       LAB_17D6
F00:2030       	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
               S01:00E009DA:  20 6B 05 90
F00:2031       	MOVEA.l	(a0),a1			* get string pointer
               S01:00E009DE:  22 50
F00:2032       	CMP.l		Sstorl(a3),a1		* compare string memory start with string
               S01:00E009E0:  B3 EB 04 46
F00:2033       							* pointer
F00:2034       	BCS.s		LAB_1811			* if it was in program memory assign the value
               S01:00E009E4:  65 16
F00:2035       							* and exit
F00:2036       
F00:2037       	CMPA.l	Sfncl(a3),a0		* compare functions start with descriptor
               S01:00E009E6:  B1 EB 04 32
F00:2038       							* pointer
F00:2039       	BCS.s		LAB_1811			* branch if >= (string is on stack)
               S01:00E009EA:  65 10
F00:2040       
F00:2041       							* string is variable$ make space and copy string
F00:2042       LAB_1810
F00:2043       	MOVEQ		#0,d1				* clear length
               S01:00E009EC:  72 00
F00:2044       	MOVE.w	4(a0),d1			* get string length
               S01:00E009EE:  32 28 00 04
F00:2045       	MOVEA.l	(a0),a0			* get string pointer
               S01:00E009F2:  20 50
F00:2046       	BSR		LAB_20C9			* copy string
               S01:00E009F4:  61 00 0B 0A
F00:2047       	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer back
               S01:00E009F8:  20 6B 05 90
F00:2048       							* clean stack & assign value to string variable
F00:2049       LAB_1811
F00:2050       	CMPA.l	a0,a4				* is string on the descriptor stack
               S01:00E009FC:  B9 C8
F00:2051       	BNE.s		LAB_1813			* skip pop if not
               S01:00E009FE:  66 02
F00:2052       
F00:2053       	ADDQ.w	#$06,a4			* else update stack pointer
               S01:00E00A00:  5C 4C
F00:2054       LAB_1813
F00:2055       	MOVE.l	(a0)+,(a2)+			* save pointer to variable
               S01:00E00A02:  24 D8
F00:2056       	MOVE.w	(a0),(a2)			* save length to variable
               S01:00E00A04:  34 90
F00:2057       RTS_008
F00:2058       	RTS
               S01:00E00A06:  4E 75
F00:2059       
F00:2060       
F00:2061       *************************************************************************************
F00:2062       *
F00:2063       * perform GET
F00:2064       
F00:2065       LAB_GET
F00:2066       	BSR		LAB_SVAR			* search for or create a variable
               S01:00E00A08:  61 00 06 BE
F00:2067       							* return the variable address in a0
F00:2068       	MOVE.l	a0,Lvarpl(a3)		* save variable address as GET variable
               S01:00E00A0C:  27 48 04 72
F00:2069       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00A10:  4A 2B 05 B5
F00:2070       							* $00=float
F00:2071       	BMI.s		LAB_GETS			* go get string character
               S01:00E00A14:  6B 0C
F00:2072       
F00:2073       							* was numeric get
F00:2074       	BSR		INGET				* get input byte
               S01:00E00A16:  61 00 1F EC
F00:2075       	BSR		LAB_1FD0			* convert d0 to unsigned byte in FAC1
               S01:00E00A1A:  61 00 09 C0
F00:2076       	BRA		LAB_PFAC			* pack FAC1 into variable (Lvarpl) & return
               S01:00E00A1E:  60 00 14 86
F00:2077       
F00:2078       LAB_GETS
F00:2079       	MOVEQ		#$00,d1			* assume no byte
               S01:00E00A22:  72 00
F00:2080       	MOVE.l	d1,a0				* assume null string
               S01:00E00A24:  20 41
F00:2081       	BSR		INGET				* get input byte
               S01:00E00A26:  61 00 1F DC
F00:2082       	BCC.s		LAB_NoSt			* branch if no byte received
               S01:00E00A2A:  64 08
F00:2083       
F00:2084       	MOVEQ		#$01,d1			* string is single byte
               S01:00E00A2C:  72 01
F00:2085       	BSR		LAB_2115			* make string space d1 bytes long
               S01:00E00A2E:  61 00 0B 02
F00:2086       							* return a0 = pointer, other registers unchanged
F00:2087       
F00:2088       	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
               S01:00E00A32:  10 80
F00:2089       LAB_NoSt
F00:2090       	BSR		LAB_RTST			* push string on descriptor stack
               S01:00E00A34:  61 00 0A E2
F00:2091       							* a0 = pointer, d1 = length
F00:2092       
F00:2093       	BRA.s		LAB_17D5			* do string LET & return
               S01:00E00A38:  60 9C
F00:2094       
F00:2095       
F00:2096       *************************************************************************************
F00:2097       *
F00:2098       * PRINT
F00:2099       
F00:2100       LAB_1829
F00:2101       	BSR		LAB_18C6			* print string from stack
               S01:00E00A3A:  61 00 00 B4
F00:2102       LAB_182C
F00:2103       	BSR		LAB_GBYT			* scan memory
               S01:00E00A3E:  61 00 04 78
F00:2104       
F00:2105       * perform PRINT
F00:2106       
F00:2107       LAB_PRINT
F00:2108       	BEQ.s		LAB_CRLF			* if nothing following just print CR/LF
               S01:00E00A42:  67 4A
F00:2109       
F00:2110       LAB_1831
F00:2111       	CMP.b		#TK_TAB,d0			* compare with TAB( token
               S01:00E00A44:  B0 3C 00 B5
F00:2112       	BEQ.s		LAB_18A2			* go do TAB/SPC
               S01:00E00A48:  67 64
F00:2113       
F00:2114       	CMP.b		#TK_SPC,d0			* compare with SPC( token
               S01:00E00A4A:  B0 3C 00 B9
F00:2115       	BEQ.s		LAB_18A2			* go do TAB/SPC
               S01:00E00A4E:  67 5E
F00:2116       
F00:2117       	CMP.b		#',',d0			* compare with ","
               S01:00E00A50:  B0 3C 00 2C
F00:2118       	BEQ.s		LAB_188B			* go do move to next TAB mark
               S01:00E00A54:  67 40
F00:2119       
F00:2120       	CMP.b		#';',d0			* compare with ";"
               S01:00E00A56:  B0 3C 00 3B
F00:2121       	BEQ		LAB_18BD			* if ";" continue with PRINT processing
               S01:00E00A5A:  67 00 00 86
F00:2122       
F00:2123       	BSR		LAB_EVEX			* evaluate expression
               S01:00E00A5E:  61 00 02 F6
F00:2124       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00A62:  4A 2B 05 B5
F00:2125       							* $00=float
F00:2126       	BMI.s		LAB_1829			* branch if string
               S01:00E00A66:  6B D2
F00:2127       
F00:2128       ** replace the two lines above with this code
F00:2129       
F00:2130       **	MOVE.b	Dtypef(a3),d0		* get data type flag, $80=string, $00=numeric
F00:2131       **	BMI.s		LAB_1829			* branch if string
F00:2132       
F00:2133       	BSR		LAB_2970			* convert FAC1 to string
               S01:00E00A68:  61 00 15 BA
F00:2134       	BSR		LAB_20AE			* print " terminated string to FAC1 stack
               S01:00E00A6C:  61 00 0A 64
F00:2135       
F00:2136       * don't check fit if terminal width byte is zero
F00:2137       
F00:2138       	MOVEQ		#0,d0				* clear d0
               S01:00E00A70:  70 00
F00:2139       	MOVE.b	TWidth(a3),d0		* get terminal width byte
               S01:00E00A72:  10 2B 05 E6
F00:2140       	BEQ.s		LAB_185E			* skip check if zero
               S01:00E00A76:  67 0C
F00:2141       
F00:2142       	SUB.b		7(a4),d0			* subtract string length
               S01:00E00A78:  90 2C 00 07
F00:2143       	SUB.b		TPos(a3),d0			* subtract terminal position
               S01:00E00A7C:  90 2B 05 E5
F00:2144       	BCC.s		LAB_185E			* branch if less than terminal width
               S01:00E00A80:  64 02
F00:2145       
F00:2146       	BSR.s		LAB_CRLF			* else print CR/LF
               S01:00E00A82:  61 0A
F00:2147       LAB_185E
F00:2148       	BSR.s		LAB_18C6			* print string from stack
               S01:00E00A84:  61 6A
F00:2149       	BRA.s		LAB_182C			* always go continue processing line
               S01:00E00A86:  60 B6
F00:2150       
F00:2151       
F00:2152       *************************************************************************************
F00:2153       *
F00:2154       * CR/LF return to BASIC from BASIC input handler
F00:2155       * leaves a0 pointing to the buffer start
F00:2156       
F00:2157       LAB_1866
F00:2158       	MOVE.b	#$00,(a0,d1.w)		* null terminate input
               S01:00E00A88:  11 BC 00 00 10 00
F00:2159       
F00:2160       * print CR/LF
F00:2161       
F00:2162       LAB_CRLF
F00:2163       	MOVEQ		#$0D,d0			* load [CR]
               S01:00E00A8E:  70 0D
F00:2164       	BSR.s		LAB_PRNA			* go print the character
               S01:00E00A90:  61 74
F00:2165       	MOVEQ		#$0A,d0			* load [LF]
               S01:00E00A92:  70 0A
F00:2166       	BRA.s		LAB_PRNA			* go print the character & return
               S01:00E00A94:  60 70
F00:2167       
F00:2168       LAB_188B
F00:2169       	MOVE.b	TPos(a3),d2			* get terminal position
               S01:00E00A96:  14 2B 05 E5
F00:2170       	CMP.b		Iclim(a3),d2		* compare with input column limit
               S01:00E00A9A:  B4 2B 05 E7
F00:2171       	BCS.s		LAB_1898			* branch if less than Iclim
               S01:00E00A9E:  65 04
F00:2172       
F00:2173       	BSR.s		LAB_CRLF			* else print CR/LF (next line)
               S01:00E00AA0:  61 EC
F00:2174       	BRA.s		LAB_18BD			* continue with PRINT processing
               S01:00E00AA2:  60 3E
F00:2175       
F00:2176       LAB_1898
F00:2177       	SUB.b		TabSiz(a3),d2		* subtract TAB size
               S01:00E00AA4:  94 2B 05 E2
F00:2178       	BCC.s		LAB_1898			* loop if result was >= 0
               S01:00E00AA8:  64 FA
F00:2179       
F00:2180       	NEG.b		d2				* twos complement it
               S01:00E00AAA:  44 02
F00:2181       	BRA.s		LAB_18B7			* print d2 spaces
               S01:00E00AAC:  60 22
F00:2182       
F00:2183       							* do TAB/SPC
F00:2184       LAB_18A2
F00:2185       	MOVE.w	d0,-(sp)			* save token
               S01:00E00AAE:  3F 00
F00:2186       	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
               S01:00E00AB0:  61 00 0D 68
F00:2187       	MOVE.w	d0,d2				* copy byte
               S01:00E00AB4:  34 00
F00:2188       	BSR		LAB_GBYT			* get basic byte back
               S01:00E00AB6:  61 00 04 00
F00:2189       	CMP.b		#$29,d0			* is next character ")"
               S01:00E00ABA:  B0 3C 00 29
F00:2190       	BNE		LAB_SNER			* if not do syntax error, then warm start
               S01:00E00ABE:  66 00 F7 BA
F00:2191       
F00:2192       	MOVE.w	(sp)+,d0			* get token back
               S01:00E00AC2:  30 1F
F00:2193       	CMP.b		#TK_TAB,d0			* was it TAB ?
               S01:00E00AC4:  B0 3C 00 B5
F00:2194       	BNE.s		LAB_18B7			* branch if not (was SPC)
               S01:00E00AC8:  66 06
F00:2195       
F00:2196       							* calculate TAB offset
F00:2197       	SUB.b		TPos(a3),d2			* subtract terminal position
               S01:00E00ACA:  94 2B 05 E5
F00:2198       	BLS.s		LAB_18BD			* branch if result was <= 0
               S01:00E00ACE:  63 12
F00:2199       							* can't TAB backwards or already there
F00:2200       
F00:2201       							* print d2.b spaces
F00:2202       LAB_18B7
F00:2203       	MOVEQ		#0,d0				* clear longword
               S01:00E00AD0:  70 00
F00:2204       	SUBQ.b	#1,d0				* make d0 = $FF
               S01:00E00AD2:  53 00
F00:2205       	AND.l		d0,d2				* mask for byte only
               S01:00E00AD4:  C4 80
F00:2206       	BEQ.s		LAB_18BD			* branch if zero
               S01:00E00AD6:  67 0A
F00:2207       
F00:2208       	MOVEQ		#$20,d0			* load " "
               S01:00E00AD8:  70 20
F00:2209       	SUBQ.b	#1,d2				* adjust for DBF loop
               S01:00E00ADA:  53 02
F00:2210       LAB_18B8
F00:2211       	BSR.s		LAB_PRNA			* go print
               S01:00E00ADC:  61 28
F00:2212       	DBF		d2,LAB_18B8			* decrement count and loop if not all done
               S01:00E00ADE:  51 CA FF FC
F00:2213       
F00:2214       							* continue with PRINT processing
F00:2215       LAB_18BD
F00:2216       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E00AE2:  61 00 03 D2
F00:2217       	BNE		LAB_1831			* if byte continue executing PRINT
               S01:00E00AE6:  66 00 FF 5C
F00:2218       
F00:2219       	RTS						* exit if nothing more to print
               S01:00E00AEA:  4E 75
F00:2220       
F00:2221       
F00:2222       *************************************************************************************
F00:2223       *
F00:2224       * print null terminated string from a0
F00:2225       
F00:2226       LAB_18C3
F00:2227       	BSR		LAB_20AE			* print terminated string to FAC1/stack
               S01:00E00AEC:  61 00 09 E4
F00:2228       
F00:2229       * print string from stack
F00:2230       
F00:2231       LAB_18C6
F00:2232       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E00AF0:  61 00 0B CC
F00:2233       							* returns with d0 = length, a0 = pointer
F00:2234       	BEQ.s		RTS_009			* exit (RTS) if null string
               S01:00E00AF4:  67 0C
F00:2235       
F00:2236       	MOVE.w	d0,d1				* copy length & set Z flag
               S01:00E00AF6:  32 00
F00:2237       	SUBQ.w	#1,d1				* -1 for BF loop
               S01:00E00AF8:  53 41
F00:2238       LAB_18CD
F00:2239       	MOVE.b	(a0)+,d0			* get byte from string
               S01:00E00AFA:  10 18
F00:2240       	BSR.s		LAB_PRNA			* go print the character
               S01:00E00AFC:  61 08
F00:2241       	DBF		d1,LAB_18CD			* decrement count and loop if not done yet
               S01:00E00AFE:  51 C9 FF FA
F00:2242       
F00:2243       RTS_009
F00:2244       	RTS
               S01:00E00B02:  4E 75
F00:2245       
F00:2246       
F00:2247       *************************************************************************************
F00:2248       *
F00:2249       * print "?" character
F00:2250       
F00:2251       LAB_18E3
F00:2252       	MOVEQ		#$3F,d0			* load "?" character
               S01:00E00B04:  70 3F
F00:2253       
F00:2254       
F00:2255       *************************************************************************************
F00:2256       *
F00:2257       * print character in d0, includes the null handler and infinite line length code
F00:2258       * changes no registers
F00:2259       
F00:2260       LAB_PRNA
F00:2261       	MOVE.l	d1,-(sp)			* save d1
               S01:00E00B06:  2F 01
F00:2262       	CMP.b		#$20,d0			* compare with " "
               S01:00E00B08:  B0 3C 00 20
F00:2263       	BCS.s		LAB_18F9			* branch if less, non printing character
               S01:00E00B0C:  65 28
F00:2264       
F00:2265       							* don't check fit if terminal width byte is zero
F00:2266       	MOVE.b	TWidth(a3),d1		* get terminal width
               S01:00E00B0E:  12 2B 05 E6
F00:2267       	BNE.s		LAB_18F0			* branch if not zero (not infinite length)
               S01:00E00B12:  66 10
F00:2268       
F00:2269       							* is "infinite line" so check TAB position
F00:2270       	MOVE.b	TPos(a3),d1			* get position
               S01:00E00B14:  12 2B 05 E5
F00:2271       	SUB.b		TabSiz(a3),d1		* subtract TAB size
               S01:00E00B18:  92 2B 05 E2
F00:2272       	BNE.s		LAB_18F7			* skip reset if different
               S01:00E00B1C:  66 14
F00:2273       
F00:2274       	MOVE.b	d1,TPos(a3)			* else reset position
               S01:00E00B1E:  17 41 05 E5
F00:2275       	BRA.s		LAB_18F7			* go print character
               S01:00E00B22:  60 0E
F00:2276       
F00:2277       LAB_18F0
F00:2278       	CMP.b		TPos(a3),d1			* compare with terminal character position
               S01:00E00B24:  B2 2B 05 E5
F00:2279       	BNE.s		LAB_18F7			* branch if not at end of line
               S01:00E00B28:  66 08
F00:2280       
F00:2281       	MOVE.l	d0,-(sp)			* save d0
               S01:00E00B2A:  2F 00
F00:2282       	BSR		LAB_CRLF			* else print CR/LF
               S01:00E00B2C:  61 00 FF 60
F00:2283       	MOVE.l	(sp)+,d0			* restore d0
               S01:00E00B30:  20 1F
F00:2284       LAB_18F7
F00:2285       	ADDQ.b	#$01,TPos(a3)		* increment terminal position
               S01:00E00B32:  52 2B 05 E5
F00:2286       LAB_18F9
F00:2287       	JSR		V_OUTP(a3)			* output byte via output vector
               S01:00E00B36:  4E AB 04 12
F00:2288       	CMP.b		#$0D,d0			* compare with [CR]
               S01:00E00B3A:  B0 3C 00 0D
F00:2289       	BNE.s		LAB_188A			* branch if not [CR]
               S01:00E00B3E:  66 18
F00:2290       
F00:2291       							* else print nullct nulls after the [CR]
F00:2292       	MOVEQ		#$00,d1			* clear d1
               S01:00E00B40:  72 00
F00:2293       	MOVE.b	Nullct(a3),d1		* get null count
               S01:00E00B42:  12 2B 05 E4
F00:2294       	BEQ.s		LAB_1886			* branch if no nulls
               S01:00E00B46:  67 0C
F00:2295       
F00:2296       	MOVEQ		#$00,d0			* load [NULL]
               S01:00E00B48:  70 00
F00:2297       LAB_1880
F00:2298       	JSR		V_OUTP(a3)			* go print the character
               S01:00E00B4A:  4E AB 04 12
F00:2299       	DBF		d1,LAB_1880			* decrement count and loop if not all done
               S01:00E00B4E:  51 C9 FF FA
F00:2300       
F00:2301       	MOVEQ		#$0D,d0			* restore the character
               S01:00E00B52:  70 0D
F00:2302       LAB_1886
F00:2303       	MOVE.b	d1,TPos(a3)			* clear terminal position
               S01:00E00B54:  17 41 05 E5
F00:2304       LAB_188A
F00:2305       	MOVE.l	(sp)+,d1			* restore d1
               S01:00E00B58:  22 1F
F00:2306       	RTS
               S01:00E00B5A:  4E 75
F00:2307       
F00:2308       
F00:2309       *************************************************************************************
F00:2310       *
F00:2311       * handle bad input data
F00:2312       
F00:2313       LAB_1904
F00:2314       	MOVEA.l	(sp)+,a5			* restore execute pointer
               S01:00E00B5C:  2A 5F
F00:2315       	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
               S01:00E00B5E:  4A 2B 05 E0
F00:2316       	BPL.s		LAB_1913			* branch if INPUT (go do redo)
               S01:00E00B62:  6A 0A
F00:2317       
F00:2318       	MOVE.l	Dlinel(a3),Clinel(a3)	* save DATA line as current line
               S01:00E00B64:  27 6B 04 5E 04 52
F00:2319       	BRA		LAB_TMER			* do type mismatch error, then warm start
               S01:00E00B6A:  60 00 F6 E2
F00:2320       
F00:2321       							* mode was INPUT
F00:2322       LAB_1913
F00:2323       	LEA		LAB_REDO(pc),a0		* point to redo message
               S01:00E00B6E:  41 FA 2D 02
F00:2324       	BSR		LAB_18C3			* print null terminated string from memory
               S01:00E00B72:  61 00 FF 78
F00:2325       	MOVEA.l	Cpntrl(a3),a5		* save continue pointer as BASIC execute pointer
               S01:00E00B76:  2A 6B 04 5A
F00:2326       	RTS
               S01:00E00B7A:  4E 75
F00:2327       
F00:2328       
F00:2329       *************************************************************************************
F00:2330       *
F00:2331       * perform INPUT
F00:2332       
F00:2333       LAB_INPUT
F00:2334       	BSR		LAB_CKRN			* check not direct (back here if ok)
               S01:00E00B7C:  61 00 08 66
F00:2335       	CMP.b		#'"',d0			* compare the next byte with open quote
               S01:00E00B80:  B0 3C 00 22
F00:2336       	BNE.s		LAB_1934			* if no prompt string just go get the input
               S01:00E00B84:  66 0E
F00:2337       
F00:2338       	BSR		LAB_1BC1			* print "..." string
               S01:00E00B86:  61 00 03 06
F00:2339       	MOVEQ		#';',d0			* set the search character to ";"
               S01:00E00B8A:  70 3B
F00:2340       	BSR		LAB_SCCA			* scan for CHR$(d0), else do syntax error/warm
               S01:00E00B8C:  61 00 03 20
F00:2341       							* start
F00:2342       	BSR		LAB_18C6			* print string from Sutill/Sutilh
               S01:00E00B90:  61 00 FF 5E
F00:2343       							* finished the prompt, now read the data
F00:2344       LAB_1934
F00:2345       	BSR		LAB_INLN			* print "? " and get BASIC input
               S01:00E00B94:  61 00 F8 0E
F00:2346       							* return a0 pointing to the buffer start
F00:2347       	MOVEQ		#0,d0				* flag INPUT
               S01:00E00B98:  70 00
F00:2348       
F00:2349       * if you don't want a null response to INPUT to break the program then set the nobrk
F00:2350       * value at the top of this file to some non zero value
F00:2351       
F00:2352        ifne	nobrk
F00:2353       
F00:2354       	BRA.s		LAB_1953			* go handle the input
F00:2355       
F00:2356        endc
F00:2357       
F00:2358       * if you do want a null response to INPUT to break the program then leave the nobrk
F00:2359       * value at the top of this file set to zero
F00:2360       
F00:2361        ifeq	nobrk
F00:2362       
F00:2363       	TST.b		(a0)				* test first byte from buffer
               S01:00E00B9A:  4A 10
F00:2364       	BNE.s		LAB_1953			* branch if not null input
               S01:00E00B9C:  66 0A
F00:2365       
F00:2366       	BRA		LAB_1647			* else go do BREAK exit
               S01:00E00B9E:  60 00 FB 5E
F00:2367       
F00:2368        endc
F00:2369       
F00:2370       
F00:2371       *************************************************************************************
F00:2372       *
F00:2373       * perform READ
F00:2374       
F00:2375       LAB_READ
F00:2376       	MOVEA.l	Dptrl(a3),a0		* get the DATA pointer
               S01:00E00BA2:  20 6B 04 62
F00:2377       	MOVEQ		#$98-$100,d0		* flag READ
               S01:00E00BA6:  70 98
F00:2378       LAB_1953
F00:2379       	MOVE.b	d0,Imode(a3)		* set input mode flag, $00=INPUT, $98=READ
               S01:00E00BA8:  17 40 05 E0
F00:2380       	MOVE.l	a0,Rdptrl(a3)		* save READ pointer
               S01:00E00BAC:  27 48 04 66
F00:2381       
F00:2382       							* READ or INPUT the next variable from list
F00:2383       LAB_195B
F00:2384       	BSR		LAB_SVAR			* search for or create a variable
               S01:00E00BB0:  61 00 05 16
F00:2385       							* return the variable address in a0
F00:2386       	MOVE.l	a0,Lvarpl(a3)		* save variable address as LET variable
               S01:00E00BB4:  27 48 04 72
F00:2387       	MOVE.l	a5,-(sp)			* save BASIC execute pointer
               S01:00E00BB8:  2F 0D
F00:2388       LAB_1961
F00:2389       	MOVEA.l	Rdptrl(a3),a5		* set READ pointer as BASIC execute pointer
               S01:00E00BBA:  2A 6B 04 66
F00:2390       	BSR		LAB_GBYT			* scan memory
               S01:00E00BBE:  61 00 02 F8
F00:2391       	BNE.s		LAB_1986			* if not null go get the value
               S01:00E00BC2:  66 1E
F00:2392       
F00:2393       							* the pointer was to a null entry
F00:2394       	TST.b		Imode(a3)			* test input mode flag, $00=INPUT, $98=READ
               S01:00E00BC4:  4A 2B 05 E0
F00:2395       	BMI.s		LAB_19DD			* branch if READ (go find the next statement)
               S01:00E00BC8:  6B 72
F00:2396       
F00:2397       							* else the mode was INPUT so get more
F00:2398       	BSR		LAB_18E3			* print a "?" character
               S01:00E00BCA:  61 00 FF 38
F00:2399       	BSR		LAB_INLN			* print "? " and get BASIC input
               S01:00E00BCE:  61 00 F7 D4
F00:2400       							* return a0 pointing to the buffer start
F00:2401       
F00:2402       * if you don't want a null response to INPUT to break the program then set the nobrk
F00:2403       * value at the top of this file to some non zero value
F00:2404       
F00:2405        ifne	nobrk
F00:2406       
F00:2407       	MOVE.l	a0,Rdptrl(a3)		* save the READ pointer
F00:2408       	BRA.s		LAB_1961			* go handle the input
F00:2409       
F00:2410        endc
F00:2411       
F00:2412       * if you do want a null response to INPUT to break the program then leave the nobrk
F00:2413       * value at the top of this file set to zero
F00:2414       
F00:2415        ifeq	nobrk
F00:2416       
F00:2417       	TST.b		(a0)				* test the first byte from the buffer
               S01:00E00BD2:  4A 10
F00:2418       	BNE.s		LAB_1984			* if not null input go handle it
               S01:00E00BD4:  66 04
F00:2419       
F00:2420       	BRA		LAB_1647			* else go do the BREAK exit
               S01:00E00BD6:  60 00 FB 26
F00:2421       
F00:2422       LAB_1984
F00:2423       	MOVEA.l	a0,a5				* set the execute pointer to the buffer
               S01:00E00BDA:  2A 48
F00:2424       	SUBQ.w	#1,a5				* decrement the execute pointer
               S01:00E00BDC:  53 4D
F00:2425       
F00:2426        endc
F00:2427       
F00:2428       LAB_1985
F00:2429       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E00BDE:  61 00 02 D6
F00:2430       LAB_1986
F00:2431       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00BE2:  4A 2B 05 B5
F00:2432       							* $00=float
F00:2433       	BPL.s		LAB_19B0			* branch if numeric
               S01:00E00BE6:  6A 20
F00:2434       
F00:2435       							* else get string
F00:2436       	MOVE.b	d0,d2				* save search character
               S01:00E00BE8:  14 00
F00:2437       	CMP.b		#$22,d0			* was it " ?
               S01:00E00BEA:  B0 3C 00 22
F00:2438       	BEQ.s		LAB_1999			* branch if so
               S01:00E00BEE:  67 06
F00:2439       
F00:2440       	MOVEQ		#':',d2			* set new search character
               S01:00E00BF0:  74 3A
F00:2441       	MOVEQ		#',',d0			* other search character is ","
               S01:00E00BF2:  70 2C
F00:2442       	SUBQ.w	#1,a5				* decrement BASIC execute pointer
               S01:00E00BF4:  53 4D
F00:2443       LAB_1999
F00:2444       	ADDQ.w	#1,a5				* increment BASIC execute pointer
               S01:00E00BF6:  52 4D
F00:2445       	MOVE.b	d0,d3				* set second search character
               S01:00E00BF8:  16 00
F00:2446       	MOVEA.l	a5,a0				* BASIC execute pointer is source
               S01:00E00BFA:  20 4D
F00:2447       
F00:2448       	BSR		LAB_20B4			* print d2/d3 terminated string to FAC1 stack
               S01:00E00BFC:  61 00 08 D8
F00:2449       							* d2 = Srchc, d3 = Asrch, a0 is source
F00:2450       	MOVEA.l	a2,a5				* copy end of string to BASIC execute pointer
               S01:00E00C00:  2A 4A
F00:2451       	BSR		LAB_17D5			* go do string LET
               S01:00E00C02:  61 00 FD D2
F00:2452       	BRA.s		LAB_19B6			* go check string terminator
               S01:00E00C06:  60 10
F00:2453       
F00:2454       							* get numeric INPUT
F00:2455       LAB_19B0
F00:2456       	MOVE.b	Dtypef(a3),-(sp)		* save variable data type
               S01:00E00C08:  1F 2B 05 B5
F00:2457       	BSR		LAB_2887			* get FAC1 from string
               S01:00E00C0C:  61 00 1F 9E
F00:2458       	MOVE.b	(sp)+,Dtypef(a3)		* restore variable data type
               S01:00E00C10:  17 5F 05 B5
F00:2459       	BSR		LAB_PFAC			* pack FAC1 into (Lvarpl)
               S01:00E00C14:  61 00 12 90
F00:2460       LAB_19B6
F00:2461       	BSR		LAB_GBYT			* scan memory
               S01:00E00C18:  61 00 02 9E
F00:2462       	BEQ.s		LAB_19C2			* branch if null (last entry)
               S01:00E00C1C:  67 0A
F00:2463       
F00:2464       	CMP.b		#',',d0			* else compare with ","
               S01:00E00C1E:  B0 3C 00 2C
F00:2465       	BNE		LAB_1904			* if not "," go handle bad input data
               S01:00E00C22:  66 00 FF 38
F00:2466       
F00:2467       	ADDQ.w	#1,a5				* else was "," so point to next chr
               S01:00E00C26:  52 4D
F00:2468       							* got good input data
F00:2469       LAB_19C2
F00:2470       	MOVE.l	a5,Rdptrl(a3)		* save the read pointer for now
               S01:00E00C28:  27 4D 04 66
F00:2471       	MOVEA.l	(sp)+,a5			* restore the execute pointer
               S01:00E00C2C:  2A 5F
F00:2472       	BSR		LAB_GBYT			* scan the memory
               S01:00E00C2E:  61 00 02 88
F00:2473       	BEQ.s		LAB_1A03			* if null go do extra ignored message
               S01:00E00C32:  67 36
F00:2474       
F00:2475       	PEA		LAB_195B(pc)		* set return address
               S01:00E00C34:  48 7A FF 7A
F00:2476       	BRA		LAB_1C01			* scan for "," else do syntax error/warm start
               S01:00E00C38:  60 00 02 72
F00:2477       							* then go INPUT next variable from list
F00:2478       
F00:2479       							* find next DATA statement or do "Out of Data"
F00:2480       							* error
F00:2481       LAB_19DD
F00:2482       	BSR		LAB_SNBS			* scan for next BASIC statement ([:] or [EOL])
               S01:00E00C3C:  61 00 FC 04
F00:2483       							* returns a0 as pointer to [:] or [EOL]
F00:2484       	MOVEA.l	a0,a5				* add index, now = pointer to [EOL]/[EOS]
               S01:00E00C40:  2A 48
F00:2485       	ADDQ.w	#1,a5				* pointer to next character
               S01:00E00C42:  52 4D
F00:2486       	CMP.b		#':',d0			* was it statement end?
               S01:00E00C44:  B0 3C 00 3A
F00:2487       	BEQ.s		LAB_19F6			* branch if [:]
               S01:00E00C48:  67 12
F00:2488       
F00:2489       							* was [EOL] so find next line
F00:2490       
F00:2491       	MOVE.w	a5,d1				* past pad byte(s)
               S01:00E00C4A:  32 0D
F00:2492       	AND.w		#1,d1				* mask odd bit
               S01:00E00C4C:  C2 7C 00 01
F00:2493       	ADD.w		d1,a5				* add pointer
               S01:00E00C50:  DA C1
F00:2494       	MOVE.l	(a5)+,d2			* get next line pointer
               S01:00E00C52:  24 1D
F00:2495       	BEQ		LAB_ODER			* branch if end of program
               S01:00E00C54:  67 00 F6 1C
F00:2496       
F00:2497       	MOVE.l	(a5)+,Dlinel(a3)		* save current DATA line
               S01:00E00C58:  27 5D 04 5E
F00:2498       LAB_19F6
F00:2499       	BSR		LAB_GBYT			* scan memory
               S01:00E00C5C:  61 00 02 5A
F00:2500       	CMP.b		#TK_DATA,d0			* compare with "DATA" token
               S01:00E00C60:  B0 3C 00 83
F00:2501       	BEQ		LAB_1985			* was "DATA" so go do next READ
               S01:00E00C64:  67 00 FF 78
F00:2502       
F00:2503       	BRA.s		LAB_19DD			* go find next statement if not "DATA"
               S01:00E00C68:  60 D2
F00:2504       
F00:2505       * end of INPUT/READ routine
F00:2506       
F00:2507       LAB_1A03
F00:2508       	MOVEA.l	Rdptrl(a3),a0		* get temp READ pointer
               S01:00E00C6A:  20 6B 04 66
F00:2509       	TST.b		Imode(a3)			* get input mode flag, $00=INPUT, $98=READ
               S01:00E00C6E:  4A 2B 05 E0
F00:2510       	BPL.s		LAB_1A0E			* branch if INPUT
               S01:00E00C72:  6A 06
F00:2511       
F00:2512       	MOVE.l	a0,Dptrl(a3)		* else save temp READ pointer as DATA pointer
               S01:00E00C74:  27 48 04 62
F00:2513       	RTS
               S01:00E00C78:  4E 75
F00:2514       
F00:2515       							* we were getting INPUT
F00:2516       LAB_1A0E
F00:2517       	TST.b		(a0)				* test next byte
               S01:00E00C7A:  4A 10
F00:2518       	BNE.s		LAB_1A1B			* error if not end of INPUT
               S01:00E00C7C:  66 02
F00:2519       
F00:2520       	RTS
               S01:00E00C7E:  4E 75
F00:2521       							* user typed too much
F00:2522       LAB_1A1B
F00:2523       	LEA		LAB_IMSG(pc),a0		* point to extra ignored message
               S01:00E00C80:  41 FA 2B E0
F00:2524       	BRA		LAB_18C3			* print null terminated string from memory & RTS
               S01:00E00C84:  60 00 FE 66
F00:2525       
F00:2526       
F00:2527       *************************************************************************************
F00:2528       *
F00:2529       * perform NEXT
F00:2530       
F00:2531       LAB_NEXT
F00:2532       	BNE.s		LAB_1A46			* branch if NEXT var
               S01:00E00C88:  66 10
F00:2533       
F00:2534       	ADDQ.w	#4,sp				* back past return address
               S01:00E00C8A:  58 4F
F00:2535       	CMP.w		#TK_FOR,(sp)		* is FOR token on stack?
               S01:00E00C8C:  0C 57 00 81
F00:2536       	BNE		LAB_NFER			* if not do NEXT without FOR err/warm start
               S01:00E00C90:  66 00 F5 EC
F00:2537       
F00:2538       	MOVEA.l	2(sp),a0			* get stacked FOR variable pointer
               S01:00E00C94:  20 6F 00 02
F00:2539       	BRA.s		LAB_11BD			* branch always (no variable to search for)
               S01:00E00C98:  60 1C
F00:2540       
F00:2541       * NEXT var
F00:2542       
F00:2543       LAB_1A46
F00:2544       	BSR		LAB_GVAR			* get variable address in a0
               S01:00E00C9A:  61 00 04 30
F00:2545       	ADDQ.w	#4,sp				* back past return address
               S01:00E00C9E:  58 4F
F00:2546       	MOVE.w	#TK_FOR,d0			* set for FOR token
               S01:00E00CA0:  30 3C 00 81
F00:2547       	MOVEQ		#$1C,d1			* set for FOR use size
               S01:00E00CA4:  72 1C
F00:2548       	BRA.s		LAB_11A6			* enter loop for next variable search
               S01:00E00CA6:  60 02
F00:2549       
F00:2550       LAB_11A5
F00:2551       	ADDA.l	d1,sp				* add FOR stack use size
               S01:00E00CA8:  DF C1
F00:2552       LAB_11A6
F00:2553       	CMP.w		(sp),d0			* is FOR token on stack?
               S01:00E00CAA:  B0 57
F00:2554       	BNE		LAB_NFER			* if not found do NEXT without FOR error and
               S01:00E00CAC:  66 00 F5 D0
F00:2555       							* warm start
F00:2556       
F00:2557       							* was FOR token
F00:2558       	CMPA.l	2(sp),a0			* compare var pointer with stacked var pointer
               S01:00E00CB0:  B1 EF 00 02
F00:2559       	BNE.s		LAB_11A5			* loop if no match found
               S01:00E00CB4:  66 F2
F00:2560       
F00:2561       LAB_11BD
F00:2562       	MOVE.w	6(sp),FAC2_e(a3)		* get STEP value exponent and sign
               S01:00E00CB6:  37 6F 00 06 05 9C
F00:2563       	MOVE.l	8(sp),FAC2_m(a3)		* get STEP value mantissa
               S01:00E00CBC:  27 6F 00 08 05 98
F00:2564       
F00:2565       	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type
               S01:00E00CC2:  17 6F 00 12 05 B5
F00:2566       	BSR		LAB_1C19			* check type and unpack (a0)
               S01:00E00CC8:  61 00 02 1A
F00:2567       
F00:2568       	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
               S01:00E00CCC:  17 6B 05 9D 05 9E
F00:2569       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
               S01:00E00CD2:  10 2B 05 95
F00:2570       	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
               S01:00E00CD6:  B1 2B 05 9E
F00:2571       
F00:2572       	MOVE.l	a0,Lvarpl(a3)		* save variable pointer
               S01:00E00CDA:  27 48 04 72
F00:2573       	BSR		LAB_ADD			* add STEP value to FOR variable
               S01:00E00CDE:  61 00 0E C8
F00:2574       	MOVE.b	18(sp),Dtypef(a3)		* restore FOR variable data type (again)
               S01:00E00CE2:  17 6F 00 12 05 B5
F00:2575       	BSR		LAB_PFAC			* pack FAC1 into FOR variable (Lvarpl)
               S01:00E00CE8:  61 00 11 BC
F00:2576       
F00:2577       	MOVE.w	12(sp),FAC2_e(a3)		* get TO value exponent and sign
               S01:00E00CEC:  37 6F 00 0C 05 9C
F00:2578       	MOVE.l	14(sp),FAC2_m(a3)		* get TO value mantissa
               S01:00E00CF2:  27 6F 00 0E 05 98
F00:2579       
F00:2580       	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* save FAC2 sign as sign compare
               S01:00E00CF8:  17 6B 05 9D 05 9E
F00:2581       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
               S01:00E00CFE:  10 2B 05 95
F00:2582       	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
               S01:00E00D02:  B1 2B 05 9E
F00:2583       
F00:2584       	BSR		LAB_27FA			* compare FAC1 with FAC2 (TO value)
               S01:00E00D06:  61 00 12 48
F00:2585       							* returns d0=+1 if FAC1 > FAC2
F00:2586       							* returns d0= 0 if FAC1 = FAC2
F00:2587       							* returns d0=-1 if FAC1 < FAC2
F00:2588       
F00:2589       	MOVE.w	6(sp),d1			* get STEP value exponent and sign
               S01:00E00D0A:  32 2F 00 06
F00:2590       	EOR.w		d0,d1				* EOR compare result with STEP exponent and sign
               S01:00E00D0E:  B1 41
F00:2591       
F00:2592       	TST.b		d0				* test for =
               S01:00E00D10:  4A 00
F00:2593       	BEQ.s		LAB_1A90			* branch if = (loop INcomplete)
               S01:00E00D12:  67 04
F00:2594       
F00:2595       	TST.b		d1				* test result
               S01:00E00D14:  4A 01
F00:2596       	BPL.s		LAB_1A9B			* branch if > (loop complete)
               S01:00E00D16:  6A 0E
F00:2597       
F00:2598       							* loop back and do it all again
F00:2599       LAB_1A90
F00:2600       	MOVE.l	20(sp),Clinel(a3)		* reset current line
               S01:00E00D18:  27 6F 00 14 04 52
F00:2601       	MOVE.l	24(sp),a5			* reset BASIC execute pointer
               S01:00E00D1E:  2A 6F 00 18
F00:2602       	BRA		LAB_15C2			* go do interpreter inner loop
               S01:00E00D22:  60 00 F9 76
F00:2603       
F00:2604       							* loop complete so carry on
F00:2605       LAB_1A9B
F00:2606       	ADDA.w	#28,sp			* add 28 to dump FOR structure
               S01:00E00D26:  4F EF 00 1C
F00:2607       	BSR		LAB_GBYT			* scan memory
               S01:00E00D2A:  61 00 01 8C
F00:2608       	CMP.b		#$2C,d0			* compare with ","
               S01:00E00D2E:  B0 3C 00 2C
F00:2609       	BNE		LAB_15C2			* if not "," go do interpreter inner loop
               S01:00E00D32:  66 00 F9 66
F00:2610       
F00:2611       							* was "," so another NEXT variable to do
F00:2612       	BSR		LAB_IGBY			* else increment & scan memory
               S01:00E00D36:  61 00 01 7E
F00:2613       	BSR		LAB_1A46			* do NEXT (var)
               S01:00E00D3A:  61 00 FF 5E
F00:2614       
F00:2615       
F00:2616       *************************************************************************************
F00:2617       *
F00:2618       * evaluate expression & check is numeric, else do type mismatch
F00:2619       
F00:2620       LAB_EVNM
F00:2621       	BSR.s		LAB_EVEX			* evaluate expression
               S01:00E00D3E:  61 16
F00:2622       
F00:2623       
F00:2624       *************************************************************************************
F00:2625       *
F00:2626       * check if source is numeric, else do type mismatch
F00:2627       
F00:2628       LAB_CTNM
F00:2629       	CMP.w		d0,d0				* required type is numeric so clear carry
               S01:00E00D40:  B0 40
F00:2630       
F00:2631       
F00:2632       *************************************************************************************
F00:2633       *
F00:2634       * type match check, set C for string, clear C for numeric
F00:2635       
F00:2636       LAB_CKTM
F00:2637       	BTST.b	#7,Dtypef(a3)		* test data type flag, don't change carry
               S01:00E00D42:  08 2B 00 07 05 B5
F00:2638       	BNE.s		LAB_1ABA			* branch if data type is string
               S01:00E00D48:  66 06
F00:2639       
F00:2640       							* else data type was numeric
F00:2641       	BCS		LAB_TMER			* if required type is string do type mismatch
               S01:00E00D4A:  65 00 F5 02
F00:2642       							* error
F00:2643       
F00:2644       	RTS
               S01:00E00D4E:  4E 75
F00:2645       							* data type was string, now check required type
F00:2646       LAB_1ABA
F00:2647       	BCC		LAB_TMER			* if required type is numeric do type mismatch
               S01:00E00D50:  64 00 F4 FC
F00:2648       							* error
F00:2649       	RTS
               S01:00E00D54:  4E 75
F00:2650       
F00:2651       
F00:2652       *************************************************************************************
F00:2653       *
F00:2654       * this routine evaluates any type of expression. first it pushes an end marker so
F00:2655       * it knows when the expression has been evaluated, this is a precedence value of zero.
F00:2656       * next the first value is evaluated, this can be an in line value, either numeric or
F00:2657       * string, a variable or array element of any type, a function or even an expression
F00:2658       * in parenthesis. this value is kept in FAC_1
F00:2659       * after the value is evaluated a test is made on the next BASIC program byte, if it
F00:2660       * is a comparrison operator i.e. "<", "=" or ">", then the corresponding bit is set
F00:2661       * in the comparison evaluation flag. this test loops until no more comparrison operators
F00:2662       * are found or more than one of any type is found. in the last case an error is generated
F00:2663       
F00:2664       * evaluate expression
F00:2665       
F00:2666       LAB_EVEX
F00:2667       	SUBQ.w	#1,a5				* decrement BASIC execute pointer
               S01:00E00D56:  53 4D
F00:2668       LAB_EVEZ
F00:2669       	MOVEQ		#0,d1				* clear precedence word
               S01:00E00D58:  72 00
F00:2670       	MOVE.b	d1,Dtypef(a3)		* clear the data type, $80=string, $40=integer,
               S01:00E00D5A:  17 41 05 B5
F00:2671       							* $00=float
F00:2672       	BRA.s		LAB_1ACD			* enter loop
               S01:00E00D5E:  60 1C
F00:2673       
F00:2674       * get vector, set up operator then continue evaluation
F00:2675       
F00:2676       LAB_1B43						*
F00:2677       	LEA		LAB_OPPT(pc),a0		* point to operator vector table
               S01:00E00D60:  41 FA 24 E4
F00:2678       	MOVE.w	2(a0,d1.w),d0		* get vector offset
               S01:00E00D64:  30 30 10 02
F00:2679       	PEA		(a0,d0.w)			* push vector
               S01:00E00D68:  48 70 00 00
F00:2680       
F00:2681       	MOVE.l	FAC1_m(a3),-(sp)		* push FAC1 mantissa
               S01:00E00D6C:  2F 2B 05 90
F00:2682       	MOVE.w	FAC1_e(a3),-(sp)		* push sign and exponent
               S01:00E00D70:  3F 2B 05 94
F00:2683       	MOVE.b	comp_f(a3),-(sp)		* push comparison evaluation flag
               S01:00E00D74:  1F 2B 05 E3
F00:2684       
F00:2685       	MOVE.w	(a0,d1.w),d1		* get precedence value
               S01:00E00D78:  32 30 10 00
F00:2686       LAB_1ACD
F00:2687       	MOVE.w	d1,-(sp)			* push precedence value
               S01:00E00D7C:  3F 01
F00:2688       	BSR		LAB_GVAL			* get value from line
               S01:00E00D7E:  61 00 00 E4
F00:2689       	MOVE.b	#$00,comp_f(a3)		* clear compare function flag
               S01:00E00D82:  17 7C 00 00 05 E3
F00:2690       LAB_1ADB
F00:2691       	BSR		LAB_GBYT			* scan memory
               S01:00E00D88:  61 00 01 2E
F00:2692       LAB_1ADE
F00:2693       	SUB.b		#TK_GT,d0			* subtract token for > (lowest compare function)
               S01:00E00D8C:  90 3C 00 C9
F00:2694       	BCS.s		LAB_1AFA			* branch if < TK_GT
               S01:00E00D90:  65 2A
F00:2695       
F00:2696       	CMP.b		#$03,d0			* compare with ">" to "<" tokens
               S01:00E00D92:  B0 3C 00 03
F00:2697       	BCS.s		LAB_1AE0			* branch if <= TK_SGN (is compare function)
               S01:00E00D96:  65 0A
F00:2698       
F00:2699       	TST.b		comp_f(a3)			* test compare function flag
               S01:00E00D98:  4A 2B 05 E3
F00:2700       	BNE.s		LAB_1B2A			* branch if compare function
               S01:00E00D9C:  66 60
F00:2701       
F00:2702       	BRA		LAB_1B78			* go do functions
               S01:00E00D9E:  60 00 00 86
F00:2703       
F00:2704       							* was token for > = or < (d0 = 0, 1 or 2)
F00:2705       LAB_1AE0
F00:2706       	MOVEQ		#1,d1				* set to 0000 0001
               S01:00E00DA2:  72 01
F00:2707       	ASL.b		d0,d1				* 1 if >, 2 if =, 4 if <
               S01:00E00DA4:  E1 21
F00:2708       	MOVE.b	comp_f(a3),d0		* copy old compare function flag
               S01:00E00DA6:  10 2B 05 E3
F00:2709       	EOR.b		d1,comp_f(a3)		* EOR in this compare function bit
               S01:00E00DAA:  B3 2B 05 E3
F00:2710       	CMP.b		comp_f(a3),d0		* compare old with new compare function flag
               S01:00E00DAE:  B0 2B 05 E3
F00:2711       	BCC		LAB_SNER			* if new <= old comp_f do syntax error and warm
               S01:00E00DB2:  64 00 F4 C6
F00:2712       							* start, there was more than one <, = or >
F00:2713       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E00DB6:  61 00 00 FE
F00:2714       	BRA.s		LAB_1ADE			* go do next character
               S01:00E00DBA:  60 D0
F00:2715       
F00:2716       							* token is < ">" or > "<" tokens
F00:2717       LAB_1AFA
F00:2718       	TST.b		comp_f(a3)			* test compare function flag
               S01:00E00DBC:  4A 2B 05 E3
F00:2719       	BNE.s		LAB_1B2A			* branch if compare function
               S01:00E00DC0:  66 3C
F00:2720       
F00:2721       							* was < TK_GT so is operator or lower
F00:2722       	ADD.b	#(TK_GT-TK_PLUS),d0		* add # of operators (+ - * / ^ AND OR EOR)
               S01:00E00DC2:  D0 3C 00 0A
F00:2723       	BCC.s		LAB_1B78			* branch if < + operator
               S01:00E00DC6:  64 5E
F00:2724       
F00:2725       	BNE.s		LAB_1B0B			* branch if not + token
               S01:00E00DC8:  66 08
F00:2726       
F00:2727       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00DCA:  4A 2B 05 B5
F00:2728       							* $00=float
F00:2729       	BMI		LAB_224D			* type is string & token was +
               S01:00E00DCE:  6B 00 08 7A
F00:2730       
F00:2731       LAB_1B0B
F00:2732       	MOVEQ		#0,d1				* clear longword
               S01:00E00DD2:  72 00
F00:2733       	ADD.b		d0,d0				* *2
               S01:00E00DD4:  D0 00
F00:2734       	ADD.b		d0,d0				* *4
               S01:00E00DD6:  D0 00
F00:2735       	MOVE.b	d0,d1				* copy to index
               S01:00E00DD8:  12 00
F00:2736       LAB_1B13
F00:2737       	MOVE.w	(sp)+,d0			* pull previous precedence
               S01:00E00DDA:  30 1F
F00:2738       	LEA		LAB_OPPT(pc),a0		* set pointer to operator table
               S01:00E00DDC:  41 FA 24 68
F00:2739       	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
               S01:00E00DE0:  B0 70 10 00
F00:2740       	BCC.s		LAB_1B7D			* branch if previous precedence (d0) >=
               S01:00E00DE4:  64 46
F00:2741       
F00:2742       	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
               S01:00E00DE6:  61 00 FF 58
F00:2743       LAB_1B1C
F00:2744       	MOVE.w	d0,-(sp)			* save precedence
               S01:00E00DEA:  3F 00
F00:2745       LAB_1B1D
F00:2746       	BSR		LAB_1B43			* get vector, set-up operator and continue
               S01:00E00DEC:  61 00 FF 72
F00:2747       							* evaluation
F00:2748       	MOVE.w	(sp)+,d0			* restore precedence
               S01:00E00DF0:  30 1F
F00:2749       	MOVE.l	prstk(a3),d1		* get stacked function pointer
               S01:00E00DF2:  22 2B 05 D8
F00:2750       	BPL.s		LAB_1B3C			* branch if stacked values
               S01:00E00DF6:  6A 22
F00:2751       
F00:2752       	MOVE.w	d0,d0				* copy precedence (set flags)
               S01:00E00DF8:  30 00
F00:2753       	BEQ.s		LAB_1B7B			* exit if done
               S01:00E00DFA:  67 2E
F00:2754       
F00:2755       	BRA.s		LAB_1B86			* else pop FAC2 & return (do function)
               S01:00E00DFC:  60 3C
F00:2756       
F00:2757       							* was compare function (< = >)
F00:2758       LAB_1B2A
F00:2759       	MOVE.b	Dtypef(a3),d0		* get data type flag
               S01:00E00DFE:  10 2B 05 B5
F00:2760       	MOVE.b	comp_f(a3),d1		* get compare function flag
               S01:00E00E02:  12 2B 05 E3
F00:2761       	ADD.b		d0,d0				* string bit flag into X bit
               S01:00E00E06:  D0 00
F00:2762       	ADDX.b	d1,d1				* shift compare function flag
               S01:00E00E08:  D3 01
F00:2763       
F00:2764       	MOVE.b	#0,Dtypef(a3)		* clear data type flag, $00=float
               S01:00E00E0A:  17 7C 00 00 05 B5
F00:2765       	MOVE.b	d1,comp_f(a3)		* save new compare function flag
               S01:00E00E10:  17 41 05 E3
F00:2766       	SUBQ.w	#1,a5				* decrement BASIC execute pointer
               S01:00E00E14:  53 4D
F00:2767       	MOVEQ		#(TK_LT-TK_PLUS)*4,d1	* set offset to last operator entry
               S01:00E00E16:  72 30
F00:2768       	BRA.s		LAB_1B13			* branch always
               S01:00E00E18:  60 C0
F00:2769       
F00:2770       LAB_1B3C
F00:2771       	LEA		LAB_OPPT(pc),a0		* point to function vector table
               S01:00E00E1A:  41 FA 24 2A
F00:2772       	CMP.w		(a0,d1.w),d0		* compare with this opperator precedence
               S01:00E00E1E:  B0 70 10 00
F00:2773       	BCC.s		LAB_1B86			* branch if d0 >=, pop FAC2 & return
               S01:00E00E22:  64 16
F00:2774       
F00:2775       	BRA.s		LAB_1B1C			* branch always
               S01:00E00E24:  60 C4
F00:2776       
F00:2777       * do functions
F00:2778       
F00:2779       LAB_1B78
F00:2780       	MOVEQ		#-1,d1			* flag all done
               S01:00E00E26:  72 FF
F00:2781       	MOVE.w	(sp)+,d0			* pull precedence word
               S01:00E00E28:  30 1F
F00:2782       LAB_1B7B
F00:2783       	BEQ.s		LAB_1B9D			* exit if done
               S01:00E00E2A:  67 32
F00:2784       
F00:2785       LAB_1B7D
F00:2786       	CMP.w		#$64,d0			* compare previous precedence with $64
               S01:00E00E2C:  B0 7C 00 64
F00:2787       	BEQ.s		LAB_1B84			* branch if was $64 (< function can be string)
               S01:00E00E30:  67 04
F00:2788       
F00:2789       	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
               S01:00E00E32:  61 00 FF 0C
F00:2790       LAB_1B84
F00:2791       	MOVE.l	d1,prstk(a3)		* save current operator index
               S01:00E00E36:  27 41 05 D8
F00:2792       
F00:2793       							* pop FAC2 & return
F00:2794       LAB_1B86
F00:2795       	MOVE.b	(sp)+,d0			* pop comparison evaluation flag
               S01:00E00E3A:  10 1F
F00:2796       	MOVE.b	d0,d1				* copy comparison evaluation flag
               S01:00E00E3C:  12 00
F00:2797       	LSR.b		#1,d0				* shift out comparison evaluation lowest bit
               S01:00E00E3E:  E2 08
F00:2798       	MOVE.b	d0,Cflag(a3)		* save comparison evaluation flag
               S01:00E00E40:  17 40 05 E1
F00:2799       	MOVE.w	(sp)+,FAC2_e(a3)		* pop exponent and sign
               S01:00E00E44:  37 5F 05 9C
F00:2800       	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
               S01:00E00E48:  27 5F 05 98
F00:2801       	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign
               S01:00E00E4C:  17 6B 05 9D 05 9E
F00:2802       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
               S01:00E00E52:  10 2B 05 95
F00:2803       	EOR.b		d0,FAC_sc(a3)		* EOR FAC1 sign and set sign compare
               S01:00E00E56:  B1 2B 05 9E
F00:2804       
F00:2805       	LSR.b		#1,d1				* type bit into X and C
               S01:00E00E5A:  E2 09
F00:2806       	RTS
               S01:00E00E5C:  4E 75
F00:2807       
F00:2808       LAB_1B9D
F00:2809       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E00E5E:  10 2B 05 94
F00:2810       	RTS
               S01:00E00E62:  4E 75
F00:2811       
F00:2812       
F00:2813       *************************************************************************************
F00:2814       *
F00:2815       * get a value from the BASIC line
F00:2816       
F00:2817       LAB_GVAL
F00:2818       	BSR.s		LAB_IGBY			* increment & scan memory
               S01:00E00E64:  61 50
F00:2819       	BCS		LAB_2887			* if numeric get FAC1 from string & return
               S01:00E00E66:  65 00 1D 44
F00:2820       
F00:2821       	TST.b		d0				* test byte
               S01:00E00E6A:  4A 00
F00:2822       	BMI		LAB_1BD0			* if -ve go test token values
               S01:00E00E6C:  6B 00 00 8C
F00:2823       
F00:2824       							* else it is either a string, number, variable
F00:2825       							* or (<expr>)
F00:2826       	CMP.b		#'$',d0			* compare with "$"
               S01:00E00E70:  B0 3C 00 24
F00:2827       	BEQ		LAB_2887			* if "$" get hex number from string & return
               S01:00E00E74:  67 00 1D 36
F00:2828       
F00:2829       	CMP.b		#'%',d0			* else compare with "%"
               S01:00E00E78:  B0 3C 00 25
F00:2830       	BEQ		LAB_2887			* if "%" get binary number from string & return
               S01:00E00E7C:  67 00 1D 2E
F00:2831       
F00:2832       	CMP.b		#$2E,d0			* compare with "."
               S01:00E00E80:  B0 3C 00 2E
F00:2833       	BEQ		LAB_2887			* if so get FAC1 from string and return
               S01:00E00E84:  67 00 1D 26
F00:2834       							* (e.g. .123)
F00:2835       
F00:2836       							* wasn't a number so ...
F00:2837       	CMP.b		#$22,d0			* compare with "
               S01:00E00E88:  B0 3C 00 22
F00:2838       	BNE.s		LAB_1BF3			* if not open quote then it must be a variable
               S01:00E00E8C:  66 0C
F00:2839       							* or an open bracket
F00:2840       
F00:2841       							* was open quote so get the enclosed string
F00:2842       
F00:2843       * print "..." string to string stack
F00:2844       
F00:2845       LAB_1BC1
F00:2846       	MOVE.b	(a5)+,d0			* increment BASIC execute pointer (past ")
               S01:00E00E8E:  10 1D
F00:2847       							* fastest/shortest method
F00:2848       	MOVEA.l	a5,a0				* copy BASIC execute pointer (string start)
               S01:00E00E90:  20 4D
F00:2849       	BSR		LAB_20AE			* print " terminated string to stack
               S01:00E00E92:  61 00 06 3E
F00:2850       	MOVEA.l	a2,a5				* restore BASIC execute pointer from temp
               S01:00E00E96:  2A 4A
F00:2851       	RTS
               S01:00E00E98:  4E 75
F00:2852       
F00:2853       * get value from line .. continued
F00:2854       							* wasn't any sort of number so ...
F00:2855       LAB_1BF3
F00:2856       	CMP.b		#'(',d0			* compare with "("
               S01:00E00E9A:  B0 3C 00 28
F00:2857       	BNE.s		LAB_1C18			* if not "(" get (var) and return value in FAC1
               S01:00E00E9E:  66 40
F00:2858       							* and $ flag
F00:2859       
F00:2860       
F00:2861       *************************************************************************************
F00:2862       *
F00:2863       * evaluate expression within parentheses
F00:2864       
F00:2865       LAB_1BF7
F00:2866       	BSR		LAB_EVEZ			* evaluate expression (no decrement)
               S01:00E00EA0:  61 00 FE B6
F00:2867       
F00:2868       
F00:2869       *************************************************************************************
F00:2870       *
F00:2871       * all the 'scan for' routines return the character after the sought character
F00:2872       
F00:2873       * scan for ")", else do syntax error, then warm start
F00:2874       
F00:2875       LAB_1BFB
F00:2876       	MOVEQ		#$29,d0			* load d0 with ")"
               S01:00E00EA4:  70 29
F00:2877       	BRA.s		LAB_SCCA
               S01:00E00EA6:  60 06
F00:2878       
F00:2879       
F00:2880       *************************************************************************************
F00:2881       *
F00:2882       * scan for "," and get byte, else do Syntax error then warm start
F00:2883       
F00:2884       LAB_SCGB
F00:2885       	PEA		LAB_GTBY(pc)		* return address is to get byte parameter
               S01:00E00EA8:  48 7A 09 74
F00:2886       
F00:2887       
F00:2888       *************************************************************************************
F00:2889       *
F00:2890       * scan for ",", else do syntax error, then warm start
F00:2891       
F00:2892       LAB_1C01
F00:2893       	MOVEQ		#$2C,d0			* load d0 with ","
               S01:00E00EAC:  70 2C
F00:2894       
F00:2895       
F00:2896       *************************************************************************************
F00:2897       *
F00:2898       * scan for CHR$(d0) , else do syntax error, then warm start
F00:2899       
F00:2900       LAB_SCCA
F00:2901       	CMP.b		(a5)+,d0			* check next byte is = d0
               S01:00E00EAE:  B0 1D
F00:2902       	BEQ.s		LAB_GBYT			* if so go get next
               S01:00E00EB0:  67 06
F00:2903       
F00:2904       	BRA		LAB_SNER			* else do syntax error/warm start
               S01:00E00EB2:  60 00 F3 C6
F00:2905       
F00:2906       
F00:2907       *************************************************************************************
F00:2908       *
F00:2909       * BASIC increment and scan memory routine
F00:2910       
F00:2911       LAB_IGBY
F00:2912       	MOVE.b	(a5)+,d0			* get byte & increment pointer
               S01:00E00EB6:  10 1D
F00:2913       
F00:2914       * scan memory routine, exit with Cb = 1 if numeric character
F00:2915       * also skips any spaces encountered
F00:2916       
F00:2917       LAB_GBYT
F00:2918       	MOVE.b	(a5),d0			* get byte
               S01:00E00EB8:  10 15
F00:2919       
F00:2920       	CMP.b		#$20,d0			* compare with " "
               S01:00E00EBA:  B0 3C 00 20
F00:2921       	BEQ.s		LAB_IGBY			* if " " go do next
               S01:00E00EBE:  67 F6
F00:2922       
F00:2923       * test current BASIC byte, exit with Cb = 1 if numeric character
F00:2924       
F00:2925       	CMP.b		#TK_ELSE,d0			* compare with the token for ELSE
               S01:00E00EC0:  B0 3C 00 B6
F00:2926       	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
               S01:00E00EC4:  64 0C
F00:2927       
F00:2928       	CMP.b		#$3A,d0			* compare with ":"
               S01:00E00EC6:  B0 3C 00 3A
F00:2929       	BCC.s		RTS_001			* exit if >= (not numeric, carry clear)
               S01:00E00ECA:  64 06
F00:2930       
F00:2931       	MOVEQ		#$D0,d6			* set -"0"
               S01:00E00ECC:  7C D0
F00:2932       	ADD.b		d6,d0				* add -"0"
               S01:00E00ECE:  D0 06
F00:2933       	SUB.b		d6,d0				* subtract -"0"
               S01:00E00ED0:  90 06
F00:2934       RTS_001						* carry set if byte = "0"-"9"
F00:2935       	RTS
               S01:00E00ED2:  4E 75
F00:2936       
F00:2937       
F00:2938       *************************************************************************************
F00:2939       *
F00:2940       * set-up for - operator
F00:2941       
F00:2942       LAB_1C11
F00:2943       	BSR		LAB_CTNM			* check if source is numeric, else type mismatch
               S01:00E00ED4:  61 00 FE 6A
F00:2944       	MOVEQ	#(TK_GT-TK_PLUS)*4,d1		* set offset from base to - operator
               S01:00E00ED8:  72 28
F00:2945       LAB_1C13
F00:2946       	LEA		4(sp),sp			* dump GVAL return address
               S01:00E00EDA:  58 8F
F00:2947       	BRA		LAB_1B1D			* continue evaluating expression
               S01:00E00EDC:  60 00 FF 0E
F00:2948       
F00:2949       
F00:2950       *************************************************************************************
F00:2951       *
F00:2952       * variable name set-up
F00:2953       * get (var), return value in FAC_1 & data type flag
F00:2954       
F00:2955       LAB_1C18
F00:2956       	BSR		LAB_GVAR			* get variable address in a0
               S01:00E00EE0:  61 00 01 EA
F00:2957       
F00:2958       * if you want a non existant variable to return a null value then set the novar
F00:2959       * value at the top of this file to some non zero value
F00:2960       
F00:2961        ifne	novar
F00:2962       
F00:2963       	BNE.s		LAB_1C19			* if it exists return it
F00:2964       
F00:2965       	LEA.l		LAB_1D96(pc),a0		* else return a null descriptor/pointer
F00:2966       
F00:2967        endc
F00:2968       
F00:2969       * return existing variable value
F00:2970       
F00:2971       LAB_1C19
F00:2972       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E00EE4:  4A 2B 05 B5
F00:2973       							* $00=float
F00:2974       	BEQ		LAB_UFAC			* if float unpack memory (a0) into FAC1 and
               S01:00E00EE8:  67 00 0F A0
F00:2975       							* return
F00:2976       
F00:2977       	BPL.s		LAB_1C1A			* if integer unpack memory (a0) into FAC1
               S01:00E00EEC:  6A 06
F00:2978       							* and return
F00:2979       
F00:2980       	MOVE.l	a0,FAC1_m(a3)		* else save descriptor pointer in FAC1
               S01:00E00EEE:  27 48 05 90
F00:2981       	RTS
               S01:00E00EF2:  4E 75
F00:2982       
F00:2983       LAB_1C1A
F00:2984       	MOVE.l	(a0),d0			* get integer value
               S01:00E00EF4:  20 10
F00:2985       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E00EF6:  60 00 04 C4
F00:2986       
F00:2987       
F00:2988       *************************************************************************************
F00:2989       *
F00:2990       * get value from line .. continued
F00:2991       * do tokens
F00:2992       
F00:2993       LAB_1BD0
F00:2994       	CMP.b		#TK_MINUS,d0		* compare with token for -
               S01:00E00EFA:  B0 3C 00 C0
F00:2995       	BEQ.s		LAB_1C11			* branch if - token (do set-up for - operator)
               S01:00E00EFE:  67 D4
F00:2996       
F00:2997       							* wasn't -123 so ...
F00:2998       	CMP.b		#TK_PLUS,d0			* compare with token for +
               S01:00E00F00:  B0 3C 00 BF
F00:2999       	BEQ		LAB_GVAL			* branch if + token (+n = n so ignore leading +)
               S01:00E00F04:  67 00 FF 5E
F00:3000       
F00:3001       	CMP.b		#TK_NOT,d0			* compare with token for NOT
               S01:00E00F08:  B0 3C 00 BB
F00:3002       	BNE.s		LAB_1BE7			* branch if not token for NOT
               S01:00E00F0C:  66 06
F00:3003       
F00:3004       							* was NOT token
F00:3005       	MOVE.w	#(TK_EQUAL-TK_PLUS)*4,d1	* offset to NOT function
               S01:00E00F0E:  32 3C 00 2C
F00:3006       	BRA.s		LAB_1C13			* do set-up for function then execute
               S01:00E00F12:  60 C6
F00:3007       
F00:3008       							* wasn't +, - or NOT so ...
F00:3009       LAB_1BE7
F00:3010       	CMP.b		#TK_FN,d0			* compare with token for FN
               S01:00E00F14:  B0 3C 00 B8
F00:3011       	BEQ		LAB_201E			* if FN go evaluate FNx
               S01:00E00F18:  67 00 05 1C
F00:3012       
F00:3013       	CMP.b		#TK_POINT,d0		* compare with token for POINT
               S01:00E00F1C:  B0 3C 00 A6
F00:3014       	BEQ		LAB_FPOINT			* if POINT go evaluate POINT(x,y)
               S01:00E00F20:  67 00 0A A0
F00:3015       
F00:3016       							* wasn't +, -, NOT or FN so ...
F00:3017       	SUB.b		#TK_SGN,d0			* compare with token for SGN & normalise
               S01:00E00F24:  90 3C 00 CC
F00:3018       	BCS		LAB_SNER			* if < SGN token then do syntax error
               S01:00E00F28:  65 00 F3 50
F00:3019       
F00:3020       * get value from line .. continued
F00:3021       * only functions left so set up function references
F00:3022       
F00:3023       * new for V2.0+ this replaces a lot of IF .. THEN .. ELSEIF .. THEN .. that was needed
F00:3024       * to process function calls. now the function vector is computed and pushed on the stack
F00:3025       * and the preprocess offset is read. if the preprocess offset is non zero then the vector
F00:3026       * is calculated and the routine called, if not this routine just does RTS. whichever
F00:3027       * happens the RTS at the end of this routine, or the preprocess routine calls, the
F00:3028       * function code
F00:3029       
F00:3030       * this also removes some less than elegant code that was used to bypass type checking
F00:3031       * for functions that returned strings
F00:3032       
F00:3033       	AND.w		#$7F,d0			* mask byte
               S01:00E00F2C:  C0 7C 00 7F
F00:3034       	ADD.w		d0,d0				* *2 (2 bytes per function offset)
               S01:00E00F30:  D0 40
F00:3035       
F00:3036       	LEA		LAB_FTBL(pc),a0		* pointer to functions vector table
               S01:00E00F32:  41 FA 22 C2
F00:3037       	MOVE.w	(a0,d0.w),d1		* get function vector offset
               S01:00E00F36:  32 30 00 00
F00:3038       	PEA		(a0,d1.w)			* push function vector
               S01:00E00F3A:  48 70 10 00
F00:3039       
F00:3040       	LEA		LAB_FTPP(pc),a0		* pointer to functions preprocess vector table
               S01:00E00F3E:  41 FA 22 66
F00:3041       	MOVE.w	(a0,d0.w),d0		* get function preprocess vector offset
               S01:00E00F42:  30 30 00 00
F00:3042       	BEQ.s		LAB_1C2A			* no preprocess vector so go do function
               S01:00E00F46:  67 12
F00:3043       
F00:3044       	LEA		(a0,d0.w),a0		* get function preprocess vector
               S01:00E00F48:  41 F0 00 00
F00:3045       	JMP		(a0)				* go do preprocess routine then function
               S01:00E00F4C:  4E D0
F00:3046       
F00:3047       
F00:3048       *************************************************************************************
F00:3049       *
F00:3050       * process string expression in parenthesis
F00:3051       
F00:3052       LAB_PPFS
F00:3053       	BSR		LAB_1BF7			* process expression in parenthesis
               S01:00E00F4E:  61 00 FF 50
F00:3054       	TST.b		Dtypef(a3)			* test data type
               S01:00E00F52:  4A 2B 05 B5
F00:3055       	BPL		LAB_TMER			* if numeric do Type missmatch Error/warm start
               S01:00E00F56:  6A 00 F2 F6
F00:3056       
F00:3057       LAB_1C2A
F00:3058       	RTS						* else do function
               S01:00E00F5A:  4E 75
F00:3059       
F00:3060       
F00:3061       *************************************************************************************
F00:3062       *
F00:3063       * process numeric expression in parenthesis
F00:3064       
F00:3065       LAB_PPFN
F00:3066       	BSR		LAB_1BF7			* process expression in parenthesis
               S01:00E00F5C:  61 00 FF 42
F00:3067       	TST.b		Dtypef(a3)			* test data type
               S01:00E00F60:  4A 2B 05 B5
F00:3068       	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
               S01:00E00F64:  6B 00 F2 E8
F00:3069       
F00:3070       	RTS						* else do function
               S01:00E00F68:  4E 75
F00:3071       
F00:3072       
F00:3073       *************************************************************************************
F00:3074       *
F00:3075       * set numeric data type and increment BASIC execute pointer
F00:3076       
F00:3077       LAB_PPBI
F00:3078       	MOVE.b	#$00,Dtypef(a3)		* clear data type flag, $00=float
               S01:00E00F6A:  17 7C 00 00 05 B5
F00:3079       	MOVE.b	(a5)+,d0			* get next BASIC byte
               S01:00E00F70:  10 1D
F00:3080       	RTS						* do function
               S01:00E00F72:  4E 75
F00:3081       
F00:3082       
F00:3083       *************************************************************************************
F00:3084       *
F00:3085       * process string for LEFT$, RIGHT$ or MID$
F00:3086       
F00:3087       LAB_LRMS
F00:3088       	BSR		LAB_EVEZ			* evaluate (should be string) expression
               S01:00E00F74:  61 00 FD E2
F00:3089       	TST.b		Dtypef(a3)			* test data type flag
               S01:00E00F78:  4A 2B 05 B5
F00:3090       	BPL		LAB_TMER			* if type is not string do type mismatch error
               S01:00E00F7C:  6A 00 F2 D0
F00:3091       
F00:3092       	MOVE.b	(a5)+,d2			* get BASIC byte
               S01:00E00F80:  14 1D
F00:3093       	CMP.b		#',',d2			* compare with comma
               S01:00E00F82:  B4 3C 00 2C
F00:3094       	BNE		LAB_SNER			* if not "," go do syntax Error/warm start
               S01:00E00F86:  66 00 F2 F2
F00:3095       
F00:3096       	MOVE.l	FAC1_m(a3),-(sp)		* save descriptor pointer
               S01:00E00F8A:  2F 2B 05 90
F00:3097       	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
               S01:00E00F8E:  61 00 08 A2
F00:3098       	MOVEA.l	(sp)+,a0			* restore descriptor pointer
               S01:00E00F92:  20 5F
F00:3099       	RTS						* do function
               S01:00E00F94:  4E 75
F00:3100       
F00:3101       
F00:3102       *************************************************************************************
F00:3103       *
F00:3104       * process numeric expression(s) for BIN$ or HEX$
F00:3105       
F00:3106       LAB_BHSS
F00:3107       	BSR		LAB_EVEZ			* evaluate expression (no decrement)
               S01:00E00F96:  61 00 FD C0
F00:3108       	TST.b		Dtypef(a3)			* test data type
               S01:00E00F9A:  4A 2B 05 B5
F00:3109       	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
               S01:00E00F9E:  6B 00 F2 AE
F00:3110       
F00:3111       	BSR		LAB_2831			* convert FAC1 floating to fixed
               S01:00E00FA2:  61 00 0F D8
F00:3112       							* result in d0 and Itemp
F00:3113       	MOVEQ		#0,d1				* set default to no leading "0"s
               S01:00E00FA6:  72 00
F00:3114       	MOVE.b	(a5)+,d2			* get BASIC byte
               S01:00E00FA8:  14 1D
F00:3115       	CMP.b		#',',d2			* compare with comma
               S01:00E00FAA:  B4 3C 00 2C
F00:3116       	BNE.s		LAB_BHCB			* if not "," go check close bracket
               S01:00E00FAE:  66 0C
F00:3117       
F00:3118       	MOVE.l	d0,-(sp)			* copy number to stack
               S01:00E00FB0:  2F 00
F00:3119       	BSR		LAB_GTBY			* get byte value
               S01:00E00FB2:  61 00 08 6A
F00:3120       	MOVE.l	d0,d1				* copy leading 0s #
               S01:00E00FB6:  22 00
F00:3121       	MOVE.l	(sp)+,d0			* restore number from stack
               S01:00E00FB8:  20 1F
F00:3122       	MOVE.b	(a5)+,d2			* get BASIC byte
               S01:00E00FBA:  14 1D
F00:3123       LAB_BHCB
F00:3124       	CMP.b		#')',d2			* compare with close bracket
               S01:00E00FBC:  B4 3C 00 29
F00:3125       	BNE		LAB_SNER			* if not ")" do Syntax Error/warm start
               S01:00E00FC0:  66 00 F2 B8
F00:3126       
F00:3127       	RTS						* go do function
               S01:00E00FC4:  4E 75
F00:3128       
F00:3129       
F00:3130       *************************************************************************************
F00:3131       *
F00:3132       * perform EOR
F00:3133       
F00:3134       LAB_EOR
F00:3135       	BSR.s		GetFirst			* get two values for OR, AND or EOR
               S01:00E00FC6:  61 16
F00:3136       							* first in d0, and Itemp, second in d2
F00:3137       	EOR.l		d2,d0				* EOR values
               S01:00E00FC8:  B5 80
F00:3138       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E00FCA:  60 00 03 F0
F00:3139       
F00:3140       
F00:3141       *************************************************************************************
F00:3142       *
F00:3143       * perform OR
F00:3144       
F00:3145       LAB_OR
F00:3146       	BSR.s		GetFirst			* get two values for OR, AND or EOR
               S01:00E00FCE:  61 0E
F00:3147       							* first in d0, and Itemp, second in d2
F00:3148       	OR.l		d2,d0				* do OR
               S01:00E00FD0:  80 82
F00:3149       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E00FD2:  60 00 03 E8
F00:3150       
F00:3151       
F00:3152       *************************************************************************************
F00:3153       *
F00:3154       * perform AND
F00:3155       
F00:3156       LAB_AND
F00:3157       	BSR.s		GetFirst			* get two values for OR, AND or EOR
               S01:00E00FD6:  61 06
F00:3158       							* first in d0, and Itemp, second in d2
F00:3159       	AND.l		d2,d0				* do AND
               S01:00E00FD8:  C0 82
F00:3160       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E00FDA:  60 00 03 E0
F00:3161       
F00:3162       
F00:3163       *************************************************************************************
F00:3164       *
F00:3165       * get two values for OR, AND, EOR
F00:3166       * first in d0, second in d2
F00:3167       
F00:3168       GetFirst
F00:3169       	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
               S01:00E00FDE:  61 00 02 28
F00:3170       							* result in d0 and Itemp
F00:3171       	MOVE.l	d0,d2				* copy second value
               S01:00E00FE2:  24 00
F00:3172       	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
               S01:00E00FE4:  61 00 0E FE
F00:3173       							* expression
F00:3174       	BRA		LAB_EVIR			* evaluate integer expression (no sign check)
               S01:00E00FE8:  60 00 02 1E
F00:3175       							* result in d0 and Itemp & return
F00:3176       
F00:3177       
F00:3178       *************************************************************************************
F00:3179       *
F00:3180       * perform NOT
F00:3181       
F00:3182       LAB_EQUAL
F00:3183       	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
               S01:00E00FEC:  61 00 02 1A
F00:3184       							* result in d0 and Itemp
F00:3185       	NOT.l		d0				* bitwise invert
               S01:00E00FF0:  46 80
F00:3186       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E00FF2:  60 00 03 C8
F00:3187       
F00:3188       
F00:3189       *************************************************************************************
F00:3190       *
F00:3191       * perform comparisons
F00:3192       * do < compare
F00:3193       
F00:3194       LAB_LTHAN
F00:3195       	BSR		LAB_CKTM			* type match check, set C for string
               S01:00E00FF6:  61 00 FD 4A
F00:3196       	BCS.s		LAB_1CAE			* branch if string
               S01:00E00FFA:  65 06
F00:3197       
F00:3198       							* do numeric < compare
F00:3199       	BSR		LAB_27FA			* compare FAC1 with FAC2
               S01:00E00FFC:  61 00 0F 52
F00:3200       							* returns d0=+1 if FAC1 > FAC2
F00:3201       							* returns d0= 0 if FAC1 = FAC2
F00:3202       							* returns d0=-1 if FAC1 < FAC2
F00:3203       	BRA.s		LAB_1CF2			* process result
               S01:00E01000:  60 42
F00:3204       
F00:3205       							* do string < compare
F00:3206       LAB_1CAE
F00:3207       	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
               S01:00E01002:  17 7C 00 00 05 B5
F00:3208       							* $00=float
F00:3209       	BSR		LAB_22B6			* pop string off descriptor stack, or from top
               S01:00E01008:  61 00 06 B4
F00:3210       							* of string space returns d0 = length,
F00:3211       							* a0 = pointer
F00:3212       	MOVEA.l	a0,a1				* copy string 2 pointer
               S01:00E0100C:  22 48
F00:3213       	MOVE.l	d0,d1				* copy string 2 length
               S01:00E0100E:  22 00
F00:3214       	MOVEA.l	FAC2_m(a3),a0		* get string 1 descriptor pointer
               S01:00E01010:  20 6B 05 98
F00:3215       	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E01014:  61 00 06 AC
F00:3216       							* d0 = length, a0 = pointer
F00:3217       	MOVE.l	d0,d2				* copy length
               S01:00E01018:  24 00
F00:3218       	BNE.s		LAB_1CB5			* branch if not null string
               S01:00E0101A:  66 04
F00:3219       
F00:3220       	TST.l		d1				* test if string 2 is null also
               S01:00E0101C:  4A 81
F00:3221       	BEQ.s		LAB_1CF2			* if so do string 1 = string 2
               S01:00E0101E:  67 24
F00:3222       
F00:3223       LAB_1CB5
F00:3224       	SUB.l		d1,d2				* subtract string 2 length
               S01:00E01020:  94 81
F00:3225       	BEQ.s		LAB_1CD5			* branch if strings = length
               S01:00E01022:  67 0C
F00:3226       
F00:3227       	BCS.s		LAB_1CD4			* branch if string 1 < string 2
               S01:00E01024:  65 04
F00:3228       
F00:3229       	MOVEQ		#-1,d0			* set for string 1 > string 2
               S01:00E01026:  70 FF
F00:3230       	BRA.s		LAB_1CD6			* go do character comapare
               S01:00E01028:  60 08
F00:3231       
F00:3232       LAB_1CD4
F00:3233       	MOVE.l	d0,d1				* string 1 length is compare length
               S01:00E0102A:  22 00
F00:3234       	MOVEQ		#1,d0				* and set for string 1 < string 2
               S01:00E0102C:  70 01
F00:3235       	BRA.s		LAB_1CD6			* go do character comapare
               S01:00E0102E:  60 02
F00:3236       
F00:3237       LAB_1CD5
F00:3238       	MOVE.l	d2,d0				* set for string 1 = string 2
               S01:00E01030:  20 02
F00:3239       LAB_1CD6
F00:3240       	SUBQ.l	#1,d1				* adjust length for DBcc loop
               S01:00E01032:  53 81
F00:3241       
F00:3242       							* d1 is length to compare, d0 is <=> for length
F00:3243       							* a0 is string 1 pointer, a1 is string 2 pointer
F00:3244       LAB_1CE6
F00:3245       	CMPM.b	(a0)+,(a1)+			* compare string bytes (1 with 2)
               S01:00E01034:  B3 08
F00:3246       	DBNE		d1,LAB_1CE6			* loop if same and not end yet
               S01:00E01036:  56 C9 FF FC
F00:3247       
F00:3248       	BEQ.s		LAB_1CF2			* if = to here, then go use length compare
               S01:00E0103A:  67 08
F00:3249       
F00:3250       	BCC.s		LAB_1CDB			* else branch if string 1 > string 2
               S01:00E0103C:  64 04
F00:3251       
F00:3252       	MOVEQ		#-1,d0			* else set for string 1 < string 2
               S01:00E0103E:  70 FF
F00:3253       	BRA.s		LAB_1CF2			* go set result
               S01:00E01040:  60 02
F00:3254       
F00:3255       LAB_1CDB
F00:3256       	MOVEQ		#1,d0				* and set for string 1 > string 2
               S01:00E01042:  70 01
F00:3257       
F00:3258       LAB_1CF2
F00:3259       	ADDQ.b	#1,d0				* make result 0, 1 or 2
               S01:00E01044:  52 00
F00:3260       	MOVE.b	d0,d1				* copy to d1
               S01:00E01046:  12 00
F00:3261       	MOVEQ		#1,d0				* set d0 longword
               S01:00E01048:  70 01
F00:3262       	ROL.b		d1,d0				* make 1, 2 or 4 (result = flag bit)
               S01:00E0104A:  E3 38
F00:3263       	AND.b		Cflag(a3),d0		* AND with comparison evaluation flag
               S01:00E0104C:  C0 2B 05 E1
F00:3264       	BEQ		LAB_27DB			* exit if not a wanted result (i.e. false)
               S01:00E01050:  67 00 0E E6
F00:3265       
F00:3266       	MOVEQ		#-1,d0			* else set -1 (true)
               S01:00E01054:  70 FF
F00:3267       	BRA		LAB_27DB			* save d0 as integer & return
               S01:00E01056:  60 00 0E E0
F00:3268       
F00:3269       
F00:3270       LAB_1CFE
F00:3271       	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
               S01:00E0105A:  61 00 FE 50
F00:3272       
F00:3273       
F00:3274       *************************************************************************************
F00:3275       *
F00:3276       * perform DIM
F00:3277       
F00:3278       LAB_DIM
F00:3279       	MOVEQ		#-1,d1			* set "DIM" flag
               S01:00E0105E:  72 FF
F00:3280       	BSR.s		LAB_1D10			* search for variable
               S01:00E01060:  61 70
F00:3281       	BSR		LAB_GBYT			* scan memory
               S01:00E01062:  61 00 FE 54
F00:3282       	BNE.s		LAB_1CFE			* loop and scan for "," if not null
               S01:00E01066:  66 F2
F00:3283       
F00:3284       	RTS
               S01:00E01068:  4E 75
F00:3285       
F00:3286       
F00:3287       *************************************************************************************
F00:3288       *
F00:3289       * perform << (left shift)
F00:3290       
F00:3291       LAB_LSHIFT
F00:3292       	BSR.s		GetPair			* get an integer and byte pair
               S01:00E0106A:  61 2E
F00:3293       							* byte is in d2, integer is in d0 and Itemp
F00:3294       	BEQ.s		NoShift			* branch if byte zero
               S01:00E0106C:  67 08
F00:3295       
F00:3296       	CMP.b		#$20,d2			* compare bit count with 32d
               S01:00E0106E:  B4 3C 00 20
F00:3297       	BCC.s		TooBig			* branch if >=
               S01:00E01072:  64 20
F00:3298       
F00:3299       	ASL.l		d2,d0				* shift longword
               S01:00E01074:  E5 A0
F00:3300       NoShift
F00:3301       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E01076:  60 00 03 44
F00:3302       
F00:3303       
F00:3304       *************************************************************************************
F00:3305       *
F00:3306       * perform >> (right shift)
F00:3307       
F00:3308       LAB_RSHIFT
F00:3309       	BSR.s		GetPair			* get an integer and byte pair
               S01:00E0107A:  61 1E
F00:3310       							* byte is in d2, integer is in d0 and Itemp
F00:3311       	BEQ.s		NoShift			* branch if byte zero
               S01:00E0107C:  67 F8
F00:3312       
F00:3313       	CMP.b		#$20,d2			* compare bit count with 32d
               S01:00E0107E:  B4 3C 00 20
F00:3314       	BCS.s		Not2Big			* branch if >= (return shift)
               S01:00E01082:  65 0A
F00:3315       
F00:3316       	TST.l		d0				* test sign bit
               S01:00E01084:  4A 80
F00:3317       	BPL.s		TooBig			* branch if +ve
               S01:00E01086:  6A 0C
F00:3318       
F00:3319       	MOVEQ		#-1,d0			* set longword
               S01:00E01088:  70 FF
F00:3320       	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
               S01:00E0108A:  60 00 03 30
F00:3321       
F00:3322       Not2Big
F00:3323       	ASR.l		d2,d0				* shift longword
               S01:00E0108E:  E4 A0
F00:3324       	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
               S01:00E01090:  60 00 03 2A
F00:3325       
F00:3326       TooBig
F00:3327       	MOVEQ		#0,d0				* clear longword
               S01:00E01094:  70 00
F00:3328       	BRA		LAB_AYFC			* convert d0 to longword in FAC1 & RET
               S01:00E01096:  60 00 03 24
F00:3329       
F00:3330       
F00:3331       *************************************************************************************
F00:3332       *
F00:3333       * get an integer and byte pair
F00:3334       * byte is in d2, integer is in d0 and Itemp
F00:3335       
F00:3336       GetPair
F00:3337       	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
               S01:00E0109A:  61 00 07 86
F00:3338       							* Itemp
F00:3339       	MOVE.b	d0,d2				* save it
               S01:00E0109E:  14 00
F00:3340       	BSR		LAB_279B			* copy FAC2 to FAC1, get first value in
               S01:00E010A0:  61 00 0E 42
F00:3341       							* expression
F00:3342       	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
               S01:00E010A4:  61 00 01 62
F00:3343       							* result in d0 and Itemp
F00:3344       	TST.b		d2				* test byte value
               S01:00E010A8:  4A 02
F00:3345       	RTS
               S01:00E010AA:  4E 75
F00:3346       
F00:3347       
F00:3348       *************************************************************************************
F00:3349       *
F00:3350       * check alpha, return C=0 if<"A" or >"Z" or <"a" to "z">
F00:3351       
F00:3352       LAB_CASC
F00:3353       	CMP.b		#$61,d0			* compare with "a"
               S01:00E010AC:  B0 3C 00 61
F00:3354       	BCC.s		LAB_1D83			* if >="a" go check =<"z"
               S01:00E010B0:  64 10
F00:3355       
F00:3356       
F00:3357       *************************************************************************************
F00:3358       *
F00:3359       * check alpha upper case, return C=0 if<"A" or >"Z"
F00:3360       
F00:3361       LAB_CAUC
F00:3362       	CMP.b		#$41,d0			* compare with "A"
               S01:00E010B2:  B0 3C 00 41
F00:3363       	BCC.s		LAB_1D8A			* if >="A" go check =<"Z"
               S01:00E010B6:  64 04
F00:3364       
F00:3365       	OR		d0,d0				* make C=0
               S01:00E010B8:  80 40
F00:3366       	RTS
               S01:00E010BA:  4E 75
F00:3367       
F00:3368       LAB_1D8A
F00:3369       	CMP.b		#$5B,d0			* compare with "Z"+1
               S01:00E010BC:  B0 3C 00 5B
F00:3370       							* carry set if byte<="Z"
F00:3371       	RTS
               S01:00E010C0:  4E 75
F00:3372       
F00:3373       LAB_1D83
F00:3374       	CMP.b		#$7B,d0			* compare with "z"+1
               S01:00E010C2:  B0 3C 00 7B
F00:3375       							* carry set if byte<="z"
F00:3376       	RTS
               S01:00E010C6:  4E 75
F00:3377       
F00:3378       
F00:3379       *************************************************************************************
F00:3380       *
F00:3381       * search for or create variable. this is used to automatically create a variable if
F00:3382       * it is not found. any routines that need to create the variable call LAB_GVAR via
F00:3383       * this point and error generation is supressed and the variable will be created
F00:3384       *
F00:3385       * return pointer to variable in Cvaral and a0
F00:3386       * set data type to variable type
F00:3387       
F00:3388       LAB_SVAR
F00:3389       	BSR.s		LAB_GVAR			* search for variable
               S01:00E010C8:  61 02
F00:3390       LAB_FVAR
F00:3391       	RTS
               S01:00E010CA:  4E 75
F00:3392       
F00:3393       
F00:3394       *************************************************************************************
F00:3395       *
F00:3396       * search for variable. if this routine is called from anywhere but the above call and
F00:3397       * the variable searched for does not exist then an error will be returned
F00:3398       *
F00:3399       * DIM flag is in d1.b
F00:3400       * return pointer to variable in Cvaral and a0
F00:3401       * set data type to variable type
F00:3402       
F00:3403       LAB_GVAR
F00:3404       	MOVEQ		#$00,d1			* set DIM flag = $00
               S01:00E010CC:  72 00
F00:3405       	BSR		LAB_GBYT			* scan memory (1st character)
               S01:00E010CE:  61 00 FD E8
F00:3406       LAB_1D10
F00:3407       	MOVE.b	d1,Defdim(a3)		* save DIM flag
               S01:00E010D2:  17 41 05 B4
F00:3408       
F00:3409       * search for FN name entry point
F00:3410       
F00:3411       LAB_1D12
F00:3412       	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
               S01:00E010D6:  61 D4
F00:3413       	BCC		LAB_SNER			* if not syntax error, then warm start
               S01:00E010D8:  64 00 F1 A0
F00:3414       
F00:3415       							* is variable name so ...
F00:3416       	MOVEQ		#$0,d1			* set index for name byte
               S01:00E010DC:  72 00
F00:3417       	LEA		Varname(a3),a0		* pointer to variable name
               S01:00E010DE:  41 EB 04 6A
F00:3418       	MOVE.l	d1,(a0)			* clear variable name
               S01:00E010E2:  20 81
F00:3419       	MOVE.b	d1,Dtypef(a3)		* clear data type, $80=string, $40=integer,
               S01:00E010E4:  17 41 05 B5
F00:3420       							* $00=float
F00:3421       
F00:3422       LAB_1D2D
F00:3423       	CMP.w		#$04,d1			* done all significant characters?
               S01:00E010E8:  B2 7C 00 04
F00:3424       	BCC.s		LAB_1D2E			* if so go ignore any more
               S01:00E010EC:  64 06
F00:3425       
F00:3426       	MOVE.b	d0,(a0,d1.w)		* save character
               S01:00E010EE:  11 80 10 00
F00:3427       	ADDQ.w	#1,d1				* increment index
               S01:00E010F2:  52 41
F00:3428       LAB_1D2E
F00:3429       	BSR		LAB_IGBY			* increment & scan memory (next character)
               S01:00E010F4:  61 00 FD C0
F00:3430       	BCS.s		LAB_1D2D			* branch if character = "0"-"9" (ok)
               S01:00E010F8:  65 EE
F00:3431       
F00:3432       							* character wasn't "0" to "9" so ...
F00:3433       	BSR.s		LAB_CASC			* check byte, return C=0 if<"A" or >"Z"
               S01:00E010FA:  61 B0
F00:3434       	BCS.s		LAB_1D2D			* branch if = "A"-"Z" (ok)
               S01:00E010FC:  65 EA
F00:3435       
F00:3436       							* check if string variable
F00:3437       	CMP.b		#'$',d0			* compare with "$"
               S01:00E010FE:  B0 3C 00 24
F00:3438       	BNE.s		LAB_1D44			* branch if not string
               S01:00E01102:  66 0C
F00:3439       
F00:3440       							* type is string
F00:3441       	OR.b		#$80,Varname+1(a3)	* set top bit of 2nd character, indicate string
               S01:00E01104:  00 2B 00 80 04 6B
F00:3442       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0110A:  61 00 FD AA
F00:3443       	BRA.s		LAB_1D45			* skip integer check
               S01:00E0110E:  60 10
F00:3444       
F00:3445       							* check if integer variable
F00:3446       LAB_1D44
F00:3447       	CMP.b		#'&',d0			* compare with "&"
               S01:00E01110:  B0 3C 00 26
F00:3448       	BNE.s		LAB_1D45			* branch if not integer
               S01:00E01114:  66 0A
F00:3449       
F00:3450       							* type is integer
F00:3451       	OR.b		#$80,Varname+2(a3)	* set top bit of 3rd character, indicate integer
               S01:00E01116:  00 2B 00 80 04 6C
F00:3452       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0111C:  61 00 FD 98
F00:3453       
F00:3454       * after we have determined the variable type we need to determine
F00:3455       * if it's an array of type
F00:3456       
F00:3457       							* gets here with character after var name in d0
F00:3458       LAB_1D45
F00:3459       	TST.b		Sufnxf(a3)			* test function name flag
               S01:00E01120:  4A 2B 05 DF
F00:3460       	BEQ.s		LAB_1D48			* branch if not FN or FN variable
               S01:00E01124:  67 0E
F00:3461       
F00:3462       	BPL.s		LAB_1D49			* branch if FN variable
               S01:00E01126:  6A 14
F00:3463       
F00:3464       							* else was FN name
F00:3465       	MOVE.l	Varname(a3),d0		* get whole function name
               S01:00E01128:  20 2B 04 6A
F00:3466       	MOVEQ		#8,d1				* set step to next function size -4
               S01:00E0112C:  72 08
F00:3467       	LEA		Sfncl(a3),a0		* get pointer to start of functions
               S01:00E0112E:  41 EB 04 32
F00:3468       	BRA.s		LAB_1D4B			* go find function
               S01:00E01132:  60 1C
F00:3469       
F00:3470       LAB_1D48
F00:3471       	SUB.b		#'(',d0			* subtract "("
               S01:00E01134:  90 3C 00 28
F00:3472       	BEQ		LAB_1E17			* if "(" go find, or make, array
               S01:00E01138:  67 00 00 F4
F00:3473       
F00:3474       * either find or create var
F00:3475       * var name (1st four characters only!) is in Varname
F00:3476       
F00:3477       							* variable name wasn't var( .. so look for
F00:3478       							* plain variable
F00:3479       LAB_1D49
F00:3480       	MOVE.l	Varname(a3),d0		* get whole variable name
               S01:00E0113C:  20 2B 04 6A
F00:3481       LAB_1D4A
F00:3482       	MOVEQ		#4,d1				* set step to next variable size -4
               S01:00E01140:  72 04
F00:3483       	LEA		Svarl(a3),a0		* get pointer to start of variables
               S01:00E01142:  41 EB 04 36
F00:3484       
F00:3485       	BTST.l	#23,d0			* test if string name
               S01:00E01146:  08 00 00 17
F00:3486       	BEQ.s		LAB_1D4B			* branch if not
               S01:00E0114A:  67 04
F00:3487       
F00:3488       	ADDQ.w	#2,d1				* 6 bytes per string entry
               S01:00E0114C:  54 41
F00:3489       	ADDQ.w	#(Sstrl-Svarl),a0		* move to string area
               S01:00E0114E:  58 48
F00:3490       
F00:3491       LAB_1D4B
F00:3492       	MOVEA.l	4(a0),a1			* get end address
               S01:00E01150:  22 68 00 04
F00:3493       	MOVEA.l	(a0),a0			* get start address
               S01:00E01154:  20 50
F00:3494       	BRA.s		LAB_1D5E			* enter loop at exit check
               S01:00E01156:  60 06
F00:3495       
F00:3496       LAB_1D5D
F00:3497       	CMP.l		(a0)+,d0			* compare this variable with name
               S01:00E01158:  B0 98
F00:3498       	BEQ.s		LAB_1DD7			* branch if match (found var)
               S01:00E0115A:  67 76
F00:3499       
F00:3500       	ADDA.l	d1,a0				* add offset to next variable
               S01:00E0115C:  D1 C1
F00:3501       LAB_1D5E
F00:3502       	CMPA.l	a1,a0				* compare address with variable space end
               S01:00E0115E:  B1 C9
F00:3503       	BNE.s		LAB_1D5D			* if not end go check next
               S01:00E01160:  66 F6
F00:3504       
F00:3505       	TST.b		Sufnxf(a3)			* is it a function or function variable
               S01:00E01162:  4A 2B 05 DF
F00:3506       	BNE.s		LAB_1D94			* if was go do DEF or function variable
               S01:00E01166:  66 0A
F00:3507       
F00:3508       							* reached end of variable mem without match
F00:3509       							* ... so create new variable, possibly
F00:3510       
F00:3511       	LEA		LAB_FVAR(pc),a2		* get the address of the create if doesn't
               S01:00E01168:  45 FA FF 60
F00:3512       							* exist call to LAB_GVAR
F00:3513       	CMPA.l	(sp),a2			* compare the return address with expected
               S01:00E0116C:  B5 D7
F00:3514       	BNE		LAB_UVER			* if not create go do error or return null
               S01:00E0116E:  66 00 F0 C6
F00:3515       
F00:3516       * this will only branch if the call to LAB_GVAR wasn't from LAB_SVAR
F00:3517       
F00:3518       LAB_1D94
F00:3519       	BTST.b	#0,Sufnxf(a3)		* test function search flag
               S01:00E01172:  08 2B 00 00 05 DF
F00:3520       	BNE		LAB_UFER			* if not doing DEF then go do undefined
               S01:00E01178:  66 00 F0 C4
F00:3521       							* function error
F00:3522       
F00:3523       							* else create new variable/function
F00:3524       LAB_1D98
F00:3525       	MOVEA.l	Earryl(a3),a2		* get end of block to move
               S01:00E0117C:  24 6B 04 42
F00:3526       	MOVE.l	a2,d2				* copy end of block to move
               S01:00E01180:  24 0A
F00:3527       	SUB.l		a1,d2				* calculate block to move size
               S01:00E01182:  94 89
F00:3528       
F00:3529       	MOVEA.l	a2,a0				* copy end of block to move
               S01:00E01184:  20 4A
F00:3530       	ADDQ.l	#4,d1				* space for one variable/function + name
               S01:00E01186:  58 81
F00:3531       	ADDA.l	d1,a2				* add space for one variable/function
               S01:00E01188:  D5 C1
F00:3532       	MOVE.l	a2,Earryl(a3)		* set new array mem end
               S01:00E0118A:  27 4A 04 42
F00:3533       	LSR.l		#1,d2				* /2 for word copy
               S01:00E0118E:  E2 8A
F00:3534       	BEQ.s		LAB_1DAF			* skip move if zero length block
               S01:00E01190:  67 12
F00:3535       
F00:3536       	SUBQ.l	#1,d2				* -1 for DFB loop
               S01:00E01192:  53 82
F00:3537       	SWAP		d2				* swap high word to low word
               S01:00E01194:  48 42
F00:3538       LAB_1DAC
F00:3539       	SWAP		d2				* swap high word to low word
               S01:00E01196:  48 42
F00:3540       LAB_1DAE
F00:3541       	MOVE.w	-(a0),-(a2)			* copy word
               S01:00E01198:  35 20
F00:3542       	DBF		d2,LAB_1DAE			* loop until done
               S01:00E0119A:  51 CA FF FC
F00:3543       
F00:3544       	SWAP		d2				* swap high word to low word
               S01:00E0119E:  48 42
F00:3545       	DBF		d2,LAB_1DAC			* decrement high count and loop until done
               S01:00E011A0:  51 CA FF F4
F00:3546       
F00:3547       * get here after creating either a function, variable or string
F00:3548       * if function set variables start, string start, array start
F00:3549       * if variable set string start, array start
F00:3550       * if string set array start
F00:3551       
F00:3552       LAB_1DAF
F00:3553       	TST.b		Sufnxf(a3)			* was it function
               S01:00E011A4:  4A 2B 05 DF
F00:3554       	BMI.s		LAB_1DB0			* branch if was FN
               S01:00E011A8:  6B 08
F00:3555       
F00:3556       	BTST.l	#23,d0			* was it string
               S01:00E011AA:  08 00 00 17
F00:3557       	BNE.s		LAB_1DB2			* branch if string
               S01:00E011AE:  66 0A
F00:3558       
F00:3559       	BRA.s		LAB_1DB1			* branch if was plain variable
               S01:00E011B0:  60 04
F00:3560       
F00:3561       LAB_1DB0
F00:3562       	ADD.l		d1,Svarl(a3)		* set new variable memory start
               S01:00E011B2:  D3 AB 04 36
F00:3563       LAB_1DB1
F00:3564       	ADD.l		d1,Sstrl(a3)		* set new start of strings
               S01:00E011B6:  D3 AB 04 3A
F00:3565       LAB_1DB2
F00:3566       	ADD.l		d1,Sarryl(a3)		* set new array memory start
               S01:00E011BA:  D3 AB 04 3E
F00:3567       	MOVE.l	d0,(a0)+			* save variable/function name
               S01:00E011BE:  20 C0
F00:3568       	MOVE.l	#$00,(a0)			* initialise variable
               S01:00E011C0:  20 BC 00 00 00 00
F00:3569       	BTST.l	#23,d0			* was it string
               S01:00E011C6:  08 00 00 17
F00:3570       	BEQ.s		LAB_1DD7			* branch if not string
               S01:00E011CA:  67 06
F00:3571       
F00:3572       	MOVE.w	#$00,4(a0)			* else initialise string length
               S01:00E011CC:  31 7C 00 00 00 04
F00:3573       
F00:3574       							* found a match for var ((Vrschl) = ptr)
F00:3575       							* found a match for var ((Vrschl) = ptr)
F00:3576       LAB_1DD7
F00:3577       	MOVE.l	d0,d1				* ........ $....... &....... ........
               S01:00E011D2:  22 00
F00:3578       	ADD.l		d1,d1				* .......$ .......& ........ .......0
               S01:00E011D4:  D2 81
F00:3579       	SWAP		d1				* ........ .......0 .......$ .......&
               S01:00E011D6:  48 41
F00:3580       	ROR.b		#1,d1				* ........ .......0 .......$ &.......
               S01:00E011D8:  E2 19
F00:3581       	LSR.w		#1,d1				* ........ .......0 0....... $&.....ï¿½.
               S01:00E011DA:  E2 49
F00:3582       	AND.b		#$C0,d1			* mask the type bits
               S01:00E011DC:  C2 3C 00 C0
F00:3583       	MOVE.b	d1,Dtypef(a3)		* save the data type
               S01:00E011E0:  17 41 05 B5
F00:3584       
F00:3585       	MOVE.b	#$00,Sufnxf(a3)		* clear FN flag byte
               S01:00E011E4:  17 7C 00 00 05 DF
F00:3586       
F00:3587       * if you want a non existant variable to return a null value then set the novar
F00:3588       * value at the top of this file to some non zero value
F00:3589       
F00:3590        ifne	novar
F00:3591       
F00:3592       	MOVEQ		#-1,d0			* return variable found
F00:3593       
F00:3594        endc
F00:3595       
F00:3596       	RTS
               S01:00E011EA:  4E 75
F00:3597       
F00:3598       
F00:3599       *************************************************************************************
F00:3600       *
F00:3601       * set-up array pointer, d0, to first element in array
F00:3602       * set d0 to (a0)+2*(Dimcnt)+$0A
F00:3603       
F00:3604       LAB_1DE6
F00:3605       	MOVEQ		#5,d0				* set d0 to 5 (*2 = 10, later)
               S01:00E011EC:  70 05
F00:3606       	ADD.b		Dimcnt(a3),d0		* add # of dimensions (1, 2 or 3)
               S01:00E011EE:  D0 2B 05 DB
F00:3607       	ADD.l		d0,d0				* *2 (bytes per dimension size)
               S01:00E011F2:  D0 80
F00:3608       	ADD.l		a0,d0				* add array start pointer
               S01:00E011F4:  D0 88
F00:3609       	RTS
               S01:00E011F6:  4E 75
F00:3610       
F00:3611       
F00:3612       *************************************************************************************
F00:3613       *
F00:3614       * evaluate unsigned integer expression
F00:3615       
F00:3616       LAB_EVIN
F00:3617       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E011F8:  61 00 FC BC
F00:3618       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E011FC:  61 00 FB 40
F00:3619       							* else do type mismatch
F00:3620       
F00:3621       
F00:3622       *************************************************************************************
F00:3623       *
F00:3624       * evaluate positive integer expression, result in d0 and Itemp
F00:3625       
F00:3626       LAB_EVPI
F00:3627       	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
               S01:00E01200:  4A 2B 05 95
F00:3628       	BMI		LAB_FCER			* do function call error if -ve
               S01:00E01204:  6B 00 F0 68
F00:3629       
F00:3630       
F00:3631       *************************************************************************************
F00:3632       *
F00:3633       * evaluate integer expression, no sign check
F00:3634       * result in d0 and Itemp, exit with flags set correctly
F00:3635       
F00:3636       LAB_EVIR
F00:3637       	CMPI.b	#$A0,FAC1_e(a3)		* compare exponent with exponent = 2^32 (n>2^31)
               S01:00E01208:  0C 2B 00 A0 05 94
F00:3638       	BCS		LAB_2831			* convert FAC1 floating to fixed
               S01:00E0120E:  65 00 0D 6C
F00:3639       							* result in d0 and Itemp
F00:3640       	BNE		LAB_FCER			* if > do function call error, then warm start
               S01:00E01212:  66 00 F0 5A
F00:3641       
F00:3642       	TST.b		FAC1_s(a3)			* test sign of FAC1
               S01:00E01216:  4A 2B 05 95
F00:3643       	BPL		LAB_2831			* if +ve then ok
               S01:00E0121A:  6A 00 0D 60
F00:3644       
F00:3645       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E0121E:  20 2B 05 90
F00:3646       	NEG.l		d0				* do -d0
               S01:00E01222:  44 80
F00:3647       	BVC		LAB_FCER			* if not $80000000 do FC error, then warm start
               S01:00E01224:  68 00 F0 48
F00:3648       
F00:3649       	MOVE.l	d0,Itemp(a3)		* else just set it
               S01:00E01228:  27 40 04 2A
F00:3650       	RTS
               S01:00E0122C:  4E 75
F00:3651       
F00:3652       
F00:3653       *************************************************************************************
F00:3654       *
F00:3655       * find or make array
F00:3656       
F00:3657       LAB_1E17
F00:3658       	MOVE.w	Defdim(a3),-(sp)		* get DIM flag and data type flag (word in mem)
               S01:00E0122E:  3F 2B 05 B4
F00:3659       	MOVEQ		#0,d1				* clear dimensions count
               S01:00E01232:  72 00
F00:3660       
F00:3661       * now get the array dimension(s) and stack it (them) before the data type and DIM flag
F00:3662       
F00:3663       LAB_1E1F
F00:3664       	MOVE.w	d1,-(sp)			* save dimensions count
               S01:00E01234:  3F 01
F00:3665       	MOVE.l	Varname(a3),-(sp)		* save variable name
               S01:00E01236:  2F 2B 04 6A
F00:3666       	BSR.s		LAB_EVIN			* evaluate integer expression
               S01:00E0123A:  61 BC
F00:3667       
F00:3668       	SWAP		d0				* swap high word to low word
               S01:00E0123C:  48 40
F00:3669       	TST.w		d0				* test swapped high word
               S01:00E0123E:  4A 40
F00:3670       	BNE		LAB_ABER			* if too big do array bounds error
               S01:00E01240:  66 00 F0 1C
F00:3671       
F00:3672       	MOVE.l	(sp)+,Varname(a3)		* restore variable name
               S01:00E01244:  27 5F 04 6A
F00:3673       	MOVE.w	(sp)+,d1			* restore dimensions count
               S01:00E01248:  32 1F
F00:3674       	MOVE.w	(sp)+,d0			* restore DIM and data type flags
               S01:00E0124A:  30 1F
F00:3675       	MOVE.w	Itemp+2(a3),-(sp)		* stack this dimension size
               S01:00E0124C:  3F 2B 04 2C
F00:3676       	MOVE.w	d0,-(sp)			* save DIM and data type flags
               S01:00E01250:  3F 00
F00:3677       	ADDQ.w	#1,d1				* increment dimensions count
               S01:00E01252:  52 41
F00:3678       	BSR		LAB_GBYT			* scan memory
               S01:00E01254:  61 00 FC 62
F00:3679       	CMP.b		#$2C,d0			* compare with ","
               S01:00E01258:  B0 3C 00 2C
F00:3680       	BEQ.s		LAB_1E1F			* if found go do next dimension
               S01:00E0125C:  67 D6
F00:3681       
F00:3682       	MOVE.b	d1,Dimcnt(a3)		* store dimensions count
               S01:00E0125E:  17 41 05 DB
F00:3683       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E01262:  61 00 FC 40
F00:3684       	MOVE.w	(sp)+,Defdim(a3)		* restore DIM and data type flags (word in mem)
               S01:00E01266:  37 5F 05 B4
F00:3685       	MOVEA.l	Sarryl(a3),a0		* get array mem start
               S01:00E0126A:  20 6B 04 3E
F00:3686       
F00:3687       * now check to see if we are at the end of array memory (we would be if there were
F00:3688       * no arrays).
F00:3689       
F00:3690       LAB_1E5C
F00:3691       	MOVE.l	a0,Astrtl(a3)		* save as array start pointer
               S01:00E0126E:  27 48 05 AC
F00:3692       	CMPA.l	Earryl(a3),a0		* compare with array mem end
               S01:00E01272:  B1 EB 04 42
F00:3693       	BEQ.s		LAB_1EA1			* go build array if not found
               S01:00E01276:  67 2E
F00:3694       
F00:3695       							* search for array
F00:3696       	MOVE.l	(a0),d0			* get this array name
               S01:00E01278:  20 10
F00:3697       	CMP.l		Varname(a3),d0		* compare with array name
               S01:00E0127A:  B0 AB 04 6A
F00:3698       	BEQ.s		LAB_1E8D			* array found so branch
               S01:00E0127E:  67 0A
F00:3699       
F00:3700       							* no match
F00:3701       	MOVEA.l	4(a0),a0			* get this array size
               S01:00E01280:  20 68 00 04
F00:3702       	ADDA.l	Astrtl(a3),a0		* add to array start pointer
               S01:00E01284:  D1 EB 05 AC
F00:3703       	BRA.s		LAB_1E5C			* go check next array
               S01:00E01288:  60 E4
F00:3704       
F00:3705       							* found array, are we trying to dimension it?
F00:3706       LAB_1E8D
F00:3707       	TST.b		Defdim(a3)			* are we trying to dimension it?
               S01:00E0128A:  4A 2B 05 B4
F00:3708       	BNE		LAB_DDER			* if so do double dimension error/warm start
               S01:00E0128E:  66 00 EF CA
F00:3709       
F00:3710       * found the array and we're not dimensioning it so we must find an element in it
F00:3711       
F00:3712       	BSR		LAB_1DE6			* set data pointer, d0, to the first element
               S01:00E01292:  61 00 FF 58
F00:3713       							* in the array
F00:3714       	ADDQ.w	#8,a0				* index to dimension count
               S01:00E01296:  50 48
F00:3715       	MOVE.w	(a0)+,d0			* get no of dimensions
               S01:00E01298:  30 18
F00:3716       	CMP.b		Dimcnt(a3),d0		* compare with dimensions count
               S01:00E0129A:  B0 2B 05 DB
F00:3717       	BEQ		LAB_1F28			* found array so go get element
               S01:00E0129E:  67 00 00 94
F00:3718       
F00:3719       	BRA		LAB_WDER			* else wrong so do "Wrong dimensions" error
               S01:00E012A2:  60 00 EF 8A
F00:3720       
F00:3721       							* array not found, so possibly build it
F00:3722       LAB_1EA1
F00:3723       	TST.b		Defdim(a3)			* test the default DIM flag
               S01:00E012A6:  4A 2B 05 B4
F00:3724       	BEQ		LAB_UDER			* if default flag is clear then we are not
               S01:00E012AA:  67 00 EF 86
F00:3725       							* explicitly dimensioning an array so go
F00:3726       							* do an "Undimensioned array" error
F00:3727       
F00:3728       	BSR		LAB_1DE6			* set data pointer, d0, to the first element
               S01:00E012AE:  61 00 FF 3C
F00:3729       							* in the array
F00:3730       	MOVE.l	Varname(a3),d0		* get array name
               S01:00E012B2:  20 2B 04 6A
F00:3731       	MOVE.l	d0,(a0)+			* save array name
               S01:00E012B6:  20 C0
F00:3732       	MOVEQ		#4,d1				* set 4 bytes per element
               S01:00E012B8:  72 04
F00:3733       	BTST.l	#23,d0			* test if string array
               S01:00E012BA:  08 00 00 17
F00:3734       	BEQ.s		LAB_1EDF			* branch if not string
               S01:00E012BE:  67 02
F00:3735       
F00:3736       	MOVEQ		#6,d1				* else 6 bytes per element
               S01:00E012C0:  72 06
F00:3737       LAB_1EDF
F00:3738       	MOVE.l	d1,Asptl(a3)		* set array data size (bytes per element)
               S01:00E012C2:  27 41 05 A8
F00:3739       	MOVE.b	Dimcnt(a3),d1		* get dimensions count
               S01:00E012C6:  12 2B 05 DB
F00:3740       	ADDQ.w	#4,a0				* skip the array size now (don't know it yet!)
               S01:00E012CA:  58 48
F00:3741       	MOVE.w	d1,(a0)+			* set array's dimensions count
               S01:00E012CC:  30 C1
F00:3742       
F00:3743       * now calculate the array data space size
F00:3744       
F00:3745       LAB_1EC0
F00:3746       
F00:3747       * If you want arrays to dimension themselves by default then comment out the test
F00:3748       * above and uncomment the next three code lines and the label LAB_1ED0
F00:3749       
F00:3750       *	MOVE.w	#$0A,d1			* set default dimension value, allow 0 to 9
F00:3751       *	TST.b		Defdim(a3)			* test default DIM flag
F00:3752       *	BNE.s		LAB_1ED0			* branch if b6 of Defdim is clear
F00:3753       
F00:3754       	MOVE.w	(sp)+,d1			* get dimension size
               S01:00E012CE:  32 1F
F00:3755       *LAB_1ED0
F00:3756       	MOVE.w	d1,(a0)+			* save to array header
               S01:00E012D0:  30 C1
F00:3757       	BSR		LAB_1F7C			* do this dimension size+1 * array size
               S01:00E012D2:  61 00 00 AE
F00:3758       							* (d1+1)*(Asptl), result in d0
F00:3759       	MOVE.l	d0,Asptl(a3)		* save array data size
               S01:00E012D6:  27 40 05 A8
F00:3760       	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
               S01:00E012DA:  53 2B 05 DB
F00:3761       	BNE.s		LAB_1EC0			* loop while not = 0
               S01:00E012DE:  66 EE
F00:3762       
F00:3763       	ADDA.l	Asptl(a3),a0		* add size to first element address
               S01:00E012E0:  D1 EB 05 A8
F00:3764       	BCS		LAB_OMER			* if overflow go do "Out of memory" error
               S01:00E012E4:  65 00 EF 80
F00:3765       
F00:3766       	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
               S01:00E012E8:  B1 EB 04 46
F00:3767       	BCS.s		LAB_1ED6			* branch if less (is ok)
               S01:00E012EC:  65 0C
F00:3768       
F00:3769       	BSR		LAB_GARB			* do garbage collection routine
               S01:00E012EE:  61 00 02 8E
F00:3770       	CMPA.l	Sstorl(a3),a0		* compare with bottom of string memory
               S01:00E012F2:  B1 EB 04 46
F00:3771       	BCC		LAB_OMER			* if Sstorl <= a0 do "Out of memory"
               S01:00E012F6:  64 00 EF 6E
F00:3772       							* error then warm start
F00:3773       
F00:3774       LAB_1ED6						* ok exit, carry set
F00:3775       	MOVE.l	a0,Earryl(a3)		* save array mem end
               S01:00E012FA:  27 48 04 42
F00:3776       	MOVEQ		#0,d0				* zero d0
               S01:00E012FE:  70 00
F00:3777       	MOVE.l	Asptl(a3),d1		* get size in bytes
               S01:00E01300:  22 2B 05 A8
F00:3778       	LSR.l		#1,d1				* /2 for word fill (may be odd # words)
               S01:00E01304:  E2 89
F00:3779       	SUBQ.w	#1,d1				* adjust for DBF loop
               S01:00E01306:  53 41
F00:3780       LAB_1ED8
F00:3781       	MOVE.w	d0,-(a0)			* decrement pointer and clear word
               S01:00E01308:  31 00
F00:3782       	DBF		d1,LAB_1ED8			* decrement & loop until low word done
               S01:00E0130A:  51 C9 FF FC
F00:3783       
F00:3784       	SWAP		d1				* swap words
               S01:00E0130E:  48 41
F00:3785       	TST.w		d1				* test high word
               S01:00E01310:  4A 41
F00:3786       	BEQ.s		LAB_1F07			* exit if done
               S01:00E01312:  67 06
F00:3787       
F00:3788       	SUBQ.w	#1,d1				* decrement low (high) word
               S01:00E01314:  53 41
F00:3789       	SWAP		d1				* swap back
               S01:00E01316:  48 41
F00:3790       	BRA.s		LAB_1ED8			* go do a whole block
               S01:00E01318:  60 EE
F00:3791       
F00:3792       * now we need to calculate the array size by doing Earryl - Astrtl
F00:3793       
F00:3794       LAB_1F07
F00:3795       	MOVEA.l	Astrtl(a3),a0		* get for calculation and as pointer
               S01:00E0131A:  20 6B 05 AC
F00:3796       	MOVE.l	Earryl(a3),d0		* get array memory end
               S01:00E0131E:  20 2B 04 42
F00:3797       	SUB.l		a0,d0				* calculate array size
               S01:00E01322:  90 88
F00:3798       	MOVE.l	d0,4(a0)			* save size to array
               S01:00E01324:  21 40 00 04
F00:3799       	TST.b		Defdim(a3)			* test default DIM flag
               S01:00E01328:  4A 2B 05 B4
F00:3800       	BNE.s		RTS_011			* exit (RET) if this was a DIM command
               S01:00E0132C:  66 52
F00:3801       
F00:3802       							* else, find element
F00:3803       	ADDQ.w	#8,a0				* index to dimension count
               S01:00E0132E:  50 48
F00:3804       	MOVE.w	(a0)+,Dimcnt(a3)		* get array's dimension count
               S01:00E01330:  37 58 05 DB
F00:3805       
F00:3806       * we have found, or built, the array. now we need to find the element
F00:3807       
F00:3808       LAB_1F28
F00:3809       	MOVEQ		#0,d0				* clear first result
               S01:00E01334:  70 00
F00:3810       	MOVE.l	d0,Asptl(a3)		* clear array data pointer
               S01:00E01336:  27 40 05 A8
F00:3811       
F00:3812       * compare nth dimension bound (a0) with nth index (sp)+
F00:3813       * if greater do array bounds error
F00:3814       
F00:3815       LAB_1F2C
F00:3816       	MOVE.w	(a0)+,d1			* get nth dimension bound
               S01:00E0133A:  32 18
F00:3817       	CMP.w		(sp),d1			* compare nth index with nth dimension bound
               S01:00E0133C:  B2 57
F00:3818       	BCS		LAB_ABER			* if d1 less or = do array bounds error
               S01:00E0133E:  65 00 EF 1E
F00:3819       
F00:3820       * now do pointer = pointer * nth dimension + nth index
F00:3821       
F00:3822       	TST.l		d0				* test pointer
               S01:00E01342:  4A 80
F00:3823       	BEQ.s		LAB_1F5A			* skip multiply if last result = null
               S01:00E01344:  67 02
F00:3824       
F00:3825       	BSR.s		LAB_1F7C			* do this dimension size+1 * array size
               S01:00E01346:  61 3A
F00:3826       LAB_1F5A
F00:3827       	MOVEQ		#0,d1				* clear longword
               S01:00E01348:  72 00
F00:3828       	MOVE.w	(sp)+,d1			* get nth dimension index
               S01:00E0134A:  32 1F
F00:3829       	ADD.l		d1,d0				* add index to size
               S01:00E0134C:  D0 81
F00:3830       	MOVE.l	d0,Asptl(a3)		* save array data pointer
               S01:00E0134E:  27 40 05 A8
F00:3831       
F00:3832       	SUBQ.b	#1,Dimcnt(a3)		* decrement dimensions count
               S01:00E01352:  53 2B 05 DB
F00:3833       	BNE.s		LAB_1F2C			* loop if dimensions still to do
               S01:00E01356:  66 E2
F00:3834       
F00:3835       	MOVE.b	#0,Dtypef(a3)		* set data type to float
               S01:00E01358:  17 7C 00 00 05 B5
F00:3836       	MOVEQ		#3,d1				* set for numeric array
               S01:00E0135E:  72 03
F00:3837       	TST.b		Varname+1(a3)		* test if string array
               S01:00E01360:  4A 2B 04 6B
F00:3838       	BPL.s		LAB_1F6A			* branch if not string
               S01:00E01364:  6A 0A
F00:3839       
F00:3840       	MOVEQ		#5,d1				* else set for string array
               S01:00E01366:  72 05
F00:3841       	MOVE.b	#$80,Dtypef(a3)		* and set data type to string
               S01:00E01368:  17 7C 00 80 05 B5
F00:3842       	BRA.s		LAB_1F6B			* skip integer test
               S01:00E0136E:  60 0C
F00:3843       
F00:3844       LAB_1F6A
F00:3845       	TST.b		Varname+2(a3)		* test if integer array
               S01:00E01370:  4A 2B 04 6C
F00:3846       	BPL.s		LAB_1F6B			* branch if not integer
               S01:00E01374:  6A 06
F00:3847       
F00:3848       	MOVE.b	#$40,Dtypef(a3)		* else set data type to integer
               S01:00E01376:  17 7C 00 40 05 B5
F00:3849       LAB_1F6B
F00:3850       	BSR.s		LAB_1F7C			* do element size (d1) * array size (Asptl)
               S01:00E0137C:  61 04
F00:3851       	ADDA.l	d0,a0				* add array data start pointer
               S01:00E0137E:  D1 C0
F00:3852       RTS_011
F00:3853       	RTS
               S01:00E01380:  4E 75
F00:3854       
F00:3855       
F00:3856       *************************************************************************************
F00:3857       *
F00:3858       * do this dimension size (d1) * array data size (Asptl)
F00:3859       
F00:3860       * do a 16 x 32 bit multiply
F00:3861       * d1 holds the 16 bit multiplier
F00:3862       * Asptl holds the 32 bit multiplicand
F00:3863       
F00:3864       * d0	bbbb  bbbb
F00:3865       * d1	0000  aaaa
F00:3866       *	----------
F00:3867       * d0	rrrr  rrrr
F00:3868       
F00:3869       LAB_1F7C
F00:3870       	MOVE.l	Asptl(a3),d0		* get result
               S01:00E01382:  20 2B 05 A8
F00:3871       	MOVE.l	d0,d2				* copy it
               S01:00E01386:  24 00
F00:3872       	SWAP		d2				* shift high word to low word
               S01:00E01388:  48 42
F00:3873       	MULU.w	d1,d0				* d1 * low word = low result
               S01:00E0138A:  C0 C1
F00:3874       	MULU.w	d1,d2				* d1 * high word = high result
               S01:00E0138C:  C4 C1
F00:3875       	SWAP		d2				* align words for test
               S01:00E0138E:  48 42
F00:3876       	TST.w		d2				* must be zero
               S01:00E01390:  4A 42
F00:3877       	BNE		LAB_OMER			* if overflow go do "Out of memory" error
               S01:00E01392:  66 00 EE D2
F00:3878       
F00:3879       	ADD.l		d2,d0				* calculate result
               S01:00E01396:  D0 82
F00:3880       	BCS		LAB_OMER			* if overflow go do "Out of memory" error
               S01:00E01398:  65 00 EE CC
F00:3881       
F00:3882       	ADD.l		Asptl(a3),d0		* add original
               S01:00E0139C:  D0 AB 05 A8
F00:3883       	BCS		LAB_OMER			* if overflow go do "Out of memory" error
               S01:00E013A0:  65 00 EE C4
F00:3884       
F00:3885       	RTS
               S01:00E013A4:  4E 75
F00:3886       
F00:3887       
F00:3888       *************************************************************************************
F00:3889       *
F00:3890       * perform FRE()
F00:3891       
F00:3892       LAB_FRE
F00:3893       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E013A6:  4A 2B 05 B5
F00:3894       							* $00=float
F00:3895       	BPL.s		LAB_1FB4			* branch if numeric
               S01:00E013AA:  6A 04
F00:3896       
F00:3897       	BSR		LAB_22B6			* pop string off descriptor stack, or from
               S01:00E013AC:  61 00 03 10
F00:3898       							* top of string space, returns d0 = length,
F00:3899       							* a0 = pointer
F00:3900       
F00:3901       							* FRE(n) was numeric so do this
F00:3902       LAB_1FB4
F00:3903       	BSR		LAB_GARB			* go do garbage collection
               S01:00E013B0:  61 00 01 CC
F00:3904       	MOVE.l	Sstorl(a3),d0		* get bottom of string space
               S01:00E013B4:  20 2B 04 46
F00:3905       	SUB.l		Earryl(a3),d0		* subtract array mem end
               S01:00E013B8:  90 AB 04 42
F00:3906       
F00:3907       
F00:3908       *************************************************************************************
F00:3909       *
F00:3910       * convert d0 to signed longword in FAC1
F00:3911       
F00:3912       LAB_AYFC
F00:3913       	MOVE.b	#$00,Dtypef(a3)		* clear data type, $80=string, $40=integer,
               S01:00E013BC:  17 7C 00 00 05 B5
F00:3914       							* $00=float
F00:3915       	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent and clear sign (b7)
               S01:00E013C2:  37 7C A0 00 05 94
F00:3916       	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
               S01:00E013C8:  27 40 05 90
F00:3917       	BPL		LAB_24D0			* convert if +ve
               S01:00E013CC:  6A 00 08 4A
F00:3918       
F00:3919       	ORI.b		#1,CCR			* else set carry
               S01:00E013D0:  00 3C 00 01
F00:3920       	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
               S01:00E013D4:  60 00 08 42
F00:3921       
F00:3922       
F00:3923       *************************************************************************************
F00:3924       *
F00:3925       * remember if the line length is zero (infinite line) then POS(n) will return
F00:3926       * position MOD tabsize
F00:3927       
F00:3928       * perform POS()
F00:3929       
F00:3930       LAB_POS
F00:3931       	MOVE.b	TPos(a3),d0			* get terminal position
               S01:00E013D8:  10 2B 05 E5
F00:3932       
F00:3933       * convert d0 to unsigned byte in FAC1
F00:3934       
F00:3935       LAB_1FD0
F00:3936       	AND.l		#$FF,d0			* clear high bits
               S01:00E013DC:  C0 BC 00 00 00 FF
F00:3937       	BRA.s		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E013E2:  60 D8
F00:3938       
F00:3939       * check not Direct (used by DEF and INPUT)
F00:3940       
F00:3941       LAB_CKRN
F00:3942       	TST.b		Clinel(a3)			* test current line #
               S01:00E013E4:  4A 2B 04 52
F00:3943       	BMI		LAB_IDER			* if -ve go do illegal direct error then warm
               S01:00E013E8:  6B 00 EE 68
F00:3944       							* start
F00:3945       
F00:3946       	RTS						* can continue so return
               S01:00E013EC:  4E 75
F00:3947       
F00:3948       
F00:3949       *************************************************************************************
F00:3950       *
F00:3951       * perform DEF
F00:3952       
F00:3953       LAB_DEF
F00:3954       	MOVEQ		#TK_FN-$100,d0		* get FN token
               S01:00E013EE:  70 B8
F00:3955       	BSR		LAB_SCCA			* scan for CHR$(d0), else syntax error and
               S01:00E013F0:  61 00 FA BC
F00:3956       							* warm start
F00:3957       							* return character after d0
F00:3958       	MOVE.b	#$80,Sufnxf(a3)		* set FN flag bit
               S01:00E013F4:  17 7C 00 80 05 DF
F00:3959       	BSR		LAB_1D12			* get FN name
               S01:00E013FA:  61 00 FC DA
F00:3960       	MOVE.l	a0,func_l(a3)		* save function pointer
               S01:00E013FE:  27 48 05 B0
F00:3961       
F00:3962       	BSR.s		LAB_CKRN			* check not direct (back here if ok)
               S01:00E01402:  61 E0
F00:3963       	CMP.b		#$28,(a5)+			* check next byte is "(" and increment
               S01:00E01404:  0C 1D 00 28
F00:3964       	BNE		LAB_SNER			* else do syntax error/warm start
               S01:00E01408:  66 00 EE 70
F00:3965       
F00:3966       	MOVE.b	#$7E,Sufnxf(a3)		* set FN variable flag bits
               S01:00E0140C:  17 7C 00 7E 05 DF
F00:3967       	BSR		LAB_SVAR			* search for or create a variable
               S01:00E01412:  61 00 FC B4
F00:3968       							* return the variable address in a0
F00:3969       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E01416:  61 00 FA 8C
F00:3970       	MOVEQ		#TK_EQUAL-$100,d0		* = token
               S01:00E0141A:  70 CA
F00:3971       	BSR		LAB_SCCA			* scan for CHR$(A), else syntax error/warm start
               S01:00E0141C:  61 00 FA 90
F00:3972       							* return character after d0
F00:3973       	MOVE.l	Varname(a3),-(sp)		* push current variable name
               S01:00E01420:  2F 2B 04 6A
F00:3974       	MOVE.l	a5,-(sp)			* push BASIC execute pointer
               S01:00E01424:  2F 0D
F00:3975       	BSR		LAB_DATA			* go perform DATA, find end of DEF FN statement
               S01:00E01426:  61 00 F4 14
F00:3976       	MOVEA.l	func_l(a3),a0		* get the function pointer
               S01:00E0142A:  20 6B 05 B0
F00:3977       	MOVE.l	(sp)+,(a0)			* save BASIC execute pointer to function
               S01:00E0142E:  20 9F
F00:3978       	MOVE.l	(sp)+,4(a0)			* save current variable name to function
               S01:00E01430:  21 5F 00 04
F00:3979       	RTS
               S01:00E01434:  4E 75
F00:3980       
F00:3981       
F00:3982       *************************************************************************************
F00:3983       *
F00:3984       * evaluate FNx
F00:3985       
F00:3986       LAB_201E
F00:3987       	MOVE.b	#$81,Sufnxf(a3)		* set FN flag (find not create)
               S01:00E01436:  17 7C 00 81 05 DF
F00:3988       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0143C:  61 00 FA 78
F00:3989       	BSR		LAB_1D12			* get FN name
               S01:00E01440:  61 00 FC 94
F00:3990       	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function type)
               S01:00E01444:  1F 2B 05 B5
F00:3991       	MOVE.l	a0,-(sp)			* push function pointer
               S01:00E01448:  2F 08
F00:3992       	CMP.b		#$28,(a5)			* check next byte is "(", no increment
               S01:00E0144A:  0C 15 00 28
F00:3993       	BNE		LAB_SNER			* else do syntax error/warm start
               S01:00E0144E:  66 00 EE 2A
F00:3994       
F00:3995       	BSR		LAB_1BF7			* evaluate expression within parentheses
               S01:00E01452:  61 00 FA 4C
F00:3996       	MOVEA.l	(sp)+,a0			* pop function pointer
               S01:00E01456:  20 5F
F00:3997       	MOVE.l	a0,func_l(a3)		* set function pointer
               S01:00E01458:  27 48 05 B0
F00:3998       	MOVE.b	Dtypef(a3),-(sp)		* push data type flag (function expression type)
               S01:00E0145C:  1F 2B 05 B5
F00:3999       
F00:4000       	MOVE.l	4(a0),d0			* get function variable name
               S01:00E01460:  20 28 00 04
F00:4001       	BSR		LAB_1D4A			* go find function variable (already created)
               S01:00E01464:  61 00 FC DA
F00:4002       
F00:4003       							* now check type match for variable
F00:4004       	MOVE.b	(sp)+,d0			* pop data type flag (function expression type)
               S01:00E01468:  10 1F
F00:4005       	ROL.b		#1,d0				* set carry if type = string
               S01:00E0146A:  E3 18
F00:4006       	BSR		LAB_CKTM			* type match check, set C for string
               S01:00E0146C:  61 00 F8 D4
F00:4007       
F00:4008       							* now stack the function variable value before
F00:4009       							* use
F00:4010       	BEQ.s		LAB_2043			* branch if not string
               S01:00E01470:  67 12
F00:4011       
F00:4012       	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
               S01:00E01472:  43 EB 04 76
F00:4013       	CMPA.l	a1,a4				* compare string stack pointer with max+1
               S01:00E01476:  B9 C9
F00:4014       	BEQ		LAB_SCER			* if no space on the stack go do string too
               S01:00E01478:  67 00 ED CC
F00:4015       							* complex error
F00:4016       
F00:4017       	MOVE.w	4(a0),-(a4)			* string length on descriptor stack
               S01:00E0147C:  39 28 00 04
F00:4018       	MOVE.l	(a0),-(a4)			* string address on stack
               S01:00E01480:  29 10
F00:4019       	BRA.s		LAB_204S			* skip var push
               S01:00E01482:  60 02
F00:4020       
F00:4021       LAB_2043
F00:4022       	MOVE.l	(a0),-(sp)			* push variable
               S01:00E01484:  2F 10
F00:4023       LAB_204S
F00:4024       	MOVE.l	a0,-(sp)			* push variable address
               S01:00E01486:  2F 08
F00:4025       	MOVE.b	Dtypef(a3),-(sp)		* push variable data type
               S01:00E01488:  1F 2B 05 B5
F00:4026       
F00:4027       	BSR.s		LAB_2045			* pack function expression value into (a0)
               S01:00E0148C:  61 32
F00:4028       							* (function variable)
F00:4029       	MOVE.l	a5,-(sp)			* push BASIC execute pointer
               S01:00E0148E:  2F 0D
F00:4030       	MOVEA.l	func_l(a3),a0		* get function pointer
               S01:00E01490:  20 6B 05 B0
F00:4031       	MOVEA.l	(a0),a5			* save function execute ptr as BASIC execute ptr
               S01:00E01494:  2A 50
F00:4032       	BSR		LAB_EVEX			* evaluate expression
               S01:00E01496:  61 00 F8 BE
F00:4033       	BSR		LAB_GBYT			* scan memory
               S01:00E0149A:  61 00 FA 1C
F00:4034       	BNE		LAB_SNER			* if not [EOL] or [EOS] do syntax error then
               S01:00E0149E:  66 00 ED DA
F00:4035       							* warm start
F00:4036       
F00:4037       	MOVE.l	(sp)+,a5			* restore BASIC execute pointer
               S01:00E014A2:  2A 5F
F00:4038       
F00:4039       * restore variable from stack and test data type
F00:4040       
F00:4041       	MOVE.b	(sp)+,d0			* pull variable data type
               S01:00E014A4:  10 1F
F00:4042       	MOVEA.l	(sp)+,a0			* pull variable address
               S01:00E014A6:  20 5F
F00:4043       	TST.b		d0				* test variable data type
               S01:00E014A8:  4A 00
F00:4044       	BPL.s		LAB_204T			* branch if not string
               S01:00E014AA:  6A 08
F00:4045       
F00:4046       	MOVE.l	(a4)+,(a0)			* string address from descriptor stack
               S01:00E014AC:  20 9C
F00:4047       	MOVE.w	(a4)+,4(a0)			* string length from descriptor stack
               S01:00E014AE:  31 5C 00 04
F00:4048       	BRA.s		LAB_2044			* skip variable pull
               S01:00E014B2:  60 02
F00:4049       
F00:4050       LAB_204T
F00:4051       	MOVE.l	(sp)+,(a0)			* restore variable from stack
               S01:00E014B4:  20 9F
F00:4052       LAB_2044
F00:4053       	MOVE.b	(sp)+,d0			* pop data type flag (function type)
               S01:00E014B6:  10 1F
F00:4054       	ROL.b		#1,d0				* set carry if type = string
               S01:00E014B8:  E3 18
F00:4055       	BSR		LAB_CKTM			* type match check, set C for string
               S01:00E014BA:  61 00 F8 86
F00:4056       	RTS
               S01:00E014BE:  4E 75
F00:4057       
F00:4058       LAB_2045
F00:4059       	TST.b		Dtypef(a3)			* test data type
               S01:00E014C0:  4A 2B 05 B5
F00:4060       	BPL		LAB_2778			* if numeric pack FAC1 into variable (a0) and
               S01:00E014C4:  6A 00 09 F8
F00:4061       							* return
F00:4062       
F00:4063       	MOVEA.l	a0,a2				* copy variable pointer
               S01:00E014C8:  24 48
F00:4064       	BRA		LAB_17D6			* go do string LET & return
               S01:00E014CA:  60 00 F5 0E
F00:4065       
F00:4066       
F00:4067       
F00:4068       *************************************************************************************
F00:4069       *
F00:4070       * perform STR$()
F00:4071       
F00:4072       LAB_STRS
F00:4073       	BSR		LAB_2970			* convert FAC1 to string
               S01:00E014CE:  61 00 0B 54
F00:4074       
F00:4075       * scan, set up string
F00:4076       * print " terminated string to FAC1 stack
F00:4077       
F00:4078       LAB_20AE
F00:4079       	MOVEQ		#$22,d2			* set Srchc character (terminator 1)
               S01:00E014D2:  74 22
F00:4080       	MOVE.w	d2,d3				* set Asrch character (terminator 2)
               S01:00E014D4:  36 02
F00:4081       
F00:4082       * print d2/d3 terminated string to FAC1 stack
F00:4083       * d2 = Srchc, d3 = Asrch, a0 is source
F00:4084       * a6 is temp
F00:4085       
F00:4086       LAB_20B4
F00:4087       	MOVEQ		#0,d1				* clear longword
               S01:00E014D6:  72 00
F00:4088       	SUBQ.w	#1,d1				* set length to -1
               S01:00E014D8:  53 41
F00:4089       	MOVEA.l	a0,a2				* copy start to calculate end
               S01:00E014DA:  24 48
F00:4090       LAB_20BE
F00:4091       	ADDQ.w	#1,d1				* increment length
               S01:00E014DC:  52 41
F00:4092       	MOVE.b	(a0,d1.w),d0		* get byte from string
               S01:00E014DE:  10 30 10 00
F00:4093       	BEQ.s		LAB_20D0			* exit loop if null byte [EOS]
               S01:00E014E2:  67 10
F00:4094       
F00:4095       	CMP.b		d2,d0				* compare with search character (terminator 1)
               S01:00E014E4:  B0 02
F00:4096       	BEQ.s		LAB_20CB			* branch if terminator
               S01:00E014E6:  67 04
F00:4097       
F00:4098       	CMP.b		d3,d0				* compare with terminator 2
               S01:00E014E8:  B0 03
F00:4099       	BNE.s		LAB_20BE			* loop if not terminator 2 (or null string)
               S01:00E014EA:  66 F0
F00:4100       
F00:4101       LAB_20CB
F00:4102       	CMP.b		#$22,d0			* compare with "
               S01:00E014EC:  B0 3C 00 22
F00:4103       	BNE.s		LAB_20D0			* branch if not "
               S01:00E014F0:  66 02
F00:4104       
F00:4105       	ADDQ.w	#1,a2				* else increment string start (skip " at end)
               S01:00E014F2:  52 4A
F00:4106       LAB_20D0
F00:4107       	ADDA.l	d1,a2				* add longowrd length to make string end+1
               S01:00E014F4:  D5 C1
F00:4108       
F00:4109       	CMPA.l	a3,a0				* is string in ram
               S01:00E014F6:  B1 CB
F00:4110       	BCS.s		LAB_RTST			* if not go push descriptor on stack & exit
               S01:00E014F8:  65 1E
F00:4111       							* (could be message string from ROM)
F00:4112       
F00:4113       	CMPA.l	Smeml(a3),a0		* is string in utility ram
               S01:00E014FA:  B1 EB 04 2E
F00:4114       	BCC.s		LAB_RTST			* if not go push descriptor on stack & exit
               S01:00E014FE:  64 18
F00:4115       							* (is in string or program space)
F00:4116       
F00:4117       							* (else) copy string to string memory
F00:4118       LAB_20C9
F00:4119       	MOVEA.l	a0,a1				* copy descriptor pointer
               S01:00E01500:  22 48
F00:4120       	MOVE.l	d1,d0				* copy longword length
               S01:00E01502:  20 01
F00:4121       	BNE.s		LAB_20D8			* branch if not null string
               S01:00E01504:  66 04
F00:4122       
F00:4123       	MOVEA.l	d1,a0				* make null pointer
               S01:00E01506:  20 41
F00:4124       	BRA.s		LAB_RTST			* go push descriptor on stack & exit
               S01:00E01508:  60 0E
F00:4125       
F00:4126       LAB_20D8
F00:4127       	BSR.s		LAB_2115			* make string space d1 bytes long
               S01:00E0150A:  61 26
F00:4128       	ADDA.l	d1,a0				* new string end
               S01:00E0150C:  D1 C1
F00:4129       	ADDA.l	d1,a1				* old string end
               S01:00E0150E:  D3 C1
F00:4130       	SUBQ.w	#1,d0				* -1 for DBF loop
               S01:00E01510:  53 40
F00:4131       LAB_20E0
F00:4132       	MOVE.b	-(a1),-(a0)			* copy byte (source can be odd aligned)
               S01:00E01512:  11 21
F00:4133       	DBF		d0,LAB_20E0			* loop until done
               S01:00E01514:  51 C8 FF FC
F00:4134       
F00:4135       
F00:4136       
F00:4137       *************************************************************************************
F00:4138       *
F00:4139       * check for space on descriptor stack then ...
F00:4140       * put string address and length on descriptor stack & update stack pointers
F00:4141       * start is in a0, length is in d1
F00:4142       
F00:4143       LAB_RTST
F00:4144       	LEA		des_sk_e(a3),a1		* get string stack pointer max+1
               S01:00E01518:  43 EB 04 76
F00:4145       	CMPA.l	a1,a4				* compare string stack pointer with max+1
               S01:00E0151C:  B9 C9
F00:4146       	BEQ		LAB_SCER			* if no space on string stack ..
               S01:00E0151E:  67 00 ED 26
F00:4147       							* .. go do 'string too complex' error
F00:4148       
F00:4149       							* push string & update pointers
F00:4150       	MOVE.w	d1,-(a4)			* string length on descriptor stack
               S01:00E01522:  39 01
F00:4151       	MOVE.l	a0,-(a4)			* string address on stack
               S01:00E01524:  29 08
F00:4152       	MOVE.l	a4,FAC1_m(a3)		* string descriptor pointer in FAC1
               S01:00E01526:  27 4C 05 90
F00:4153       	MOVE.b	#$80,Dtypef(a3)		* save data type flag, $80=string
               S01:00E0152A:  17 7C 00 80 05 B5
F00:4154       	RTS
               S01:00E01530:  4E 75
F00:4155       
F00:4156       
F00:4157       *************************************************************************************
F00:4158       *
F00:4159       * build descriptor a0/d1
F00:4160       * make space in string memory for string d1.w long
F00:4161       * return pointer in a0/Sutill
F00:4162       
F00:4163       LAB_2115
F00:4164       	TST.w		d1				* test length
               S01:00E01532:  4A 41
F00:4165       	BEQ.s		LAB_2128			* branch if user wants null string
               S01:00E01534:  67 2E
F00:4166       
F00:4167       							* make space for string d1 long
F00:4168       	MOVE.l	d0,-(sp)			* save d0
               S01:00E01536:  2F 00
F00:4169       	MOVEQ		#0,d0				* clear longword
               S01:00E01538:  70 00
F00:4170       	MOVE.b	d0,Gclctd(a3)		* clear garbage collected flag (b7)
               S01:00E0153A:  17 40 05 DE
F00:4171       	MOVEQ		#1,d0				* +1 to possibly round up
               S01:00E0153E:  70 01
F00:4172       	AND.w		d1,d0				* mask odd bit
               S01:00E01540:  C0 41
F00:4173       	ADD.w		d1,d0				* ensure d0 is even length
               S01:00E01542:  D0 41
F00:4174       	BCC.s		LAB_2117			* branch if no overflow
               S01:00E01544:  64 04
F00:4175       
F00:4176       	MOVEQ		#1,d0				* set to allocate 65536 bytes
               S01:00E01546:  70 01
F00:4177       	SWAP		d0				* makes $00010000
               S01:00E01548:  48 40
F00:4178       LAB_2117
F00:4179       	MOVEA.l	Sstorl(a3),a0		* get bottom of string space
               S01:00E0154A:  20 6B 04 46
F00:4180       	SUBA.l	d0,a0				* subtract string length
               S01:00E0154E:  91 C0
F00:4181       	CMPA.l	Earryl(a3),a0		* compare with top of array space
               S01:00E01550:  B1 EB 04 42
F00:4182       	BCS.s		LAB_2137			* if less do out of memory error
               S01:00E01554:  65 12
F00:4183       
F00:4184       	MOVE.l	a0,Sstorl(a3)		* save bottom of string space
               S01:00E01556:  27 48 04 46
F00:4185       	MOVE.l	a0,Sutill(a3)		* save string utility pointer
               S01:00E0155A:  27 48 04 4E
F00:4186       	MOVE.l	(sp)+,d0			* restore d0
               S01:00E0155E:  20 1F
F00:4187       	TST.w		d1				* set flags on length
               S01:00E01560:  4A 41
F00:4188       	RTS
               S01:00E01562:  4E 75
F00:4189       
F00:4190       LAB_2128
F00:4191       	MOVEA.w	d1,a0				* make null pointer
               S01:00E01564:  30 41
F00:4192       	RTS
               S01:00E01566:  4E 75
F00:4193       
F00:4194       LAB_2137
F00:4195       	TST.b		Gclctd(a3)			* get garbage collected flag
               S01:00E01568:  4A 2B 05 DE
F00:4196       	BMI		LAB_OMER			* do "Out of memory" error, then warm start
               S01:00E0156C:  6B 00 EC F8
F00:4197       
F00:4198       	MOVE.l	a1,-(sp)			* save a1
               S01:00E01570:  2F 09
F00:4199       	BSR.s		LAB_GARB			* else go do garbage collection
               S01:00E01572:  61 0A
F00:4200       	MOVEA.l	(sp)+,a1			* restore a1
               S01:00E01574:  22 5F
F00:4201       	MOVE.b	#$80,Gclctd(a3)		* set garbage collected flag
               S01:00E01576:  17 7C 00 80 05 DE
F00:4202       	BRA.s		LAB_2117			* go try again
               S01:00E0157C:  60 CC
F00:4203       
F00:4204       
F00:4205       *************************************************************************************
F00:4206       *
F00:4207       * garbage collection routine
F00:4208       
F00:4209       LAB_GARB
F00:4210       	MOVEM.l	d0-d2/a0-a2,-(sp)		* save registers
               S01:00E0157E:  48 E7 E0 E0
F00:4211       	MOVE.l	Ememl(a3),Sstorl(a3)	* start with no strings
               S01:00E01582:  27 6B 04 4A 04 46
F00:4212       
F00:4213       							* re-run routine from last ending
F00:4214       LAB_214B
F00:4215       	MOVE.l	Earryl(a3),d1		* set highest uncollected string so far
               S01:00E01588:  22 2B 04 42
F00:4216       	MOVEQ		#0,d0				* clear longword
               S01:00E0158C:  70 00
F00:4217       	MOVEA.l	d0,a1				* clear string to move pointer
               S01:00E0158E:  22 40
F00:4218       	MOVEA.l	Sstrl(a3),a0		* set pointer to start of strings
               S01:00E01590:  20 6B 04 3A
F00:4219       	LEA		4(a0),a0			* index to string pointer
               S01:00E01594:  58 88
F00:4220       	MOVEA.l	Sarryl(a3),a2		* set end pointer to start of arrays, end of
               S01:00E01596:  24 6B 04 3E
F00:4221       							* strings
F00:4222       	BRA.s		LAB_2176			* branch into loop at end loop test
               S01:00E0159A:  60 06
F00:4223       
F00:4224       LAB_2161
F00:4225       	BSR		LAB_2206			* test and set if this is the highest string
               S01:00E0159C:  61 7E
F00:4226       	LEA		10(a0),a0			* increment to next string
               S01:00E0159E:  41 E8 00 0A
F00:4227       LAB_2176
F00:4228       	CMPA.l	a2,a0				* compare end of area with pointer
               S01:00E015A2:  B1 CA
F00:4229       	BCS.s		LAB_2161			* go do next if not at end
               S01:00E015A4:  65 F6
F00:4230       
F00:4231       * done strings, now do arrays.
F00:4232       
F00:4233       	LEA		-4(a0),a0			* decrement pointer to start of arrays
               S01:00E015A6:  59 88
F00:4234       	MOVEA.l	Earryl(a3),a2		* set end pointer to end of arrays
               S01:00E015A8:  24 6B 04 42
F00:4235       	BRA.s		LAB_218F			* branch into loop at end loop test
               S01:00E015AC:  60 24
F00:4236       
F00:4237       LAB_217E
F00:4238       	MOVE.l	4(a0),d2			* get array size
               S01:00E015AE:  24 28 00 04
F00:4239       	ADD.l		a0,d2				* makes start of next array
               S01:00E015B2:  D4 88
F00:4240       
F00:4241       	MOVE.l	(a0),d0			* get array name
               S01:00E015B4:  20 10
F00:4242       	BTST		#23,d0			* test string flag
               S01:00E015B6:  08 00 00 17
F00:4243       	BEQ.s		LAB_218B			* branch if not string
               S01:00E015BA:  67 14
F00:4244       
F00:4245       	MOVE.w	8(a0),d0			* get # of dimensions
               S01:00E015BC:  30 28 00 08
F00:4246       	ADD.w		d0,d0				* *2
               S01:00E015C0:  D0 40
F00:4247       	ADDA.w	d0,a0				* add to skip dimension size(s)
               S01:00E015C2:  D0 C0
F00:4248       	LEA		10(a0),a0			* increment to first element
               S01:00E015C4:  41 E8 00 0A
F00:4249       LAB_2183
F00:4250       	BSR.s		LAB_2206			* test and set if this is the highest string
               S01:00E015C8:  61 52
F00:4251       	ADDQ.w	#6,a0				* increment to next element
               S01:00E015CA:  5C 48
F00:4252       	CMPA.l	d2,a0				* compare with start of next array
               S01:00E015CC:  B1 C2
F00:4253       	BNE.s		LAB_2183			* go do next if not at end of array
               S01:00E015CE:  66 F8
F00:4254       
F00:4255       LAB_218B
F00:4256       	MOVEA.l	d2,a0				* pointer to next array
               S01:00E015D0:  20 42
F00:4257       LAB_218F
F00:4258       	CMPA.l	a0,a2				* compare pointer with array end
               S01:00E015D2:  B5 C8
F00:4259       	BNE.s		LAB_217E			* go do next if not at end
               S01:00E015D4:  66 D8
F00:4260       
F00:4261       * done arrays and variables, now just the descriptor stack to do
F00:4262       
F00:4263       	MOVEA.l	a4,a0				* get descriptor stack pointer
               S01:00E015D6:  20 4C
F00:4264       	LEA		des_sk(a3),a2		* set end pointer to end of stack
               S01:00E015D8:  45 EB 04 8E
F00:4265       	BRA.s		LAB_21C4			* branch into loop at end loop test
               S01:00E015DC:  60 04
F00:4266       
F00:4267       LAB_21C2
F00:4268       	BSR.s		LAB_2206			* test and set if this is the highest string
               S01:00E015DE:  61 3C
F00:4269       	LEA		6(a0),a0			* increment to next string
               S01:00E015E0:  5C 88
F00:4270       LAB_21C4
F00:4271       	CMPA.l	a0,a2				* compare pointer with stack end
               S01:00E015E2:  B5 C8
F00:4272       	BNE.s		LAB_21C2			* go do next if not at end
               S01:00E015E4:  66 F8
F00:4273       
F00:4274       * descriptor search complete, now either exit or set-up and move string
F00:4275       
F00:4276       	MOVE.l	a1,d0				* set the flags (a1 is move string)
               S01:00E015E6:  20 09
F00:4277       	BEQ.s		LAB_21D1			* go tidy up and exit if no move
               S01:00E015E8:  67 2C
F00:4278       
F00:4279       	MOVEA.l	(a1),a0			* a0 is now string start
               S01:00E015EA:  20 51
F00:4280       	MOVEQ		#0,d1				* clear d1
               S01:00E015EC:  72 00
F00:4281       	MOVE.w	4(a1),d1			* d1 is string length
               S01:00E015EE:  32 29 00 04
F00:4282       	ADDQ.l	#1,d1				* +1
               S01:00E015F2:  52 81
F00:4283       	AND.b		#$FE,d1			* make even length
               S01:00E015F4:  C2 3C 00 FE
F00:4284       	ADDA.l	d1,a0				* pointer is now to string end+1
               S01:00E015F8:  D1 C1
F00:4285       	MOVEA.l	Sstorl(a3),a2		* is destination end+1
               S01:00E015FA:  24 6B 04 46
F00:4286       	CMPA.l	a2,a0				* does the string need moving
               S01:00E015FE:  B1 CA
F00:4287       	BEQ.s		LAB_2240			* branch if not
               S01:00E01600:  67 0C
F00:4288       
F00:4289       	LSR.l		#1,d1				* word move so do /2
               S01:00E01602:  E2 89
F00:4290       	SUBQ.w	#1,d1				* -1 for DBF loop
               S01:00E01604:  53 41
F00:4291       LAB_2216
F00:4292       	MOVE.w	-(a0),-(a2)			* copy word
               S01:00E01606:  35 20
F00:4293       	DBF		d1,LAB_2216			* loop until done
               S01:00E01608:  51 C9 FF FC
F00:4294       
F00:4295       	MOVE.l	a2,(a1)			* save new string start
               S01:00E0160C:  22 8A
F00:4296       LAB_2240
F00:4297       	MOVE.l	(a1),Sstorl(a3)		* string start is new string mem start
               S01:00E0160E:  27 51 04 46
F00:4298       	BRA		LAB_214B			* re-run routine from last ending
               S01:00E01612:  60 00 FF 74
F00:4299       							* (but don't collect this string)
F00:4300       
F00:4301       LAB_21D1
F00:4302       	MOVEM.l	(sp)+,d0-d2/a0-a2		* restore registers
               S01:00E01616:  4C DF 07 07
F00:4303       	RTS
               S01:00E0161A:  4E 75
F00:4304       
F00:4305       * test and set if this is the highest string
F00:4306       
F00:4307       LAB_2206
F00:4308       	MOVE.l	(a0),d0			* get this string pointer
               S01:00E0161C:  20 10
F00:4309       	BEQ.s		RTS_012			* exit if null string
               S01:00E0161E:  67 28
F00:4310       
F00:4311       	CMP.l		d0,d1				* compare with highest uncollected string so far
               S01:00E01620:  B2 80
F00:4312       	BCC.s		RTS_012			* exit if <= with highest so far
               S01:00E01622:  64 24
F00:4313       
F00:4314       	CMP.l		Sstorl(a3),d0		* compare with bottom of string space
               S01:00E01624:  B0 AB 04 46
F00:4315       	BCC.s		RTS_012			* exit if >= bottom of string space
               S01:00E01628:  64 1E
F00:4316       
F00:4317       	MOVEQ		#-1,d0			* d0 = $FFFFFFFF
               S01:00E0162A:  70 FF
F00:4318       	MOVE.w	4(a0),d0			* d0 is string length
               S01:00E0162C:  30 28 00 04
F00:4319       	NEG.w		d0				* make -ve
               S01:00E01630:  44 40
F00:4320       	AND.b		#$FE,d0			* make -ve even length
               S01:00E01632:  C0 3C 00 FE
F00:4321       	ADD.l		Sstorl(a3),d0		* add string store to -ve length
               S01:00E01636:  D0 AB 04 46
F00:4322       	CMP.l		(a0),d0			* compare with string address
               S01:00E0163A:  B0 90
F00:4323       	BEQ.s		LAB_2212			* if = go move string store pointer down
               S01:00E0163C:  67 06
F00:4324       
F00:4325       	MOVE.l	(a0),d1			* highest = current
               S01:00E0163E:  22 10
F00:4326       	MOVEA.l	a0,a1				* string to move = current
               S01:00E01640:  22 48
F00:4327       	RTS
               S01:00E01642:  4E 75
F00:4328       
F00:4329       LAB_2212
F00:4330       	MOVE.l	d0,Sstorl(a3)		* set new string store start
               S01:00E01644:  27 40 04 46
F00:4331       RTS_012
F00:4332       	RTS
               S01:00E01648:  4E 75
F00:4333       
F00:4334       
F00:4335       *************************************************************************************
F00:4336       *
F00:4337       * concatenate - add strings
F00:4338       * string descriptor 1 is in FAC1_m, string 2 is in line
F00:4339       
F00:4340       LAB_224D
F00:4341       	PEA		LAB_1ADB(pc)		* continue evaluation after concatenate
               S01:00E0164A:  48 7A F7 3C
F00:4342       	MOVE.l	FAC1_m(a3),-(sp)		* stack descriptor pointer for string 1
               S01:00E0164E:  2F 2B 05 90
F00:4343       
F00:4344       	BSR		LAB_GVAL			* get value from line
               S01:00E01652:  61 00 F8 10
F00:4345       	TST.b		Dtypef(a3)			* test data type flag
               S01:00E01656:  4A 2B 05 B5
F00:4346       	BPL		LAB_TMER			* if type is not string do type mismatch error
               S01:00E0165A:  6A 00 EB F2
F00:4347       
F00:4348       	MOVEA.l	(sp)+,a0			* restore descriptor pointer for string 1
               S01:00E0165E:  20 5F
F00:4349       
F00:4350       *************************************************************************************
F00:4351       *
F00:4352       * concatenate
F00:4353       * string descriptor 1 is in a0, string descriptor 2 is in FAC1_m
F00:4354       
F00:4355       LAB_224E
F00:4356       	MOVEA.l	FAC1_m(a3),a1		* copy descriptor pointer 2
               S01:00E01660:  22 6B 05 90
F00:4357       	MOVE.w	4(a0),d1			* get length 1
               S01:00E01664:  32 28 00 04
F00:4358       	ADD.w		4(a1),d1			* add length 2
               S01:00E01668:  D2 69 00 04
F00:4359       	BCS		LAB_SLER			* if overflow go do 'string too long' error
               S01:00E0166C:  65 00 EB DC
F00:4360       
F00:4361       	MOVE.l	a0,-(sp)			* save descriptor pointer 1
               S01:00E01670:  2F 08
F00:4362       	BSR		LAB_2115			* make space d1 bytes long
               S01:00E01672:  61 00 FE BE
F00:4363       	MOVE.l	a0,FAC2_m(a3)		* save new string start pointer
               S01:00E01676:  27 48 05 98
F00:4364       	MOVEA.l	(sp),a0			* copy descriptor pointer 1 from stack
               S01:00E0167A:  20 57
F00:4365       	MOVE.w	4(a0),d0			* get length
               S01:00E0167C:  30 28 00 04
F00:4366       	MOVEA.l	(a0),a0			* get string pointer
               S01:00E01680:  20 50
F00:4367       	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
               S01:00E01682:  61 20
F00:4368       							* return with a0 = pointer, d1 = length
F00:4369       
F00:4370       	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer for string 2
               S01:00E01684:  20 6B 05 90
F00:4371       	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E01688:  61 38
F00:4372       							* a0 = pointer, d0 = length
F00:4373       	BSR.s		LAB_229E			* copy string d0 bytes long from a0 to Sutill
               S01:00E0168A:  61 18
F00:4374       							* return with a0 = pointer, d1 = length
F00:4375       
F00:4376       	MOVEA.l	(sp)+,a0			* get descriptor pointer for string 1
               S01:00E0168C:  20 5F
F00:4377       	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E0168E:  61 32
F00:4378       							* d0 = length, a0 = pointer
F00:4379       
F00:4380       	MOVEA.l	FAC2_m(a3),a0		* retreive result string pointer
               S01:00E01690:  20 6B 05 98
F00:4381       	MOVE.l	a0,d1				* copy the result string pointer
               S01:00E01694:  22 08
F00:4382       	BEQ		LAB_RTST			* if it is a null string just return it
               S01:00E01696:  67 00 FE 80
F00:4383       							* a0 = pointer, d1 = length
F00:4384       
F00:4385       	NEG.l		d1				* else make the start pointer negative
               S01:00E0169A:  44 81
F00:4386       	ADD.l		Sutill(a3),d1		* add the end pointert to give the length
               S01:00E0169C:  D2 AB 04 4E
F00:4387       	BRA		LAB_RTST			* push string on descriptor stack
               S01:00E016A0:  60 00 FE 76
F00:4388       							* a0 = pointer, d1 = length
F00:4389       
F00:4390       
F00:4391       *************************************************************************************
F00:4392       *
F00:4393       * copy string d0 bytes long from a0 to Sutill
F00:4394       * return with a0 = pointer, d1 = length
F00:4395       
F00:4396       LAB_229E
F00:4397       	MOVE.w	d0,d1				* copy and check length
               S01:00E016A4:  32 00
F00:4398       	BEQ.s		RTS_013			* skip copy if null
               S01:00E016A6:  67 14
F00:4399       
F00:4400       	MOVEA.l	Sutill(a3),a1		* get destination pointer
               S01:00E016A8:  22 6B 04 4E
F00:4401       	MOVE.l	a1,-(sp)			* save destination string pointer
               S01:00E016AC:  2F 09
F00:4402       	SUBQ.w	#1,d0				* subtract for DBF loop
               S01:00E016AE:  53 40
F00:4403       LAB_22A0
F00:4404       	MOVE.b	(a0)+,(a1)+			* copy byte
               S01:00E016B0:  12 D8
F00:4405       	DBF		d0,LAB_22A0			* loop if not done
               S01:00E016B2:  51 C8 FF FC
F00:4406       
F00:4407       	MOVE.l	a1,Sutill(a3)		* update Sutill to end of copied string
               S01:00E016B6:  27 49 04 4E
F00:4408       	MOVEA.l	(sp)+,a0			* restore destination string pointer
               S01:00E016BA:  20 5F
F00:4409       RTS_013
F00:4410       	RTS
               S01:00E016BC:  4E 75
F00:4411       
F00:4412       
F00:4413       *************************************************************************************
F00:4414       *
F00:4415       * pop string off descriptor stack, or from top of string space
F00:4416       * returns with d0.l = length, a0 = pointer
F00:4417       
F00:4418       LAB_22B6
F00:4419       	MOVEA.l	FAC1_m(a3),a0		* get descriptor pointer
               S01:00E016BE:  20 6B 05 90
F00:4420       
F00:4421       
F00:4422       *************************************************************************************
F00:4423       *
F00:4424       * pop (a0) descriptor off stack or from string space
F00:4425       * returns with d0.l = length, a0 = pointer
F00:4426       
F00:4427       LAB_22BA
F00:4428       	MOVEM.l	a1/d1,-(sp)			* save other regs
               S01:00E016C2:  48 E7 40 40
F00:4429       	CMPA.l	a0,a4				* is string on the descriptor stack
               S01:00E016C6:  B9 C8
F00:4430       	BNE.s		LAB_22BD			* skip pop if not
               S01:00E016C8:  66 02
F00:4431       
F00:4432       	ADDQ.w	#$06,a4			* else update stack pointer
               S01:00E016CA:  5C 4C
F00:4433       LAB_22BD
F00:4434       	MOVEQ		#0,d0				* clear string length longword
               S01:00E016CC:  70 00
F00:4435       	MOVEA.l	(a0)+,a1			* get string address
               S01:00E016CE:  22 58
F00:4436       	MOVE.w	(a0)+,d0			* get string length
               S01:00E016D0:  30 18
F00:4437       
F00:4438       	CMPA.l	a0,a4				* was it on the descriptor stack
               S01:00E016D2:  B9 C8
F00:4439       	BNE.s		LAB_22E6			* branch if it wasn't
               S01:00E016D4:  66 10
F00:4440       
F00:4441       	CMPA.l	Sstorl(a3),a1		* compare string address with bottom of string
               S01:00E016D6:  B3 EB 04 46
F00:4442       							* space
F00:4443       	BNE.s		LAB_22E6			* branch if <>
               S01:00E016DA:  66 0A
F00:4444       
F00:4445       	MOVEQ		#1,d1				* mask for odd bit
               S01:00E016DC:  72 01
F00:4446       	AND.w		d0,d1				* AND length
               S01:00E016DE:  C2 40
F00:4447       	ADD.l		d0,d1				* make it fit word aligned length
               S01:00E016E0:  D2 80
F00:4448       
F00:4449       	ADD.l		d1,Sstorl(a3)		* add to bottom of string space
               S01:00E016E2:  D3 AB 04 46
F00:4450       LAB_22E6
F00:4451       	MOVEA.l	a1,a0				* copy to a0
               S01:00E016E6:  20 49
F00:4452       	MOVEM.l	(sp)+,a1/d1			* restore other regs
               S01:00E016E8:  4C DF 02 02
F00:4453       	TST.l		d0				* set flags on length
               S01:00E016EC:  4A 80
F00:4454       	RTS
               S01:00E016EE:  4E 75
F00:4455       
F00:4456       
F00:4457       *************************************************************************************
F00:4458       *
F00:4459       * perform CHR$()
F00:4460       
F00:4461       LAB_CHRS
F00:4462       	BSR		LAB_EVBY			* evaluate byte expression, result in d0 and
               S01:00E016F0:  61 00 01 30
F00:4463       							* Itemp
F00:4464       	MOVEQ		#1,d1				* string is single byte
               S01:00E016F4:  72 01
F00:4465       	BSR		LAB_2115			* make string space d1 bytes long
               S01:00E016F6:  61 00 FE 3A
F00:4466       							* return a0/Sutill = pointer, others unchanged
F00:4467       	MOVE.b	d0,(a0)			* save byte in string (byte IS string!)
               S01:00E016FA:  10 80
F00:4468       	BRA		LAB_RTST			* push string on descriptor stack
               S01:00E016FC:  60 00 FE 1A
F00:4469       							* a0 = pointer, d1 = length
F00:4470       
F00:4471       
F00:4472       *************************************************************************************
F00:4473       *
F00:4474       * perform LEFT$()
F00:4475       
F00:4476       * enter with a0 is descriptor, d0 & Itemp is word 1
F00:4477       
F00:4478       LAB_LEFT
F00:4479       	EXG		d0,d1				* word in d1
               S01:00E01700:  C1 41
F00:4480       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E01702:  61 00 F7 A0
F00:4481       
F00:4482       	TST.l		d1				* test returned length
               S01:00E01706:  4A 81
F00:4483       	BEQ.s		LAB_231C			* branch if null return
               S01:00E01708:  67 22
F00:4484       
F00:4485       	MOVEQ		#0,d0				* clear start offset
               S01:00E0170A:  70 00
F00:4486       	CMP.w		4(a0),d1			* compare word parameter with string length
               S01:00E0170C:  B2 68 00 04
F00:4487       	BCS.s		LAB_231C			* branch if string length > word parameter
               S01:00E01710:  65 1A
F00:4488       
F00:4489       	BRA.s		LAB_2317			* go copy whole string
               S01:00E01712:  60 14
F00:4490       
F00:4491       
F00:4492       *************************************************************************************
F00:4493       *
F00:4494       * perform RIGHT$()
F00:4495       
F00:4496       * enter with a0 is descriptor, d0 & Itemp is word 1
F00:4497       
F00:4498       LAB_RIGHT
F00:4499       	EXG		d0,d1				* word in d1
               S01:00E01714:  C1 41
F00:4500       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E01716:  61 00 F7 8C
F00:4501       
F00:4502       	TST.l		d1				* test returned length
               S01:00E0171A:  4A 81
F00:4503       	BEQ.s		LAB_231C			* branch if null return
               S01:00E0171C:  67 0E
F00:4504       
F00:4505       	MOVE.w	4(a0),d0			* get string length
               S01:00E0171E:  30 28 00 04
F00:4506       	SUB.l		d1,d0				* subtract word
               S01:00E01722:  90 81
F00:4507       	BCC.s		LAB_231C			* branch if string length > word parameter
               S01:00E01724:  64 06
F00:4508       
F00:4509       							* else copy whole string
F00:4510       LAB_2316
F00:4511       	MOVEQ		#0,d0				* clear start offset
               S01:00E01726:  70 00
F00:4512       LAB_2317
F00:4513       	MOVE.w	4(a0),d1			* else make parameter = length
               S01:00E01728:  32 28 00 04
F00:4514       
F00:4515       * get here with ...
F00:4516       *   a0 - points to descriptor
F00:4517       *   d0 - is offset from string start
F00:4518       *   d1 - is required string length
F00:4519       
F00:4520       LAB_231C
F00:4521       	MOVEA.l	a0,a1				* save string descriptor pointer
               S01:00E0172C:  22 48
F00:4522       	BSR		LAB_2115			* make string space d1 bytes long
               S01:00E0172E:  61 00 FE 02
F00:4523       							* return a0/Sutill = pointer, others unchanged
F00:4524       	MOVEA.l	a1,a0				* restore string descriptor pointer
               S01:00E01732:  20 49
F00:4525       	MOVE.l	d0,-(sp)			* save start offset (longword)
               S01:00E01734:  2F 00
F00:4526       	BSR.s		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E01736:  61 8A
F00:4527       							* d0 = length, a0 = pointer
F00:4528       	ADDA.l	(sp)+,a0			* adjust pointer to start of wanted string
               S01:00E01738:  D1 DF
F00:4529       	MOVE.w	d1,d0				* length to d0
               S01:00E0173A:  30 01
F00:4530       	BSR		LAB_229E			* store string d0 bytes long from (a0) to
               S01:00E0173C:  61 00 FF 66
F00:4531       							* (Sutill) return with a0 = pointer,
F00:4532       							* d1 = length
F00:4533       	BRA		LAB_RTST			* push string on descriptor stack
               S01:00E01740:  60 00 FD D6
F00:4534       							* a0 = pointer, d1 = length
F00:4535       
F00:4536       
F00:4537       *************************************************************************************
F00:4538       *
F00:4539       * perform MID$()
F00:4540       
F00:4541       * enter with a0 is descriptor, d0 & Itemp is word 1
F00:4542       
F00:4543       LAB_MIDS
F00:4544       	MOVEQ		#0,d7				* clear longword
               S01:00E01744:  7E 00
F00:4545       	SUBQ.w	#1,d7				* set default length = 65535
               S01:00E01746:  53 47
F00:4546       	MOVE.l	d0,-(sp)			* save word 1
               S01:00E01748:  2F 00
F00:4547       	BSR		LAB_GBYT			* scan memory
               S01:00E0174A:  61 00 F7 6C
F00:4548       	CMP.b		#',',d0			* was it ","
               S01:00E0174E:  B0 3C 00 2C
F00:4549       	BNE.s		LAB_2358			* branch if not "," (skip second byte get)
               S01:00E01752:  66 0C
F00:4550       
F00:4551       	MOVE.b	(a5)+,d0			* increment pointer past ","
               S01:00E01754:  10 1D
F00:4552       	MOVE.l	a0,-(sp)			* save descriptor pointer
               S01:00E01756:  2F 08
F00:4553       	BSR		LAB_GTWO			* get word parameter, result in d0 and Itemp
               S01:00E01758:  61 00 00 D8
F00:4554       	MOVEA.l	(sp)+,a0			* restore descriptor pointer
               S01:00E0175C:  20 5F
F00:4555       	MOVE.l	d0,d7				* copy length
               S01:00E0175E:  2E 00
F00:4556       LAB_2358
F00:4557       	BSR		LAB_1BFB			* scan for ")", else do syntax error then warm
               S01:00E01760:  61 00 F7 42
F00:4558       							* start
F00:4559       	MOVE.l	(sp)+,d0			* restore word 1
               S01:00E01764:  20 1F
F00:4560       	MOVEQ		#0,d1				* null length
               S01:00E01766:  72 00
F00:4561       	SUBQ.l	#1,d0				* decrement start index (word 1)
               S01:00E01768:  53 80
F00:4562       	BMI		LAB_FCER			* if was null do function call error then warm
               S01:00E0176A:  6B 00 EB 02
F00:4563       							* start
F00:4564       
F00:4565       	CMP.w		4(a0),d0			* compare string length with start index
               S01:00E0176E:  B0 68 00 04
F00:4566       	BCC.s		LAB_231C			* if start not in string do null string (d1=0)
               S01:00E01772:  64 B8
F00:4567       
F00:4568       	MOVE.l	d7,d1				* get length back
               S01:00E01774:  22 07
F00:4569       	ADD.w		d0,d7				* d7 now = MID$() end
               S01:00E01776:  DE 40
F00:4570       	BCS.s		LAB_2368			* already too long so do RIGHT$ equivalent
               S01:00E01778:  65 06
F00:4571       
F00:4572       	CMP.w		4(a0),d7			* compare string length with start index+length
               S01:00E0177A:  BE 68 00 04
F00:4573       	BCS.s		LAB_231C			* if end in string go do string
               S01:00E0177E:  65 AC
F00:4574       
F00:4575       LAB_2368
F00:4576       	MOVE.w	4(a0),d1			* get string length
               S01:00E01780:  32 28 00 04
F00:4577       	SUB.w		d0,d1				* subtract start offset
               S01:00E01784:  92 40
F00:4578       	BRA.s		LAB_231C			* go do string (effectively RIGHT$)
               S01:00E01786:  60 A4
F00:4579       
F00:4580       
F00:4581       *************************************************************************************
F00:4582       *
F00:4583       * perform LCASE$()
F00:4584       
F00:4585       LAB_LCASE
F00:4586       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E01788:  61 00 FF 34
F00:4587       							* returns with d0 = length, a0 = pointer
F00:4588       	MOVE.l	d0,d1				* copy the string length
               S01:00E0178C:  22 00
F00:4589       	BEQ.s		NoString			* if null go return a null string
               S01:00E0178E:  67 56
F00:4590       
F00:4591       * else copy and change the string
F00:4592       
F00:4593       	MOVEA.l	a0,a1				* copy the string address
               S01:00E01790:  22 48
F00:4594       	BSR		LAB_2115			* make a string space d1 bytes long
               S01:00E01792:  61 00 FD 9E
F00:4595       	ADDA.l	d1,a0				* new string end
               S01:00E01796:  D1 C1
F00:4596       	ADDA.l	d1,a1				* old string end
               S01:00E01798:  D3 C1
F00:4597       	MOVE.w	d1,d2				* copy length for loop
               S01:00E0179A:  34 01
F00:4598       	SUBQ.w	#1,d2				* -1 for DBF loop
               S01:00E0179C:  53 42
F00:4599       LC_loop
F00:4600       	MOVE.b	-(a1),d0			* get byte from string
               S01:00E0179E:  10 21
F00:4601       
F00:4602       	CMP.b		#$5B,d0			* compare with "Z"+1
               S01:00E017A0:  B0 3C 00 5B
F00:4603       	BCC.s		NoUcase			* if > "Z" skip change
               S01:00E017A4:  64 0A
F00:4604       
F00:4605       	CMP.b		#$41,d0			* compare with "A"
               S01:00E017A6:  B0 3C 00 41
F00:4606       	BCS.s		NoUcase			* if < "A" skip change
               S01:00E017AA:  65 04
F00:4607       
F00:4608       	ORI.b		#$20,d0			* convert upper case to lower case
               S01:00E017AC:  00 00 00 20
F00:4609       NoUcase
F00:4610       	MOVE.b	d0,-(a0)			* copy upper case byte back to string
               S01:00E017B0:  11 00
F00:4611       	DBF		d2,LC_loop			* decrement and loop if not all done
               S01:00E017B2:  51 CA FF EA
F00:4612       
F00:4613       	BRA.s		NoString			* tidy up & exit (branch always)
               S01:00E017B6:  60 2E
F00:4614       
F00:4615       
F00:4616       *************************************************************************************
F00:4617       *
F00:4618       * perform UCASE$()
F00:4619       
F00:4620       LAB_UCASE
F00:4621       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E017B8:  61 00 FF 04
F00:4622       							* returns with d0 = length, a0 = pointer
F00:4623       	MOVE.l	d0,d1				* copy the string length
               S01:00E017BC:  22 00
F00:4624       	BEQ.s		NoString			* if null go return a null string
               S01:00E017BE:  67 26
F00:4625       
F00:4626       * else copy and change the string
F00:4627       
F00:4628       	MOVEA.l	a0,a1				* copy the string address
               S01:00E017C0:  22 48
F00:4629       	BSR		LAB_2115			* make a string space d1 bytes long
               S01:00E017C2:  61 00 FD 6E
F00:4630       	ADDA.l	d1,a0				* new string end
               S01:00E017C6:  D1 C1
F00:4631       	ADDA.l	d1,a1				* old string end
               S01:00E017C8:  D3 C1
F00:4632       	MOVE.w	d1,d2				* copy length for loop
               S01:00E017CA:  34 01
F00:4633       	SUBQ.w	#1,d2				* -1 for DBF loop
               S01:00E017CC:  53 42
F00:4634       UC_loop
F00:4635       	MOVE.b	-(a1),d0			* get a byte from the string
               S01:00E017CE:  10 21
F00:4636       
F00:4637       	CMP.b		#$61,d0			* compare with "a"
               S01:00E017D0:  B0 3C 00 61
F00:4638       	BCS.s		NoLcase			* if < "a" skip change
               S01:00E017D4:  65 0A
F00:4639       
F00:4640       	CMP.b		#$7B,d0			* compare with "z"+1
               S01:00E017D6:  B0 3C 00 7B
F00:4641       	BCC.s		NoLcase			* if > "z" skip change
               S01:00E017DA:  64 04
F00:4642       
F00:4643       	ANDI.b	#$DF,d0			* convert lower case to upper case
               S01:00E017DC:  02 00 00 DF
F00:4644       NoLcase
F00:4645       	MOVE.b	d0,-(a0)			* copy upper case byte back to string
               S01:00E017E0:  11 00
F00:4646       	DBF		d2,UC_loop			* decrement and loop if not all done
               S01:00E017E2:  51 CA FF EA
F00:4647       
F00:4648       NoString
F00:4649       	BRA		LAB_RTST			* push string on descriptor stack
               S01:00E017E6:  60 00 FD 30
F00:4650       							* a0 = pointer, d1 = length
F00:4651       
F00:4652       
F00:4653       *************************************************************************************
F00:4654       *
F00:4655       * perform SADD()
F00:4656       
F00:4657       LAB_SADD
F00:4658       	MOVE.b	(a5)+,d0			* increment pointer
               S01:00E017EA:  10 1D
F00:4659       	BSR		LAB_GVAR			* get variable address in a0
               S01:00E017EC:  61 00 F8 DE
F00:4660       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E017F0:  61 00 F6 B2
F00:4661       	TST.b		Dtypef(a3)			* test data type flag
               S01:00E017F4:  4A 2B 05 B5
F00:4662       	BPL		LAB_TMER			* if numeric do Type missmatch Error
               S01:00E017F8:  6A 00 EA 54
F00:4663       
F00:4664       * if you want a non existant variable to return a null value then set the novar
F00:4665       * value at the top of this file to some non zero value
F00:4666       
F00:4667        ifne	novar
F00:4668       
F00:4669       	MOVE.l	a0,d0				* test the variable found flag
F00:4670       	BEQ		LAB_AYFC			* if not found go return null
F00:4671       
F00:4672        endc
F00:4673       
F00:4674       	MOVE.l	(a0),d0			* get string address
               S01:00E017FC:  20 10
F00:4675       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E017FE:  60 00 FB BC
F00:4676       
F00:4677       
F00:4678       *************************************************************************************
F00:4679       *
F00:4680       * perform LEN()
F00:4681       
F00:4682       LAB_LENS
F00:4683       	PEA		LAB_AYFC(pc)		* set return address to convert d0 to signed
               S01:00E01802:  48 7A FB B8
F00:4684       							* longword in FAC1
F00:4685       	BRA		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E01806:  60 00 FE B6
F00:4686       							* returns with d0 = length, a0 = pointer
F00:4687       
F00:4688       
F00:4689       *************************************************************************************
F00:4690       *
F00:4691       * perform ASC()
F00:4692       
F00:4693       LAB_ASC
F00:4694       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E0180A:  61 00 FE B2
F00:4695       							* returns with d0 = length, a0 = pointer
F00:4696       	TST.w		d0				* test length
               S01:00E0180E:  4A 40
F00:4697       	BEQ		LAB_FCER			* if null do function call error then warm start
               S01:00E01810:  67 00 EA 5C
F00:4698       
F00:4699       	MOVE.b	(a0),d0			* get first character byte
               S01:00E01814:  10 10
F00:4700       	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
               S01:00E01816:  60 00 FB C4
F00:4701       
F00:4702       
F00:4703       *************************************************************************************
F00:4704       *
F00:4705       * increment and get byte, result in d0 and Itemp
F00:4706       
F00:4707       LAB_SGBY
F00:4708       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E0181A:  61 00 F6 9A
F00:4709       
F00:4710       
F00:4711       *************************************************************************************
F00:4712       *
F00:4713       * get byte parameter, result in d0 and Itemp
F00:4714       
F00:4715       LAB_GTBY
F00:4716       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E0181E:  61 00 F5 1E
F00:4717       							* else do type mismatch
F00:4718       
F00:4719       
F00:4720       *************************************************************************************
F00:4721       *
F00:4722       * evaluate byte expression, result in d0 and Itemp
F00:4723       
F00:4724       LAB_EVBY
F00:4725       	BSR		LAB_EVPI			* evaluate positive integer expression
               S01:00E01822:  61 00 F9 DC
F00:4726       							* result in d0 and Itemp
F00:4727       	MOVEQ		#$80,d1			* set mask/2
               S01:00E01826:  72 80
F00:4728       	ADD.l		d1,d1				* =$FFFFFF00
               S01:00E01828:  D2 81
F00:4729       	AND.l		d0,d1				* check top 24 bits
               S01:00E0182A:  C2 80
F00:4730       	BNE		LAB_FCER			* if <> 0 do function call error/warm start
               S01:00E0182C:  66 00 EA 40
F00:4731       
F00:4732       	RTS
               S01:00E01830:  4E 75
F00:4733       
F00:4734       
F00:4735       *************************************************************************************
F00:4736       *
F00:4737       * get word parameter, result in d0 and Itemp
F00:4738       
F00:4739       LAB_GTWO
F00:4740       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E01832:  61 00 F5 0A
F00:4741       							* else do type mismatch
F00:4742       	BSR		LAB_EVPI			* evaluate positive integer expression
               S01:00E01836:  61 00 F9 C8
F00:4743       							* result in d0 and Itemp
F00:4744       	SWAP		d0				* copy high word to low word
               S01:00E0183A:  48 40
F00:4745       	TST.w		d0				* set flags
               S01:00E0183C:  4A 40
F00:4746       	BNE		LAB_FCER			* if <> 0 do function call error/warm start
               S01:00E0183E:  66 00 EA 2E
F00:4747       
F00:4748       	SWAP		d0				* copy high word to low word
               S01:00E01842:  48 40
F00:4749       	RTS
               S01:00E01844:  4E 75
F00:4750       
F00:4751       
F00:4752       *************************************************************************************
F00:4753       *
F00:4754       * perform VAL()
F00:4755       
F00:4756       LAB_VAL
F00:4757       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E01846:  61 00 FE 76
F00:4758       							* returns with d0 = length, a0 = pointer
F00:4759       	BEQ.s		LAB_VALZ			* string was null so set result = $00
               S01:00E0184A:  67 22
F00:4760       							* clear FAC1 exponent & sign & return
F00:4761       
F00:4762       	MOVEA.l	a5,a6				* save BASIC execute pointer
               S01:00E0184C:  2C 4D
F00:4763       	MOVEA.l	a0,a5				* copy string pointer to execute pointer
               S01:00E0184E:  2A 48
F00:4764       	ADDA.l	d0,a0				* string end+1
               S01:00E01850:  D1 C0
F00:4765       	MOVE.b	(a0),d0			* get byte from string+1
               S01:00E01852:  10 10
F00:4766       	MOVE.w	d0,-(sp)			* save it
               S01:00E01854:  3F 00
F00:4767       	MOVE.l	a0,-(sp)			* save address
               S01:00E01856:  2F 08
F00:4768       	MOVE.b	#0,(a0)			* null terminate string
               S01:00E01858:  10 BC 00 00
F00:4769       	BSR		LAB_GBYT			* scan memory
               S01:00E0185C:  61 00 F6 5A
F00:4770       	BSR		LAB_2887			* get FAC1 from string
               S01:00E01860:  61 00 13 4A
F00:4771       	MOVEA.l	(sp)+,a0			* restore pointer
               S01:00E01864:  20 5F
F00:4772       	MOVE.w	(sp)+,d0			* pop byte
               S01:00E01866:  30 1F
F00:4773       	MOVE.b	d0,(a0)			* restore to memory
               S01:00E01868:  10 80
F00:4774       	MOVEA.l	a6,a5				* restore BASIC execute pointer
               S01:00E0186A:  2A 4E
F00:4775       	RTS
               S01:00E0186C:  4E 75
F00:4776       
F00:4777       LAB_VALZ
F00:4778       	MOVE.w	d0,FAC1_e(a3)		* clear FAC1 exponent & sign
               S01:00E0186E:  37 40 05 94
F00:4779       	RTS
               S01:00E01872:  4E 75
F00:4780       
F00:4781       
F00:4782       *************************************************************************************
F00:4783       *
F00:4784       * get two parameters for POKE or WAIT, first parameter in a0, second in d0
F00:4785       
F00:4786       LAB_GADB
F00:4787       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E01874:  61 00 F4 C8
F00:4788       							* else do type mismatch
F00:4789       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E01878:  61 00 F9 8E
F00:4790       							* (does FC error not OF error if out of range)
F00:4791       	MOVE.l	d0,-(sp)			* copy to stack
               S01:00E0187C:  2F 00
F00:4792       	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
               S01:00E0187E:  61 00 F6 2C
F00:4793       	BSR.s		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E01882:  61 9A
F00:4794       	MOVEA.l	(sp)+,a0			* pull address
               S01:00E01884:  20 5F
F00:4795       	RTS
               S01:00E01886:  4E 75
F00:4796       
F00:4797       
F00:4798       *************************************************************************************
F00:4799       *
F00:4800       * get two parameters for DOKE or WAITW, first parameter in a0, second in d0
F00:4801       
F00:4802       LAB_GADW
F00:4803       	BSR.s		LAB_GEAD			* get even address for word/long memory actions
               S01:00E01888:  61 1E
F00:4804       							* address returned in d0 and on the stack
F00:4805       	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
               S01:00E0188A:  61 00 F6 20
F00:4806       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E0188E:  61 00 F4 AE
F00:4807       							* else do type mismatch
F00:4808       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E01892:  61 00 F9 74
F00:4809       							* result in d0 and Itemp
F00:4810       	SWAP		d0				* swap words
               S01:00E01896:  48 40
F00:4811       	TST.w		d0				* test high word
               S01:00E01898:  4A 40
F00:4812       	BEQ.s		LAB_XGADW			* exit if null
               S01:00E0189A:  67 06
F00:4813       
F00:4814       	ADDQ.w	#1,d0				* increment word
               S01:00E0189C:  52 40
F00:4815       	BNE		LAB_FCER			* if <> 0 do function call error/warm start
               S01:00E0189E:  66 00 E9 CE
F00:4816       
F00:4817       LAB_XGADW
F00:4818       	SWAP		d0				* swap words back
               S01:00E018A2:  48 40
F00:4819       	MOVEA.l	(sp)+,a0			* pull address
               S01:00E018A4:  20 5F
F00:4820       	RTS
               S01:00E018A6:  4E 75
F00:4821       
F00:4822       
F00:4823       *************************************************************************************
F00:4824       *
F00:4825       * get even address (for word or longword memory actions)
F00:4826       * address returned in d0 and on the stack
F00:4827       * does address error if the address is odd
F00:4828       
F00:4829       LAB_GEAD
F00:4830       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E018A8:  61 00 F4 94
F00:4831       							* else do type mismatch
F00:4832       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E018AC:  61 00 F9 5A
F00:4833       							* (does FC error not OF error if out of range)
F00:4834       	BTST		#0,d0				* test low bit of longword
               S01:00E018B0:  08 00 00 00
F00:4835       	BNE		LAB_ADER			* if address is odd do address error/warm start
               S01:00E018B4:  66 00 E9 74
F00:4836       
F00:4837       	MOVEA.l	(sp),a0			* copy return address
               S01:00E018B8:  20 57
F00:4838       	MOVE.l	d0,(sp)			* even address on stack
               S01:00E018BA:  2E 80
F00:4839       	JMP		(a0)				* effectively RTS
               S01:00E018BC:  4E D0
F00:4840       
F00:4841       
F00:4842       *************************************************************************************
F00:4843       *
F00:4844       * perform PEEK()
F00:4845       
F00:4846       LAB_PEEK
F00:4847       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E018BE:  61 00 F9 48
F00:4848       							* (does FC error not OF error if out of range)
F00:4849       	MOVEA.l	d0,a0				* copy to address register
               S01:00E018C2:  20 40
F00:4850       	MOVE.b	(a0),d0			* get byte
               S01:00E018C4:  10 10
F00:4851       	BRA		LAB_1FD0			* convert d0 to unsigned byte in FAC1 & return
               S01:00E018C6:  60 00 FB 14
F00:4852       
F00:4853       
F00:4854       *************************************************************************************
F00:4855       *
F00:4856       * perform POKE
F00:4857       
F00:4858       LAB_POKE
F00:4859       	BSR.s		LAB_GADB			* get two parameters for POKE or WAIT
               S01:00E018CA:  61 A8
F00:4860       							* first parameter in a0, second in d0
F00:4861       	MOVE.b	d0,(a0)			* put byte in memory
               S01:00E018CC:  10 80
F00:4862       	RTS
               S01:00E018CE:  4E 75
F00:4863       
F00:4864       
F00:4865       *************************************************************************************
F00:4866       *
F00:4867       * perform DEEK()
F00:4868       
F00:4869       LAB_DEEK
F00:4870       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E018D0:  61 00 F9 36
F00:4871       							* (does FC error not OF error if out of range)
F00:4872       	LSR.b		#1,d0				* shift bit 0 to carry
               S01:00E018D4:  E2 08
F00:4873       	BCS		LAB_ADER			* if address is odd do address error/warm start
               S01:00E018D6:  65 00 E9 52
F00:4874       
F00:4875       	ADD.b		d0,d0				* shift byte back
               S01:00E018DA:  D0 00
F00:4876       	EXG		d0,a0				* copy to address register
               S01:00E018DC:  C1 88
F00:4877       	MOVEQ		#0,d0				* clear top bits
               S01:00E018DE:  70 00
F00:4878       	MOVE.w	(a0),d0			* get word
               S01:00E018E0:  30 10
F00:4879       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E018E2:  60 00 FA D8
F00:4880       
F00:4881       
F00:4882       *************************************************************************************
F00:4883       *
F00:4884       * perform LEEK()
F00:4885       
F00:4886       LAB_LEEK
F00:4887       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E018E6:  61 00 F9 20
F00:4888       							* (does FC error not OF error if out of range)
F00:4889       	LSR.b		#1,d0				* shift bit 0 to carry
               S01:00E018EA:  E2 08
F00:4890       	BCS		LAB_ADER			* if address is odd do address error/warm start
               S01:00E018EC:  65 00 E9 3C
F00:4891       
F00:4892       	ADD.b		d0,d0				* shift byte back
               S01:00E018F0:  D0 00
F00:4893       	EXG		d0,a0				* copy to address register
               S01:00E018F2:  C1 88
F00:4894       	MOVE.l	(a0),d0			* get longword
               S01:00E018F4:  20 10
F00:4895       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E018F6:  60 00 FA C4
F00:4896       
F00:4897       
F00:4898       *************************************************************************************
F00:4899       *
F00:4900       * perform DOKE
F00:4901       
F00:4902       LAB_DOKE
F00:4903       	BSR.s		LAB_GADW			* get two parameters for DOKE or WAIT
               S01:00E018FA:  61 8C
F00:4904       							* first parameter in a0, second in d0
F00:4905       	MOVE.w	d0,(a0)			* put word in memory
               S01:00E018FC:  30 80
F00:4906       	RTS
               S01:00E018FE:  4E 75
F00:4907       
F00:4908       
F00:4909       *************************************************************************************
F00:4910       *
F00:4911       * perform LOKE
F00:4912       
F00:4913       LAB_LOKE
F00:4914       	BSR.s		LAB_GEAD			* get even address for word/long memory actions
               S01:00E01900:  61 A6
F00:4915       							* address returned in d0 and on the stack
F00:4916       	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
               S01:00E01902:  61 00 F5 A8
F00:4917       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E01906:  61 00 F4 36
F00:4918       							* else do type mismatch
F00:4919       	BSR		LAB_EVIR			* evaluate integer value (no sign check)
               S01:00E0190A:  61 00 F8 FC
F00:4920       	MOVEA.l	(sp)+,a0			* pull address
               S01:00E0190E:  20 5F
F00:4921       	MOVE.l	d0,(a0)			* put longword in memory
               S01:00E01910:  20 80
F00:4922       RTS_015
F00:4923       	RTS
               S01:00E01912:  4E 75
F00:4924       
F00:4925       
F00:4926       *************************************************************************************
F00:4927       *
F00:4928       * perform SWAP
F00:4929       
F00:4930       LAB_SWAP
F00:4931       	BSR		LAB_GVAR			* get variable 1 address in a0
               S01:00E01914:  61 00 F7 B6
F00:4932       	MOVE.l	a0,-(sp)			* save variable 1 address
               S01:00E01918:  2F 08
F00:4933       	MOVE.b	Dtypef(a3),d4		* copy variable 1 data type, $80=string,
               S01:00E0191A:  18 2B 05 B5
F00:4934       							* $40=inetger, $00=float
F00:4935       
F00:4936       	BSR		LAB_1C01			* scan for ",", else do syntax error/warm start
               S01:00E0191E:  61 00 F5 8C
F00:4937       	BSR		LAB_GVAR			* get variable 2 address in a0
               S01:00E01922:  61 00 F7 A8
F00:4938       	MOVEA.l	(sp)+,a2			* restore variable 1 address
               S01:00E01926:  24 5F
F00:4939       	CMP.b		Dtypef(a3),d4		* compare variable 1 data type with variable 2
               S01:00E01928:  B8 2B 05 B5
F00:4940       							* data type
F00:4941       	BNE		LAB_TMER			* if not both the same type do "Type mismatch"
               S01:00E0192C:  66 00 E9 20
F00:4942       							* error then warm start
F00:4943       
F00:4944       * if you do want a non existant variable to return an error then leave the novar
F00:4945       * value at the top of this file set to zero
F00:4946       
F00:4947        ifeq	novar
F00:4948       
F00:4949       	MOVE.l	(a0),d0			* get variable 2
               S01:00E01930:  20 10
F00:4950       	MOVE.l	(a2),(a0)+			* copy variable 1 to variable 2
               S01:00E01932:  20 D2
F00:4951       	MOVE.l	d0,(a2)+			* save variable 2 to variable 1
               S01:00E01934:  24 C0
F00:4952       
F00:4953       	TST.b		d4				* check data type
               S01:00E01936:  4A 04
F00:4954       	BPL.s		RTS_015			* exit if not string
               S01:00E01938:  6A D8
F00:4955       
F00:4956       	MOVE.w	(a0),d0			* get string 2 length
               S01:00E0193A:  30 10
F00:4957       	MOVE.w	(a2),(a0)			* copy string 1 length to string 2 length
               S01:00E0193C:  30 92
F00:4958       	MOVE.w	d0,(a2)			* save string 2 length to string 1 length
               S01:00E0193E:  34 80
F00:4959       
F00:4960        endc
F00:4961       
F00:4962       
F00:4963       * if you want a non existant variable to return a null value then set the novar
F00:4964       * value at the top of this file to some non zero value
F00:4965       
F00:4966        ifne	novar
F00:4967       
F00:4968       	MOVE.l	a2,d2				* copy the variable 1 pointer
F00:4969       	MOVE.l	d2,d3				* and again for any length
F00:4970       	BEQ.s		no_variable1		* if variable 1 doesn't exist skip the
F00:4971       							* value get
F00:4972       
F00:4973       	MOVE.l	(a2),d2			* get variable 1 value
F00:4974       	TST.b		d4				* check the data type
F00:4975       	BPL.s		no_variable1		* if not string skip the length get
F00:4976       
F00:4977       	MOVE.w	4(a2),d3			* else get variable 1 string length
F00:4978       no_variable1
F00:4979       	MOVE.l	a0,d0				* copy the variable 2 pointer
F00:4980       	MOVE.l	d0,d1				* and again for any length
F00:4981       	BEQ.s		no_variable2		* if variable 2 doesn't exist skip the
F00:4982       							* value get and the new value save
F00:4983       
F00:4984       	MOVE.l	(a0),d0			* get variable 2 value
F00:4985       	MOVE.l	d2,(a0)+			* save variable 2 new value
F00:4986       	TST.b		d4				* check the data type
F00:4987       	BPL.s		no_variable2		* if not string skip the length get and
F00:4988       							* new length save
F00:4989       
F00:4990       	MOVE.w	(a0),d1			* else get variable 2 string length
F00:4991       	MOVE.w	d3,(a0)			* save variable 2 new string length
F00:4992       no_variable2
F00:4993       	TST.l		d2				* test if variable 1 exists
F00:4994       	BEQ.s		EXIT_SWAP			* if variable 1 doesn't exist skip the
F00:4995       							* new value save
F00:4996       
F00:4997       	MOVE.l	d0,(a2)+			* save variable 1 new value
F00:4998       	TST.b		d4				* check the data type
F00:4999       	BPL.s		EXIT_SWAP			* if not string skip the new length save
F00:5000       
F00:5001       	MOVE.w	d1,(a2)			* save variable 1 new string length
F00:5002       EXIT_SWAP
F00:5003       
F00:5004        endc
F00:5005       
F00:5006       	RTS
               S01:00E01940:  4E 75
F00:5007       
F00:5008       
F00:5009       *************************************************************************************
F00:5010       *
F00:5011       * perform USR
F00:5012       
F00:5013       LAB_USR
F00:5014       	JSR		Usrjmp(a3)			* do user vector
               S01:00E01942:  4E AB 04 06
F00:5015       	BRA		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E01946:  60 00 F5 5C
F00:5016       
F00:5017       
F00:5018       *************************************************************************************
F00:5019       *
F00:5020       * perform LOAD
F00:5021       
F00:5022       LAB_LOAD
F00:5023       	JMP		V_LOAD(a3)			* do the load vector 
               S01:00E0194A:  4E EB 04 18
F00:5024       
F00:5025       
F00:5026       *************************************************************************************
F00:5027       *
F00:5028       * perform SAVE
F00:5029       
F00:5030       LAB_SAVE
F00:5031       	JMP		V_SAVE(a3)			* do the save vector
               S01:00E0194E:  4E EB 04 1E
F00:5032       
F00:5033       
F00:5034       *************************************************************************************
F00:5035       *
F00:5036       * perform CALL
F00:5037       
F00:5038       LAB_CALL
F00:5039       	PEA		LAB_GBYT(pc)		* put return address on stack
               S01:00E01952:  48 7A F5 64
F00:5040       	BSR		LAB_GEAD			* get even address for word/long memory actions
               S01:00E01956:  61 00 FF 50
F00:5041       							* address returned in d0 and on the stack
F00:5042       	RTS						* effectively calls the routine
               S01:00E0195A:  4E 75
F00:5043       
F00:5044       * if the called routine exits correctly then it will return via the get byte routine.
F00:5045       * this will then get the next byte for the interpreter and return
F00:5046       
F00:5047       
F00:5048       *************************************************************************************
F00:5049       *
F00:5050       * perform WAIT
F00:5051       
F00:5052       LAB_WAIT
F00:5053       	BSR		LAB_GADB			* get two parameters for POKE or WAIT
               S01:00E0195C:  61 00 FF 16
F00:5054       							* first parameter in a0, second in d0
F00:5055       	MOVE.l	a0,-(sp)			* save address
               S01:00E01960:  2F 08
F00:5056       	MOVE.w	d0,-(sp)			* save byte
               S01:00E01962:  3F 00
F00:5057       	MOVEQ		#0,d2				* clear mask
               S01:00E01964:  74 00
F00:5058       	BSR		LAB_GBYT			* scan memory
               S01:00E01966:  61 00 F5 50
F00:5059       	BEQ.s		LAB_2441			* skip if no third argument
               S01:00E0196A:  67 06
F00:5060       
F00:5061       	BSR		LAB_SCGB			* scan for "," & get byte,
               S01:00E0196C:  61 00 F5 3A
F00:5062       							* else do syntax error/warm start
F00:5063       	MOVE.l	d0,d2				* copy mask
               S01:00E01970:  24 00
F00:5064       LAB_2441
F00:5065       	MOVE.w	(sp)+,d1			* get byte
               S01:00E01972:  32 1F
F00:5066       	MOVEA.l	(sp)+,a0			* get address
               S01:00E01974:  20 5F
F00:5067       LAB_2445
F00:5068       	MOVE.b	(a0),d0			* read memory byte
               S01:00E01976:  10 10
F00:5069       	EOR.b		d2,d0				* EOR with second argument (mask)
               S01:00E01978:  B5 00
F00:5070       	AND.b		d1,d0				* AND with first argument (byte)
               S01:00E0197A:  C0 01
F00:5071       	BEQ.s		LAB_2445			* loop if result is zero
               S01:00E0197C:  67 F8
F00:5072       
F00:5073       	RTS
               S01:00E0197E:  4E 75
F00:5074       
F00:5075       *************************************************************************************
F00:5076       * EASy68k extension function										*
F00:5077       *************************************************************************************
F00:5078       *
F00:5079       * perform TI
F00:5080       
F00:5081       LAB_TI
F00:5082       	;MOVEQ		#8,d0				* get time
F00:5083       	;TRAP		#15				* do I/O function
F00:5084       	MOVE.l	d1,FAC1_m(a3)		* time (in 100ths seconds) into FAC1
               S01:00E01980:  27 41 05 90
F00:5085       	MOVE.w	#$A000,FAC1_e(a3)		* time exponent and sign
               S01:00E01984:  37 7C A0 00 05 94
F00:5086       	BRA		LAB_24D5			* normalise FAC1 & return
               S01:00E0198A:  60 00 02 96
F00:5087       
F00:5088       
F00:5089       *************************************************************************************
F00:5090       *
F00:5091       * perform KEYS()
F00:5092       
F00:5093       LAB_KEYS
F00:5094       	TST.b		Dtypef(a3)			* test data type, $80=string, $40=integer,
               S01:00E0198E:  4A 2B 05 B5
F00:5095       							* $00=float
F00:5096       	BMI.s		LAB_KESS			* branch if string
               S01:00E01992:  6B 12
F00:5097       
F00:5098       	BSR		LAB_EVIR			* evaluate integer expression (no sign check)
               S01:00E01994:  61 00 F8 72
F00:5099       							* result in d0 and Itemp
F00:5100       LAB_KEZZ
F00:5101       	MOVE.l	d0,d1				* copy key value to parameter
               S01:00E01998:  22 00
F00:5102       LAB_KETT
F00:5103       	MOVE.b	#19,d0			* check for keypress
               S01:00E0199A:  10 3C 00 13
F00:5104       	TRAP		#15
               S01:00E0199E:  4E 4F
F00:5105       
F00:5106       	MOVE.l	d1,d0				* copy result
               S01:00E019A0:  20 01
F00:5107       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E019A2:  60 00 FA 18
F00:5108       
F00:5109       LAB_KESS
F00:5110       	BSR		LAB_22B6			* pop string off descriptor stack or from memory
               S01:00E019A6:  61 00 FD 16
F00:5111       							* returns with d0 = length, a0 = pointer
F00:5112       	BEQ		LAB_KEZZ			* return last key if null string
               S01:00E019AA:  67 EC
F00:5113       
F00:5114       	CMP.w		#5,d0				* compare length with max+1
               S01:00E019AC:  B0 7C 00 05
F00:5115       	BCS.s		LAB_KKSS			* branch if <= 4
               S01:00E019B0:  65 02
F00:5116       
F00:5117       	MOVEQ		#4,d0				* else make = 4
               S01:00E019B2:  70 04
F00:5118       LAB_KKSS
F00:5119       	MOVEQ		#0,d1				* clear parameter
               S01:00E019B4:  72 00
F00:5120       	SUBQ.w	#1,d0				* -1 for BF loop
               S01:00E019B6:  53 40
F00:5121       LAB_KSSS
F00:5122       	ASL.l		#8,d1				* shift any previous characters along
               S01:00E019B8:  E1 81
F00:5123       	MOVE.b	(a0)+,d1			* get byte from string
               S01:00E019BA:  12 18
F00:5124       	DBF		d0,LAB_KSSS			* decrement count and loop if not done yet
               S01:00E019BC:  51 C8 FF FA
F00:5125       
F00:5126       	BRA.s		LAB_KETT			* go test the keys
               S01:00E019C0:  60 D8
F00:5127       
F00:5128       
F00:5129       *************************************************************************************
F00:5130       
F00:5131       *************************************************************************************
F00:5132       * EASy68k graphics extension function								*
F00:5133       *************************************************************************************
F00:5134       *
F00:5135       * perform POINT(X,Y) function
F00:5136       
F00:5137       LAB_FPOINT
F00:5138       	MOVE.b	(a5)+,d0			* increment BASIC execute pointer
               S01:00E019C2:  10 1D
F00:5139       							* fastest/shortest method
F00:5140       	MOVEQ		#$28,d0			* load d0 with "("
               S01:00E019C4:  70 28
F00:5141       	BSR		LAB_SCCA			* scan for "(", else do syntax error/warm start
               S01:00E019C6:  61 00 F4 E6
F00:5142       	BSR.s		LAB_GTSW			* get X co-ordinate
               S01:00E019CA:  61 1A
F00:5143       	MOVE.l	d0,-(sp)			* save X co-ordinate
               S01:00E019CC:  2F 00
F00:5144       	BSR		LAB_1C01			* scan for "," else do syntax error/warm start
               S01:00E019CE:  61 00 F4 DC
F00:5145       	BSR.s		LAB_GTSW			* get Y co-ordinate
               S01:00E019D2:  61 12
F00:5146       	MOVE.l	d0,-(sp)			* save Y co-ordinate
               S01:00E019D4:  2F 00
F00:5147       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E019D6:  61 00 F4 CC
F00:5148       	MOVE.l	(sp)+,d2			* restore Y co-ordinate
               S01:00E019DA:  24 1F
F00:5149       	MOVE.l	(sp)+,d1			* restore X co-ordinate
               S01:00E019DC:  22 1F
F00:5150       	MOVEQ		#83,d0			* read pixel colour
               S01:00E019DE:  70 53
F00:5151       	TRAP		#15				* do I/O function
               S01:00E019E0:  4E 4F
F00:5152       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & RET
               S01:00E019E2:  60 00 F9 D8
F00:5153       
F00:5154       *************************************************************************************
F00:5155       * EASy68k graphics extension commands								*
F00:5156       *************************************************************************************
F00:5157       
F00:5158       * get signed word parameter, result in d0 and Itemp
F00:5159       
F00:5160       LAB_GTSW
F00:5161       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E019E6:  61 00 F3 56
F00:5162       							* else do type mismatch
F00:5163       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E019EA:  61 00 F8 1C
F00:5164       							* result in d0 and Itemp
F00:5165       
F00:5166       
F00:5167       *************************************************************************************
F00:5168       *
F00:5169       * test signed word parameter in d0, must be -32769 < value < 32768
F00:5170       
F00:5171       LAB_EVSW
F00:5172       	SWAP		d0				* copy high word to low word
               S01:00E019EE:  48 40
F00:5173       	TST.w		d0				* set flags
               S01:00E019F0:  4A 40
F00:5174       	BEQ		LAB_ISWD			* branch if -1 < value < 32768
               S01:00E019F2:  67 06
F00:5175       
F00:5176       	ADDQ.w	#1,d0				* else check $FFFF
               S01:00E019F4:  52 40
F00:5177       	BNE		LAB_FCER			* if <> 0 do function call error/warm start
               S01:00E019F6:  66 00 E8 76
F00:5178       
F00:5179       LAB_ISWD
F00:5180       	SWAP		d0				* copy high word to low word
               S01:00E019FA:  48 40
F00:5181       	RTS
               S01:00E019FC:  4E 75
F00:5182       
F00:5183       
F00:5184       *************************************************************************************
F00:5185       *
F00:5186       * get graphics parameters, return count in d1.w
F00:5187       * numeric parameters are evaluated and stacked until the command end or an
F00:5188       * error is detected. the parameters are all long integers
F00:5189       
F00:5190       LAB_GGPR
F00:5191       	MOVEQ		#0,d1				* clear parameter count
               S01:00E019FE:  72 00
F00:5192       LAB_GGLP
F00:5193       	MOVE.w	d1,-(sp)			* save parameter count
               S01:00E01A00:  3F 01
F00:5194       	BSR		LAB_EVNM			* evaluate expression & check is numeric,
               S01:00E01A02:  61 00 F3 3A
F00:5195       							* else do type mismatch
F00:5196       	BSR		LAB_EVIR			* evaluate integer expression
               S01:00E01A06:  61 00 F8 00
F00:5197       							* result in d0 and Itemp
F00:5198       	MOVE.w	(sp)+,d1			* get parameter count
               S01:00E01A0A:  32 1F
F00:5199       	MOVE.l	(sp),d2			* copy return address
               S01:00E01A0C:  24 17
F00:5200       	MOVE.l	d0,(sp)			* save parameter
               S01:00E01A0E:  2E 80
F00:5201       	MOVE.l	d2,-(sp)			* save return address
               S01:00E01A10:  2F 02
F00:5202       	ADDQ.w	#1,d1				* increment parameter count
               S01:00E01A12:  52 41
F00:5203       	BSR		LAB_GBYT			* get BASIC byte
               S01:00E01A14:  61 00 F4 A2
F00:5204       	BEQ		LAB_GGEX			* no more parameters so exit
               S01:00E01A18:  67 0E
F00:5205       
F00:5206       	CMP.b		#',',d0			* check next byte is ","
               S01:00E01A1A:  B0 3C 00 2C
F00:5207       	BNE		LAB_SNER			* do error if not
               S01:00E01A1E:  66 00 E8 5A
F00:5208       
F00:5209       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E01A22:  61 00 F4 92
F00:5210       	BRA.s		LAB_GGLP			* go get next parameter
               S01:00E01A26:  60 D8
F00:5211       
F00:5212       LAB_GGEX
F00:5213       	RTS
               S01:00E01A28:  4E 75
F00:5214       
F00:5215       
F00:5216       *************************************************************************************
F00:5217       *
F00:5218       * set line colour d0
F00:5219       
F00:5220       LAB_SLCO
F00:5221       	MOVE.w	d1,-(sp)			* save parameter count
               S01:00E01A2A:  3F 01
F00:5222       	MOVE.l	#$FFFFFF,d1			* set mask
               S01:00E01A2C:  22 3C 00 FF FF FF
F00:5223       	AND.l		d0,d1				* and line colour
               S01:00E01A32:  C2 80
F00:5224       	MOVEQ		#80,d0			* set pen colour
               S01:00E01A34:  70 50
F00:5225       	TRAP		#15				* do I/O function
               S01:00E01A36:  4E 4F
F00:5226       	MOVE.w	(sp)+,d1			* get parameter count back
               S01:00E01A38:  32 1F
F00:5227       	RTS
               S01:00E01A3A:  4E 75
F00:5228       
F00:5229       
F00:5230       *************************************************************************************
F00:5231       *
F00:5232       * set fill colour d0
F00:5233       
F00:5234       LAB_SFCO
F00:5235       	MOVE.w	d1,-(sp)			* save parameter count
               S01:00E01A3C:  3F 01
F00:5236       	MOVE.l	#$FFFFFF,d1			* set mask
               S01:00E01A3E:  22 3C 00 FF FF FF
F00:5237       	AND.l		d0,d1				* and line colour
               S01:00E01A44:  C2 80
F00:5238       	MOVEQ		#81,d0			* set pen colour
               S01:00E01A46:  70 51
F00:5239       	TRAP		#15				* do I/O function
               S01:00E01A48:  4E 4F
F00:5240       	MOVE.w	(sp)+,d1			* get parameter count back
               S01:00E01A4A:  32 1F
F00:5241       	RTS
               S01:00E01A4C:  4E 75
F00:5242       
F00:5243       
F00:5244       *************************************************************************************
F00:5245       *
F00:5246       * perform LINE [[X1,Y1],X2,Y2][,][LINE_COLOUR]
F00:5247       
F00:5248       LAB_LINE
F00:5249       	MOVEQ		#85,d0			* default to draw line to X1,Y1
               S01:00E01A4E:  70 55
F00:5250       	MOVE.l	d0,-(sp)			* set line type
               S01:00E01A50:  2F 00
F00:5251       
F00:5252       	BSR		LAB_GGPR			* get graphics parameters, return count in d1.w
               S01:00E01A52:  61 AA
F00:5253       	BTST		#0,d1				* test parameter count
               S01:00E01A54:  08 01 00 00
F00:5254       	BEQ		LAB_LNCO			* branch if no line colour parameter
               S01:00E01A58:  67 0A
F00:5255       
F00:5256       	MOVE.l	(sp)+,d0			* get line colour
               S01:00E01A5A:  20 1F
F00:5257       	BSR		LAB_SLCO			* go mask & set line colour
               S01:00E01A5C:  61 CC
F00:5258       	SUBQ.w	#1,d1				* decrement parameter count
               S01:00E01A5E:  53 41
F00:5259       	BEQ		LAB_SRTS			* exit if all done
               S01:00E01A60:  67 00 00 AE
F00:5260       
F00:5261       							* parameter count is always even here
F00:5262       LAB_LNCO
F00:5263       	SUBQ.w	#2,d1				* subtract 2 from parameter count
               S01:00E01A64:  55 41
F00:5264       	BEQ		LAB_S1XY			* go do line to X,Y if only two parameters left
               S01:00E01A66:  67 00 00 92
F00:5265       
F00:5266       	SUBQ.w	#2,d1				* subtract 2 from parameter count
               S01:00E01A6A:  55 41
F00:5267       	BNE		LAB_SNER			* do error if there are other than two
               S01:00E01A6C:  66 00 E8 0C
F00:5268       							* parameters left
F00:5269       
F00:5270       	MOVEQ		#84,d0			* draw line from X1,Y1 to X2,Y2
               S01:00E01A70:  70 54
F00:5271       	MOVE.w	d0,$12(sp)			* set line type (write over line to X1,Y1 type)
               S01:00E01A72:  3F 40 00 12
F00:5272       	BRA		LAB_S2XY			* go pop X1,Y1,X2,Y2 and do line
               S01:00E01A76:  60 72
F00:5273       
F00:5274       
F00:5275       *************************************************************************************
F00:5276       *
F00:5277       * perform MOVE X,Y
F00:5278       
F00:5279       LAB_MOVE
F00:5280       	MOVEQ		#86,d0			* move to x,y
               S01:00E01A78:  70 56
F00:5281       	MOVE.l	d0,-(sp)			* save pixel type
               S01:00E01A7A:  2F 00
F00:5282       
F00:5283       	BSR		LAB_GGPR			* get graphics parameters, return count in d1.w
               S01:00E01A7C:  61 80
F00:5284       	BRA.s		LAB_PNCE			* go check only two parameters and do move
               S01:00E01A7E:  60 2C
F00:5285       
F00:5286       
F00:5287       *************************************************************************************
F00:5288       *
F00:5289       * perform POINT [X,Y][,][LINE_COLOUR]
F00:5290       
F00:5291       LAB_POINT
F00:5292       	MOVEQ		#82,d0			* set point
               S01:00E01A80:  70 52
F00:5293       	BRA.s		LAB_pixel			* go do pixel command
               S01:00E01A82:  60 02
F00:5294       
F00:5295       
F00:5296       *************************************************************************************
F00:5297       *
F00:5298       * perform FILL [X,Y][,][FILL_COLOUR]
F00:5299       
F00:5300       LAB_FILL
F00:5301       	MOVEQ		#89,d0			* flood fill
               S01:00E01A84:  70 59
F00:5302       *	BRA.s		LAB_pixel			* go do pixel command
F00:5303       
F00:5304       * do POINT or FILL pixel based commands
F00:5305       
F00:5306       LAB_pixel
F00:5307       	MOVE.l	d0,-(sp)			* save pixel type
               S01:00E01A86:  2F 00
F00:5308       
F00:5309       	BSR		LAB_GGPR			* get graphics parameters, return count in d1.w
               S01:00E01A88:  61 00 FF 74
F00:5310       	BTST		#0,d1				* test parameter count
               S01:00E01A8C:  08 01 00 00
F00:5311       	BEQ		LAB_PNCE			* branch if no line colour parameter
               S01:00E01A90:  67 1A
F00:5312       
F00:5313       	MOVE.l	(sp)+,d0			* get line colour
               S01:00E01A92:  20 1F
F00:5314       	MOVE.w	d1,d2				* copy count
               S01:00E01A94:  34 01
F00:5315       	ADD.w		d2,d2				* *2
               S01:00E01A96:  D4 42
F00:5316       	ADD.w		d2,d2				* *4
               S01:00E01A98:  D4 42
F00:5317       	BTST		#0,-1(sp,d2.w)		* test point or fill
               S01:00E01A9A:  08 37 00 00 20 FF
F00:5318       	BEQ.s		LAB_SELC			* branch if line
               S01:00E01AA0:  67 04
F00:5319       	
F00:5320       	BSR		LAB_SFCO			* go mask & set fill colour
               S01:00E01AA2:  61 98
F00:5321       	BRA.s		LAB_PNCO			* continue command
               S01:00E01AA4:  60 02
F00:5322       
F00:5323       LAB_SELC
F00:5324       	BSR		LAB_SLCO			* go mask & set line colour
               S01:00E01AA6:  61 82
F00:5325       LAB_PNCO
F00:5326       	SUBQ.w	#1,d1				* decrement parameter count
               S01:00E01AA8:  53 41
F00:5327       	BEQ		LAB_SRTS			* exit if all done
               S01:00E01AAA:  67 64
F00:5328       
F00:5329       LAB_PNCE
F00:5330       	SUBQ.w	#2,d1				* subtract 2 from parameter count
               S01:00E01AAC:  55 41
F00:5331       	BNE		LAB_SNER			* do error if there were other than two
               S01:00E01AAE:  66 00 E7 CA
F00:5332       							* parameters left
F00:5333       
F00:5334       	BRA		LAB_S1XY			* go pop X,Y and do pixel command
               S01:00E01AB2:  60 46
F00:5335       
F00:5336       
F00:5337       *************************************************************************************
F00:5338       *
F00:5339       * perform RECT [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
F00:5340       
F00:5341       LAB_RECT
F00:5342       	MOVEQ		#90,d0			* draw unfilled rectangle
               S01:00E01AB4:  70 5A
F00:5343       	BRA.s		LAB_shape			* go do shape
               S01:00E01AB6:  60 0A
F00:5344       
F00:5345       
F00:5346       *************************************************************************************
F00:5347       *
F00:5348       * perform RECTF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
F00:5349       
F00:5350       LAB_FRECT
F00:5351       	MOVEQ		#87,d0			* draw filled rectangle
               S01:00E01AB8:  70 57
F00:5352       	BRA.s		LAB_shape			* go do shape
               S01:00E01ABA:  60 06
F00:5353       
F00:5354       
F00:5355       *************************************************************************************
F00:5356       *
F00:5357       * perform ELLIPSE [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
F00:5358       
F00:5359       LAB_ELLIPSE
F00:5360       	MOVEQ		#91,d0			* draw unfilled ellipse
               S01:00E01ABC:  70 5B
F00:5361       	BRA.s		LAB_shape			* go do shape
               S01:00E01ABE:  60 02
F00:5362       
F00:5363       
F00:5364       *************************************************************************************
F00:5365       *
F00:5366       * perform ELLIPSEF [X1,Y1,X2,Y2][,][LINE_COLOUR[,FILL_COLOUR]]
F00:5367       
F00:5368       LAB_FELLIPSE
F00:5369       	MOVEQ		#88,d0			* draw filled ellipse
               S01:00E01AC0:  70 58
F00:5370       *	BRA.s		LAB_shape			* go do shape
F00:5371       
F00:5372       * this is the routine that does all the hard work for all the shape commands
F00:5373       * the parameters are interpreted depending on their number. if there are four
F00:5374       * parameters then they must be X1, Y1, X2 and Y2. if there are less or more
F00:5375       * than four then LINE_COLOUR and/or FILL_COLOUR must be present
F00:5376       
F00:5377       LAB_shape
F00:5378       	MOVE.l	d0,-(sp)			* save shape type
               S01:00E01AC2:  2F 00
F00:5379       
F00:5380       	BSR		LAB_GGPR			* get graphics parameters, return count in d1.w
               S01:00E01AC4:  61 00 FF 38
F00:5381       	SUBQ.w	#4,d1				* subtract 4 from parameter count
               S01:00E01AC8:  59 41
F00:5382       	BEQ		LAB_S2XY			* branch if there were 4 parameters
               S01:00E01ACA:  67 1E
F00:5383       
F00:5384       * less or more than four then LINE_COLOUR and/or FILL_COLOUR must be present
F00:5385       
F00:5386       	BTST		#0,d1				* test parameter count
               S01:00E01ACC:  08 01 00 00
F00:5387       	BNE		LAB_SNFC			* branch if no fill colour parameter
               S01:00E01AD0:  66 08
F00:5388       
F00:5389       * even number so LINE_COLOUR and FILL_COLOUR must be present
F00:5390       
F00:5391       	MOVE.l	(sp)+,d0			* get fill colour
               S01:00E01AD2:  20 1F
F00:5392       	BSR		LAB_SFCO			* go mask & set fill colour
               S01:00E01AD4:  61 00 FF 66
F00:5393       	SUBQ.w	#1,d1				* decrement parameter count
               S01:00E01AD8:  53 41
F00:5394       LAB_SNFC
F00:5395       	MOVE.l	(sp)+,d0			* get line colour
               S01:00E01ADA:  20 1F
F00:5396       	BSR		LAB_SLCO			* go mask & set line colour
               S01:00E01ADC:  61 00 FF 4C
F00:5397       	ADDQ.w	#3,d1				* decrement parameter count and add 4
               S01:00E01AE0:  56 41
F00:5398       	BEQ		LAB_SRTS			* exit if no more parameters
               S01:00E01AE2:  67 2C
F00:5399       
F00:5400       * if there are any parameters left then they must be X1, Y1, X2 and Y2
F00:5401       * if there are less or more than four then something is wrong
F00:5402       
F00:5403       	SUBQ.w	#4,d1				* subtract 4 from parameter count
               S01:00E01AE4:  59 41
F00:5404       	BNE		LAB_SNER			* do error if wasn't 4 parameters
               S01:00E01AE6:  66 00 E7 92
F00:5405       
F00:5406       * pull four parameters and do graphics command
F00:5407       
F00:5408       LAB_S2XY
F00:5409       	MOVE.l	(sp)+,d0			* get Y2 off stack
               S01:00E01AEA:  20 1F
F00:5410       	BSR		LAB_EVSW			* evaluate signed word in d0
               S01:00E01AEC:  61 00 FF 00
F00:5411       	MOVE.l	d0,d4				* copy Y2 parameter
               S01:00E01AF0:  28 00
F00:5412       
F00:5413       	MOVE.l	(sp)+,d0			* get X2 off stack
               S01:00E01AF2:  20 1F
F00:5414       	BSR		LAB_EVSW			* evaluate signed word in d0
               S01:00E01AF4:  61 00 FE F8
F00:5415       	MOVE.l	d0,d3				* copy X2 parameter
               S01:00E01AF8:  26 00
F00:5416       
F00:5417       * pull two parameters and do graphics command
F00:5418       
F00:5419       LAB_S1XY
F00:5420       	MOVE.l	(sp)+,d0			* get Y1 off stack
               S01:00E01AFA:  20 1F
F00:5421       	BSR		LAB_EVSW			* evaluate signed word in d0
               S01:00E01AFC:  61 00 FE F0
F00:5422       	MOVE.l	d0,d2				* copy Y1 parameter
               S01:00E01B00:  24 00
F00:5423       
F00:5424       	MOVE.l	(sp)+,d0			* get X1 off stack
               S01:00E01B02:  20 1F
F00:5425       	BSR		LAB_EVSW			* evaluate signed word in d0
               S01:00E01B04:  61 00 FE E8
F00:5426       	MOVE.l	d0,d1				* copy X1 parameter
               S01:00E01B08:  22 00
F00:5427       
F00:5428       	MOVE.l	(sp)+,d0			* draw line, pixel or shape
               S01:00E01B0A:  20 1F
F00:5429       	TRAP		#15				* do I/O function
               S01:00E01B0C:  4E 4F
F00:5430       	RTS
               S01:00E01B0E:  4E 75
F00:5431       
F00:5432       LAB_SRTS
F00:5433       	MOVE.l	(sp)+,d0			* dump command
               S01:00E01B10:  20 1F
F00:5434       	RTS
               S01:00E01B12:  4E 75
F00:5435       
F00:5436       
F00:5437       *************************************************************************************
F00:5438       *
F00:5439       * perform MODE m
F00:5440       
F00:5441       LAB_MODE
F00:5442       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E01B14:  61 00 FD 08
F00:5443       	CMP.b		#$12,d0			* compare with max+1
               S01:00E01B18:  B0 3C 00 12
F00:5444       	BCC		LAB_FCER			* if >= $10 go do function call error
               S01:00E01B1C:  64 00 E7 50
F00:5445       
F00:5446       	MOVE.l	d0,d1				* copy it
               S01:00E01B20:  22 00
F00:5447       	MOVEQ		#92,d0			* set draw mode
               S01:00E01B22:  70 5C
F00:5448       	TRAP		#15				* do I/O function
               S01:00E01B24:  4E 4F
F00:5449       	RTS
               S01:00E01B26:  4E 75
F00:5450       
F00:5451       
F00:5452       *************************************************************************************
F00:5453       *
F00:5454       * perform SIZE s
F00:5455       
F00:5456       LAB_SIZE
F00:5457       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E01B28:  61 00 FC F4
F00:5458       	MOVE.l	d0,d1				* copy it
               S01:00E01B2C:  22 00
F00:5459       	MOVEQ		#93,d0			* set pen width
               S01:00E01B2E:  70 5D
F00:5460       	TRAP		#15				* do I/O function
               S01:00E01B30:  4E 4F
F00:5461       	RTS
               S01:00E01B32:  4E 75
F00:5462       
F00:5463       
F00:5464       *************************************************************************************
F00:5465       *
F00:5466       * perform CURSOR X,Y
F00:5467       
F00:5468       LAB_CURSOR
F00:5469       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E01B34:  61 00 FC E8
F00:5470       	CMP.b		#80,d0			* compare with max+1
               S01:00E01B38:  B0 3C 00 50
F00:5471       	BCC		LAB_FCER			* if >= 80 go do function call error
               S01:00E01B3C:  64 00 E7 30
F00:5472       
F00:5473       	MOVE.b	d0,TPos(a3)			* set terminal position
               S01:00E01B40:  17 40 05 E5
F00:5474       	ASL.w		#8,d0				* shift to high byte of word
               S01:00E01B44:  E1 40
F00:5475       	MOVE.w	d0,-(sp)			* save d0
               S01:00E01B46:  3F 00
F00:5476       
F00:5477       	BSR		LAB_SCGB			* scan for "," and get byte parameter, result
               S01:00E01B48:  61 00 F3 5E
F00:5478       							* in d0 & Itemp
F00:5479       
F00:5480       	CMP.b		#32,d0			* compare with max+1
               S01:00E01B4C:  B0 3C 00 20
F00:5481       	BCC		LAB_FCER			* if >= 32 go do function call error
               S01:00E01B50:  64 00 E7 1C
F00:5482       
F00:5483       	MOVE.w	(sp)+,d1			* restore d1
               S01:00E01B54:  32 1F
F00:5484       	OR.w		d0,d1				* OR row into low byte
               S01:00E01B56:  82 40
F00:5485       
F00:5486       	MOVEQ		#11,d0			* cursor position
               S01:00E01B58:  70 0B
F00:5487       	TRAP		#15				* do I/O function
               S01:00E01B5A:  4E 4F
F00:5488       
F00:5489       	MOVEQ		#0,d0				* set d0
               S01:00E01B5C:  70 00
F00:5490       	ADD.b		TPos(a3),d0			* get cursor x position
               S01:00E01B5E:  D0 2B 05 E5
F00:5491       	TST.b		TWidth(a3)			* test terminal width
               S01:00E01B62:  4A 2B 05 E6
F00:5492       	BNE.s		LAB_CRTS			* branch if not infinite line
               S01:00E01B66:  66 0A
F00:5493       
F00:5494       LAB_CDLP
F00:5495       	SUB.b		TabSiz(a3),d0		* subtract tab size
               S01:00E01B68:  90 2B 05 E2
F00:5496       	BCC.s		LAB_CDLP			* loop while no borrow
               S01:00E01B6C:  64 FA
F00:5497       	ADD.b		TabSiz(a3),d0		* add tab size back
               S01:00E01B6E:  D0 2B 05 E2
F00:5498       LAB_CRTS
F00:5499       	MOVE.b	d0,TPos(a3)			* set terminal position
               S01:00E01B72:  17 40 05 E5
F00:5500       	RTS
               S01:00E01B76:  4E 75
F00:5501       
F00:5502       
F00:5503       *************************************************************************************
F00:5504       *
F00:5505       * perform BUFFER
F00:5506       
F00:5507       LAB_BUFFER
F00:5508       	BNE		LAB_SNER			* do syntax error if following byte
               S01:00E01B78:  66 00 E7 00
F00:5509       
F00:5510       	MOVEQ		#94,d0			* copy buffer to screen
               S01:00E01B7C:  70 5E
F00:5511       	TRAP		#15				* do I/O function
               S01:00E01B7E:  4E 4F
F00:5512       
F00:5513       	RTS
               S01:00E01B80:  4E 75
F00:5514       
F00:5515       
F00:5516       *************************************************************************************
F00:5517       *
F00:5518       * perform CLS
F00:5519       
F00:5520       LAB_CLS
F00:5521       	BNE		LAB_SNER			* do syntax error if following byte
               S01:00E01B82:  66 00 E6 F6
F00:5522       
F00:5523       	MOVE.w	#$FF00,d1			* set for clear screen
               S01:00E01B86:  32 3C FF 00
F00:5524       	MOVE.b	d1,TPos(a3)			* clear terminal position
               S01:00E01B8A:  17 41 05 E5
F00:5525       	MOVEQ		#11,d0			* cursor position
               S01:00E01B8E:  70 0B
F00:5526       	TRAP		#15				* do I/O function
               S01:00E01B90:  4E 4F
F00:5527       
F00:5528       	RTS
               S01:00E01B92:  4E 75
F00:5529       
F00:5530       
F00:5531       *************************************************************************************
F00:5532       * end of EASy68k graphics extension commands							*
F00:5533       *************************************************************************************
F00:5534       
F00:5535       *************************************************************************************
F00:5536       *
F00:5537       * perform subtraction, FAC1 from FAC2
F00:5538       
F00:5539       LAB_SUBTRACT
F00:5540       	EORI.b	#$80,FAC1_s(a3)		* complement FAC1 sign
               S01:00E01B94:  0A 2B 00 80 05 95
F00:5541       	MOVE.b	FAC2_s(a3),FAC_sc(a3)	* copy FAC2 sign byte
               S01:00E01B9A:  17 6B 05 9D 05 9E
F00:5542       
F00:5543       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign byte
               S01:00E01BA0:  10 2B 05 95
F00:5544       	EOR.b		d0,FAC_sc(a3)		* EOR with FAC2 sign
               S01:00E01BA4:  B1 2B 05 9E
F00:5545       
F00:5546       
F00:5547       *************************************************************************************
F00:5548       *
F00:5549       * add FAC2 to FAC1
F00:5550       
F00:5551       LAB_ADD
F00:5552       	MOVE.b	FAC1_e(a3),d0		* get exponent
               S01:00E01BA8:  10 2B 05 94
F00:5553       	BEQ		LAB_279B			* FAC1 was zero so copy FAC2 to FAC1 & return
               S01:00E01BAC:  67 00 03 36
F00:5554       
F00:5555       							* FAC1 is non zero
F00:5556       	LEA		FAC2_m(a3),a0		* set pointer1 to FAC2 mantissa
               S01:00E01BB0:  41 EB 05 98
F00:5557       	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
               S01:00E01BB4:  10 2B 05 9C
F00:5558       	BEQ.s		RTS_016			* exit if zero
               S01:00E01BB8:  67 46
F00:5559       
F00:5560       	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
               S01:00E01BBA:  90 2B 05 94
F00:5561       	BEQ.s		LAB_24A8			* branch if = (go add mantissa)
               S01:00E01BBE:  67 22
F00:5562       
F00:5563       	BCS.s		LAB_249C			* branch if FAC2 < FAC1
               S01:00E01BC0:  65 0A
F00:5564       
F00:5565       							* FAC2 > FAC1
F00:5566       	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy sign and exponent of FAC2
               S01:00E01BC2:  37 6B 05 9C 05 94
F00:5567       	NEG.b		d0				* negate exponent difference (make diff -ve)
               S01:00E01BC8:  44 00
F00:5568       	SUBQ.w	#8,a0				* pointer1 to FAC1 
               S01:00E01BCA:  51 48
F00:5569       LAB_249C
F00:5570       	NEG.b		d0				* negate exponent difference (make diff +ve)
               S01:00E01BCC:  44 00
F00:5571       	MOVE.l	d1,-(sp)			* save d1
               S01:00E01BCE:  2F 01
F00:5572       	CMP.b		#32,d0			* compare exponent diff with 32
               S01:00E01BD0:  B0 3C 00 20
F00:5573       	BLT.s		LAB_2467			* branch if range >= 32
               S01:00E01BD4:  6D 04
F00:5574       
F00:5575       	MOVEQ		#0,d1				* clear d1
               S01:00E01BD6:  72 00
F00:5576       	BRA.s		LAB_2468			* go clear smaller mantissa
               S01:00E01BD8:  60 04
F00:5577       
F00:5578       LAB_2467
F00:5579       	MOVE.l	(a0),d1			* get FACx mantissa
               S01:00E01BDA:  22 10
F00:5580       	LSR.l		d0,d1				* shift d0 times right
               S01:00E01BDC:  E0 A9
F00:5581       LAB_2468
F00:5582       	MOVE.l	d1,(a0)			* save it back
               S01:00E01BDE:  20 81
F00:5583       	MOVE.l	(sp)+,d1			* restore d1
               S01:00E01BE0:  22 1F
F00:5584       
F00:5585       							* exponents are equal now do mantissa add or
F00:5586       							* subtract
F00:5587       LAB_24A8
F00:5588       	TST.b		FAC_sc(a3)			* test sign compare (FAC1 EOR FAC2)
               S01:00E01BE2:  4A 2B 05 9E
F00:5589       	BMI.s		LAB_24F8			* if <> go do subtract
               S01:00E01BE6:  6B 1A
F00:5590       
F00:5591       	MOVE.l	FAC2_m(a3),d0		* get FAC2 mantissa
               S01:00E01BE8:  20 2B 05 98
F00:5592       	ADD.l		FAC1_m(a3),d0		* add FAC1 mantissa
               S01:00E01BEC:  D0 AB 05 90
F00:5593       	BCC.s		LAB_24F7			* save and exit if no carry (FAC1 is normal)
               S01:00E01BF0:  64 0A
F00:5594       
F00:5595       	ROXR.l	#1,d0				* else shift carry back into mantissa
               S01:00E01BF2:  E2 90
F00:5596       	ADDQ.b	#1,FAC1_e(a3)		* increment FAC1 exponent
               S01:00E01BF4:  52 2B 05 94
F00:5597       	BCS		LAB_OFER			* if carry do overflow error & warm start
               S01:00E01BF8:  65 00 E6 70
F00:5598       
F00:5599       LAB_24F7
F00:5600       	MOVE.l	d0,FAC1_m(a3)		* save mantissa
               S01:00E01BFC:  27 40 05 90
F00:5601       RTS_016
F00:5602       	RTS
               S01:00E01C00:  4E 75
F00:5603       							* signs are different
F00:5604       LAB_24F8
F00:5605       	LEA		FAC1_m(a3),a1		* pointer 2 to FAC1
               S01:00E01C02:  43 EB 05 90
F00:5606       	CMPA.l	a0,a1				* compare pointers
               S01:00E01C06:  B3 C8
F00:5607       	BNE.s		LAB_24B4			* branch if <>
               S01:00E01C08:  66 02
F00:5608       
F00:5609       	ADDQ.w	#8,a1				* else pointer2 to FAC2
               S01:00E01C0A:  50 49
F00:5610       
F00:5611       							* take smaller from bigger (take sign of bigger)
F00:5612       LAB_24B4
F00:5613       	MOVE.l	(a1),d0			* get larger mantissa
               S01:00E01C0C:  20 11
F00:5614       	MOVE.l	(a0),d1			* get smaller mantissa
               S01:00E01C0E:  22 10
F00:5615       	MOVE.l	d0,FAC1_m(a3)		* save larger mantissa
               S01:00E01C10:  27 40 05 90
F00:5616       	SUB.l		d1,FAC1_m(a3)		* subtract smaller
               S01:00E01C14:  93 AB 05 90
F00:5617       
F00:5618       
F00:5619       *************************************************************************************
F00:5620       *
F00:5621       * do +/- (carry is sign) & normalise FAC1
F00:5622       
F00:5623       LAB_24D0
F00:5624       	BCC.s		LAB_24D5			* branch if result is +ve
               S01:00E01C18:  64 08
F00:5625       
F00:5626       							* erk! subtract is the wrong way round so
F00:5627       							* negate everything
F00:5628       	EORI.b	#$FF,FAC1_s(a3)		* complement FAC1 sign
               S01:00E01C1A:  46 2B 05 95
F00:5629       	NEG.l		FAC1_m(a3)			* negate FAC1 mantissa
               S01:00E01C1E:  44 AB 05 90
F00:5630       
F00:5631       
F00:5632       *************************************************************************************
F00:5633       *
F00:5634       * normalise FAC1
F00:5635       
F00:5636       LAB_24D5
F00:5637       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E01C22:  20 2B 05 90
F00:5638       	BMI.s		LAB_24DA			* mantissa is normal so just exit
               S01:00E01C26:  6B 2E
F00:5639       
F00:5640       	BNE.s		LAB_24D9			* mantissa is not zero so go normalise FAC1
               S01:00E01C28:  66 06
F00:5641       
F00:5642       	MOVE.w	d0,FAC1_e(a3)		* else make FAC1 = +zero
               S01:00E01C2A:  37 40 05 94
F00:5643       	RTS
               S01:00E01C2E:  4E 75
F00:5644       
F00:5645       LAB_24D9
F00:5646       	MOVE.l	d1,-(sp)			* save d1
               S01:00E01C30:  2F 01
F00:5647       	MOVE.l	d0,d1				* mantissa to d1
               S01:00E01C32:  22 00
F00:5648       	MOVEQ		#0,d0				* clear d0
               S01:00E01C34:  70 00
F00:5649       	MOVE.b	FAC1_e(a3),d0		* get exponent byte
               S01:00E01C36:  10 2B 05 94
F00:5650       	BEQ.s		LAB_24D8			* if exponent is zero then clean up and exit
               S01:00E01C3A:  67 14
F00:5651       LAB_24D6
F00:5652       	ADD.l		d1,d1				* shift mantissa, ADD is quicker for a single
               S01:00E01C3C:  D2 81
F00:5653       							* shift
F00:5654       	DBMI		d0,LAB_24D6			* decrement exponent and loop if mantissa and
               S01:00E01C3E:  5B C8 FF FC
F00:5655       							* exponent +ve
F00:5656       
F00:5657       	TST.w		d0				* test exponent
               S01:00E01C42:  4A 40
F00:5658       	BEQ.s		LAB_24D8			* if exponent is zero make FAC1 zero
               S01:00E01C44:  67 0A
F00:5659       
F00:5660       	BPL.s		LAB_24D7			* if exponent is >zero go save FAC1
               S01:00E01C46:  6A 02
F00:5661       
F00:5662       	MOVEQ		#1,d0				* else set for zero after correction
               S01:00E01C48:  70 01
F00:5663       LAB_24D7
F00:5664       	SUBQ.b	#1,d0				* adjust exponent for loop
               S01:00E01C4A:  53 00
F00:5665       	MOVE.l	d1,FAC1_m(a3)		* save normalised mantissa
               S01:00E01C4C:  27 41 05 90
F00:5666       LAB_24D8
F00:5667       	MOVE.l	(sp)+,d1			* restore d1
               S01:00E01C50:  22 1F
F00:5668       	MOVE.b	d0,FAC1_e(a3)		* save corrected exponent
               S01:00E01C52:  17 40 05 94
F00:5669       LAB_24DA
F00:5670       	RTS
               S01:00E01C56:  4E 75
F00:5671       
F00:5672       
F00:5673       *************************************************************************************
F00:5674       *
F00:5675       * perform LOG()
F00:5676       
F00:5677       LAB_LOG
F00:5678       	TST.b		FAC1_s(a3)			* test sign
               S01:00E01C58:  4A 2B 05 95
F00:5679       	BMI		LAB_FCER			* if -ve do function call error/warm start
               S01:00E01C5C:  6B 00 E6 10
F00:5680       
F00:5681       	MOVEQ		#0,d7				* clear d7
               S01:00E01C60:  7E 00
F00:5682       	MOVE.b	d7,FAC_sc(a3)		* clear sign compare
               S01:00E01C62:  17 47 05 9E
F00:5683       	MOVE.b	FAC1_e(a3),d7		* get exponent
               S01:00E01C66:  1E 2B 05 94
F00:5684       	BEQ		LAB_FCER			* if 0 do function call error/warm start
               S01:00E01C6A:  67 00 E6 02
F00:5685       
F00:5686       	SUB.l		#$81,d7			* normalise exponent
               S01:00E01C6E:  9E BC 00 00 00 81
F00:5687       	MOVE.b	#$81,FAC1_e(a3)		* force a value between 1 and 2
               S01:00E01C74:  17 7C 00 81 05 94
F00:5688       	MOVE.l	FAC1_m(a3),d6		* copy mantissa
               S01:00E01C7A:  2C 2B 05 90
F00:5689       
F00:5690       	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
               S01:00E01C7E:  27 7C 80 00 00 00 05 98
F00:5691       	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
               S01:00E01C86:  37 7C 81 00 05 9C
F00:5692       	BSR		LAB_ADD			* find arg+1
               S01:00E01C8C:  61 00 FF 1A
F00:5693       	MOVEQ		#0,d0				* setup for calc skip
               S01:00E01C90:  70 00
F00:5694       	MOVE.w	d0,FAC2_e(a3)		* set FAC1 for zero result
               S01:00E01C92:  37 40 05 9C
F00:5695       	ADD.l		d6,d6				* shift 1 bit out
               S01:00E01C96:  DC 86
F00:5696       	MOVE.l	d6,FAC2_m(a3)		* put back FAC2
               S01:00E01C98:  27 46 05 98
F00:5697       	BEQ.s		LAB_LONN			* if 0 skip calculation
               S01:00E01C9C:  67 58
F00:5698       
F00:5699       	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for .5
               S01:00E01C9E:  37 7C 80 00 05 9C
F00:5700       	BSR		LAB_DIVIDE			* do (arg-1)/(arg+1)
               S01:00E01CA4:  61 00 01 30
F00:5701       	TST.b		FAC1_e(a3)			* test exponent
               S01:00E01CA8:  4A 2B 05 94
F00:5702       	BEQ.s		LAB_LONN			* if 0 skip calculation
               S01:00E01CAC:  67 48
F00:5703       
F00:5704       	MOVE.b	FAC1_e(a3),d1		* get exponent
               S01:00E01CAE:  12 2B 05 94
F00:5705       	SUB.b		#$82,d1			* normalise and two integer bits
               S01:00E01CB2:  92 3C 00 82
F00:5706       	NEG.b		d1				* negate for shift
               S01:00E01CB6:  44 01
F00:5707       **	CMP.b		#$1F,d1			* will mantissa vanish?
F00:5708       **	BGT.s		LAB_dunno			* if so do ???
F00:5709       
F00:5710       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E01CB8:  20 2B 05 90
F00:5711       	LSR.l		d1,d0				* shift in two integer bits
               S01:00E01CBC:  E2 A8
F00:5712       
F00:5713       * d0 = arg
F00:5714       * d0 = x, d1 = y
F00:5715       * d2 = x1, d3 = y1
F00:5716       * d4 = shift count
F00:5717       * d5 = loop count
F00:5718       * d6 = z
F00:5719       * a0 = table pointer
F00:5720       
F00:5721       	MOVEQ		#0,d6				* z = 0
               S01:00E01CBE:  7C 00
F00:5722       	MOVE.l	#1<<30,d1			* y = 1
               S01:00E01CC0:  22 3C 40 00 00 00
F00:5723       	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic tangent table
               S01:00E01CC6:  41 FA 13 F4
F00:5724       	MOVEQ		#30,d5			* loop 31 times
               S01:00E01CCA:  7A 1E
F00:5725       	MOVEQ		#1,d4				* set shift count
               S01:00E01CCC:  78 01
F00:5726       	BRA.s		LAB_LOCC			* entry point for loop
               S01:00E01CCE:  60 06
F00:5727       
F00:5728       LAB_LAAD
F00:5729       	ASR.l		d4,d2				* x1 >> i
               S01:00E01CD0:  E8 A2
F00:5730       	SUB.l		d2,d1				* y = y - x1
               S01:00E01CD2:  92 82
F00:5731       	ADD.l		(a0),d6			* z = z + tanh(i)
               S01:00E01CD4:  DC 90
F00:5732       LAB_LOCC
F00:5733       	MOVE.l	d0,d2				* x1 = x
               S01:00E01CD6:  24 00
F00:5734       	MOVE.l	d1,d3				* y1 = Y
               S01:00E01CD8:  26 01
F00:5735       	ASR.l		d4,d3				* y1 >> i
               S01:00E01CDA:  E8 A3
F00:5736       	BCC.s		LAB_LOLP
               S01:00E01CDC:  64 02
F00:5737       
F00:5738       	ADDQ.l	#1,d3
               S01:00E01CDE:  52 83
F00:5739       LAB_LOLP
F00:5740       	SUB.l		d3,d0				* x = x - y1
               S01:00E01CE0:  90 83
F00:5741       	BPL.s		LAB_LAAD			* branch if > 0
               S01:00E01CE2:  6A EC
F00:5742       
F00:5743       	MOVE.l	d2,d0				* get x back
               S01:00E01CE4:  20 02
F00:5744       	ADDQ.w	#4,a0				* next entry
               S01:00E01CE6:  58 48
F00:5745       	ADDQ.l	#1,d4				* next i
               S01:00E01CE8:  52 84
F00:5746       	LSR.l		#1,d3				* /2
               S01:00E01CEA:  E2 8B
F00:5747       	BEQ.s		LAB_LOCX			* branch y1 = 0
               S01:00E01CEC:  67 04
F00:5748       
F00:5749       	DBF		d5,LAB_LOLP			* decrement and loop if not done
               S01:00E01CEE:  51 CD FF F0
F00:5750       
F00:5751       							* now sort out the result
F00:5752       LAB_LOCX
F00:5753       	ADD.l		d6,d6				* *2
               S01:00E01CF2:  DC 86
F00:5754       	MOVE.l	d6,d0				* setup for d7 = 0
               S01:00E01CF4:  20 06
F00:5755       LAB_LONN
F00:5756       	MOVE.l	d0,d4				* save cordic result
               S01:00E01CF6:  28 00
F00:5757       	MOVEQ		#0,d5				* set default exponent sign
               S01:00E01CF8:  7A 00
F00:5758       	TST.l		d7				* check original exponent sign
               S01:00E01CFA:  4A 87
F00:5759       	BEQ.s		LAB_LOXO			* branch if original was 0
               S01:00E01CFC:  67 16
F00:5760       
F00:5761       	BPL.s		LAB_LOXP			* branch if was +ve
               S01:00E01CFE:  6A 04
F00:5762       
F00:5763       	NEG.l		d7				* make original exponent +ve
               S01:00E01D00:  44 87
F00:5764       	MOVEQ		#$80-$100,d5		* make sign -ve
               S01:00E01D02:  7A 80
F00:5765       LAB_LOXP
F00:5766       	MOVE.b	d5,FAC1_s(a3)		* save original exponent sign
               S01:00E01D04:  17 45 05 95
F00:5767       	SWAP		d7				* 16 bit shift
               S01:00E01D08:  48 47
F00:5768       	LSL.l		#8,d7				* easy first part
               S01:00E01D0A:  E1 8F
F00:5769       	MOVEQ		#$88-$100,d5		* start with byte
               S01:00E01D0C:  7A 88
F00:5770       LAB_LONE
F00:5771       	SUBQ.l	#1,d5				* decrement exponent
               S01:00E01D0E:  53 85
F00:5772       	ADD.l		d7,d7				* shift mantissa
               S01:00E01D10:  DE 87
F00:5773       	BPL.s		LAB_LONE			* loop if not normal
               S01:00E01D12:  6A FA
F00:5774       
F00:5775       LAB_LOXO
F00:5776       	MOVE.l	d7,FAC1_m(a3)		* save original exponent as mantissa
               S01:00E01D14:  27 47 05 90
F00:5777       	MOVE.b	d5,FAC1_e(a3)		* save exponent for this
               S01:00E01D18:  17 45 05 94
F00:5778       	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
               S01:00E01D1C:  27 7C B1 72 17 F8 05 98
F00:5779       	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
               S01:00E01D24:  37 7C 80 00 05 9C
F00:5780       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make sign compare = FAC1 sign
               S01:00E01D2A:  17 6B 05 95 05 9E
F00:5781       	BSR.s		LAB_MULTIPLY		* do multiply
               S01:00E01D30:  61 18
F00:5782       	MOVE.l	d4,FAC2_m(a3)		* save cordic result
               S01:00E01D32:  27 44 05 98
F00:5783       	BEQ.s		LAB_LOWZ			* branch if zero
               S01:00E01D36:  67 10
F00:5784       
F00:5785       	MOVE.w	#$8200,FAC2_e(a3)		* set exponent & sign
               S01:00E01D38:  37 7C 82 00 05 9C
F00:5786       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* clear sign compare
               S01:00E01D3E:  17 6B 05 95 05 9E
F00:5787       	BSR		LAB_ADD			* and add for final result
               S01:00E01D44:  61 00 FE 62
F00:5788       
F00:5789       LAB_LOWZ
F00:5790       	RTS
               S01:00E01D48:  4E 75
F00:5791       
F00:5792       
F00:5793       *************************************************************************************
F00:5794       *
F00:5795       * multiply FAC1 by FAC2
F00:5796       
F00:5797       LAB_MULTIPLY
F00:5798       	MOVEM.l	d0-d4,-(sp)			* save registers
               S01:00E01D4A:  48 E7 F8 00
F00:5799       	TST.b		FAC1_e(a3)			* test FAC1 exponent
               S01:00E01D4E:  4A 2B 05 94
F00:5800       	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
               S01:00E01D52:  67 76
F00:5801       
F00:5802       	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
               S01:00E01D54:  10 2B 05 9C
F00:5803       	BEQ.s		LAB_MUUF			* if exponent zero go make result zero
               S01:00E01D58:  67 70
F00:5804       
F00:5805       	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare becomes sign
               S01:00E01D5A:  17 6B 05 9E 05 95
F00:5806       
F00:5807       	ADD.b		FAC1_e(a3),d0		* multiply exponents by adding
               S01:00E01D60:  D0 2B 05 94
F00:5808       	BCC.s		LAB_MNOC			* branch if no carry
               S01:00E01D64:  64 0A
F00:5809       
F00:5810       	SUB.b		#$80,d0			* normalise result
               S01:00E01D66:  90 3C 00 80
F00:5811       	BCC		LAB_OFER			* if no carry do overflow
               S01:00E01D6A:  64 00 E4 FE
F00:5812       
F00:5813       	BRA.s		LAB_MADD			* branch
               S01:00E01D6E:  60 06
F00:5814       
F00:5815       							* no carry for exponent add
F00:5816       LAB_MNOC
F00:5817       	SUB.b		#$80,d0			* normalise result
               S01:00E01D70:  90 3C 00 80
F00:5818       	BCS.s		LAB_MUUF			* return zero if underflow
               S01:00E01D74:  65 54
F00:5819       
F00:5820       LAB_MADD
F00:5821       	MOVE.b	d0,FAC1_e(a3)		* save exponent
               S01:00E01D76:  17 40 05 94
F00:5822       
F00:5823       							* d1 (FAC1) x d2 (FAC2)
F00:5824       	MOVE.l	FAC1_m(a3),d1		* get FAC1 mantissa
               S01:00E01D7A:  22 2B 05 90
F00:5825       	MOVE.l	FAC2_m(a3),d2		* get FAC2 mantissa
               S01:00E01D7E:  24 2B 05 98
F00:5826       
F00:5827       	MOVE.w	d1,d4				* copy low word FAC1
               S01:00E01D82:  38 01
F00:5828       	MOVE.l	d1,d0				* copy long word FAC1
               S01:00E01D84:  20 01
F00:5829       	SWAP		d0				* high word FAC1 to low word FAC1
               S01:00E01D86:  48 40
F00:5830       	MOVE.w	d0,d3				* copy high word FAC1
               S01:00E01D88:  36 00
F00:5831       
F00:5832       	MULU		d2,d1				* low word FAC2 x low word FAC1
               S01:00E01D8A:  C2 C2
F00:5833       	MULU		d2,d0				* low word FAC2 x high word FAC1
               S01:00E01D8C:  C0 C2
F00:5834       	SWAP		d2				* high word FAC2 to low word FAC2
               S01:00E01D8E:  48 42
F00:5835       	MULU		d2,d4				* high word FAC2 x low word FAC1
               S01:00E01D90:  C8 C2
F00:5836       	MULU		d2,d3				* high word FAC2 x high word FAC1
               S01:00E01D92:  C6 C2
F00:5837       
F00:5838       * done multiply, now add partial products
F00:5839       
F00:5840       *			d1 =					aaaa  ----	FAC2_L x FAC1_L
F00:5841       *			d0 =				bbbb  aaaa		FAC2_L x FAC1_H
F00:5842       *			d4 =				bbbb  aaaa		FAC2_H x FAC1_L
F00:5843       *			d3 =			cccc  bbbb			FAC2_H x FAC1_H
F00:5844       *			product =		mmmm  mmmm
F00:5845       
F00:5846       	ADD.L		#$8000,d1			* round up lowest word
               S01:00E01D94:  D2 BC 00 00 80 00
F00:5847       	CLR.w		d1				* clear low word, don't need it
               S01:00E01D9A:  42 41
F00:5848       	SWAP		d1				* align high word
               S01:00E01D9C:  48 41
F00:5849       	ADD.l		d0,d1				* add FAC2_L x FAC1_H (can't be carry)
               S01:00E01D9E:  D2 80
F00:5850       LAB_MUF1
F00:5851       	ADD.l		d4,d1				* now add intermediate (FAC2_H x FAC1_L)
               S01:00E01DA0:  D2 84
F00:5852       	BCC.s		LAB_MUF2			* branch if no carry
               S01:00E01DA2:  64 06
F00:5853       
F00:5854       	ADD.l		#$10000,d3			* else correct result
               S01:00E01DA4:  D6 BC 00 01 00 00
F00:5855       LAB_MUF2
F00:5856       	ADD.l		#$8000,d1			* round up low word
               S01:00E01DAA:  D2 BC 00 00 80 00
F00:5857       	CLR.w		d1				* clear low word
               S01:00E01DB0:  42 41
F00:5858       	SWAP		d1				* align for final add
               S01:00E01DB2:  48 41
F00:5859       	ADD.l		d3,d1				* add FAC2_H x FAC1_H, result
               S01:00E01DB4:  D2 83
F00:5860       	BMI.s		LAB_MUF3			* branch if normalisation not needed
               S01:00E01DB6:  6B 08
F00:5861       
F00:5862       	ADD.l		d1,d1				* shift mantissa
               S01:00E01DB8:  D2 81
F00:5863       	SUBQ.b	#1,FAC1_e(a3)		* adjust exponent
               S01:00E01DBA:  53 2B 05 94
F00:5864       	BEQ.s		LAB_MUUF			* branch if underflow
               S01:00E01DBE:  67 0A
F00:5865       
F00:5866       LAB_MUF3
F00:5867       	MOVE.l	d1,FAC1_m(a3)		* save mantissa
               S01:00E01DC0:  27 41 05 90
F00:5868       LAB_MUEX
F00:5869       	MOVEM.l	(sp)+,d0-d4			* restore registers
               S01:00E01DC4:  4C DF 00 1F
F00:5870       	RTS
               S01:00E01DC8:  4E 75
F00:5871       							* either zero or underflow result
F00:5872       LAB_MUUF
F00:5873       	MOVEQ		#0,d0				* quick clear
               S01:00E01DCA:  70 00
F00:5874       	MOVE.l	d0,FAC1_m(a3)		* clear mantissa
               S01:00E01DCC:  27 40 05 90
F00:5875       	MOVE.w	d0,FAC1_e(a3)		* clear sign and exponent
               S01:00E01DD0:  37 40 05 94
F00:5876       	BRA.s		LAB_MUEX			* restore regs & exit
               S01:00E01DD4:  60 EE
F00:5877       
F00:5878       
F00:5879       *************************************************************************************
F00:5880       *
F00:5881       * do FAC2/FAC1, result in FAC1
F00:5882       * fast hardware divide version
F00:5883       
F00:5884       LAB_DIVIDE
F00:5885       	MOVE.l	d7,-(sp)			* save d7
               S01:00E01DD6:  2F 07
F00:5886       	MOVEQ		#0,d0				* clear FAC2 exponent
               S01:00E01DD8:  70 00
F00:5887       	MOVE.l	d0,d2				* clear FAC1 exponent
               S01:00E01DDA:  24 00
F00:5888       
F00:5889       	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
               S01:00E01DDC:  14 2B 05 94
F00:5890       	BEQ		LAB_DZER			* if zero go do /0 error
               S01:00E01DE0:  67 00 E4 74
F00:5891       
F00:5892       	MOVE.b	FAC2_e(a3),d0		* get FAC2 exponent
               S01:00E01DE4:  10 2B 05 9C
F00:5893       	BEQ.s		LAB_DIV0			* if zero return zero
               S01:00E01DE8:  67 66
F00:5894       
F00:5895       	SUB.w		d2,d0				* get result exponent by subtracting
               S01:00E01DEA:  90 42
F00:5896       	ADD.w		#$80,d0			* correct 16 bit exponent result
               S01:00E01DEC:  D0 7C 00 80
F00:5897       
F00:5898       	MOVE.b	FAC_sc(a3),FAC1_s(a3)	* sign compare is result sign
               S01:00E01DF0:  17 6B 05 9E 05 95
F00:5899       
F00:5900       * now to do 32/32 bit mantissa divide
F00:5901       
F00:5902       	CLR.b		flag(a3)			* clear 'flag' byte
               S01:00E01DF6:  42 2B 05 9F
F00:5903       	MOVE.l	FAC1_m(a3),d3		* get FAC1 mantissa
               S01:00E01DFA:  26 2B 05 90
F00:5904       	MOVE.l	FAC2_m(a3),d4		* get FAC2 mantissa
               S01:00E01DFE:  28 2B 05 98
F00:5905       	CMP.l		d3,d4				* compare FAC2 with FAC1 mantissa
               S01:00E01E02:  B8 83
F00:5906       	BEQ.s		LAB_MAN1			* set mantissa result = 1 if equal
               S01:00E01E04:  67 44
F00:5907       
F00:5908       	BCS.s		AC1gtAC2			* branch if FAC1 > FAC2
               S01:00E01E06:  65 06
F00:5909       
F00:5910       	SUB.l		d3,d4				* subtract FAC1 from FAC2, result now must be <1
               S01:00E01E08:  98 83
F00:5911       	ADDQ.b	#3,flag(a3)			* FAC2>FAC1 so set 'flag' byte
               S01:00E01E0A:  56 2B 05 9F
F00:5912       AC1gtAC2
F00:5913       	BSR.s		LAB_32_16			* do 32/16 divide
               S01:00E01E0E:  61 46
F00:5914       	SWAP		d1				* move 16 bit result to high word
               S01:00E01E10:  48 41
F00:5915       	MOVE.l	d2,d4				* copy remainder longword
               S01:00E01E12:  28 02
F00:5916       	BSR.s		LAB_3216			* do 32/16 divide again (skip copy d4 to d2)
               S01:00E01E14:  61 42
F00:5917       	DIVU.w	d5,d2				* now divide remainder to make guard word
               S01:00E01E16:  84 C5
F00:5918       	MOVE.b	flag(a3),d7			* now normalise, get flag byte back
               S01:00E01E18:  1E 2B 05 9F
F00:5919       	BEQ.s		LAB_DIVX			* skip add if null
               S01:00E01E1C:  67 08
F00:5920       
F00:5921       * else result was >1 so we need to add 1 to result mantissa and adjust exponent
F00:5922       
F00:5923       	LSR.b		#1,d7				* shift 1 into eXtend
               S01:00E01E1E:  E2 0F
F00:5924       	ROXR.l	#1,d1				* shift extend result >>
               S01:00E01E20:  E2 91
F00:5925       	ROXR.w	#1,d2				* shift extend guard word >>
               S01:00E01E22:  E2 52
F00:5926       	ADDQ.b	#1,d0				* adjust exponent
               S01:00E01E24:  52 00
F00:5927       
F00:5928       * now round result to 32 bits
F00:5929       
F00:5930       LAB_DIVX
F00:5931       	ADD.w		d2,d2				* guard bit into eXtend bit
               S01:00E01E26:  D4 42
F00:5932       	BCC.s		L_DIVRND			* branch if guard=0
               S01:00E01E28:  64 08
F00:5933       
F00:5934       	ADDQ.l	#1,d1				* add guard to mantissa
               S01:00E01E2A:  52 81
F00:5935       	BCC.s		L_DIVRND			* branch if no overflow
               S01:00E01E2C:  64 04
F00:5936       
F00:5937       LAB_SET1
F00:5938       	ROXR.l	#1,d1				* shift extend result >>
               S01:00E01E2E:  E2 91
F00:5939       	ADDQ.w	#1,d0				* adjust exponent
               S01:00E01E30:  52 40
F00:5940       
F00:5941       							* test for over/under flow
F00:5942       L_DIVRND
F00:5943       	MOVE.w	d0,d3				* copy exponent
               S01:00E01E32:  36 00
F00:5944       	BMI.s		LAB_DIV0			* if -ve return zero
               S01:00E01E34:  6B 1A
F00:5945       
F00:5946       	ANDI.w	#$FF00,d3			* mask word high byte
               S01:00E01E36:  02 43 FF 00
F00:5947       	BNE		LAB_OFER			* branch if overflow
               S01:00E01E3A:  66 00 E4 2E
F00:5948       
F00:5949       							* move result into FAC1
F00:5950       LAB_XDIV
F00:5951       	MOVE.l	(sp)+,d7			* restore d7
               S01:00E01E3E:  2E 1F
F00:5952       	MOVE.b	d0,FAC1_e(a3)		* save result exponent
               S01:00E01E40:  17 40 05 94
F00:5953       	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
               S01:00E01E44:  27 41 05 90
F00:5954       	RTS
               S01:00E01E48:  4E 75
F00:5955       
F00:5956       * FAC1 mantissa = FAC2 mantissa so set result mantissa
F00:5957       
F00:5958       LAB_MAN1
F00:5959       	MOVEQ		#1,d1				* set bit
               S01:00E01E4A:  72 01
F00:5960       	LSR.l		d1,d1				* bit into eXtend
               S01:00E01E4C:  E2 A9
F00:5961       	BRA.s		LAB_SET1			* set mantissa, adjust exponent and exit
               S01:00E01E4E:  60 DE
F00:5962       
F00:5963       * result is zero
F00:5964       
F00:5965       LAB_DIV0
F00:5966       	MOVEQ		#0,d0				* zero exponent & sign
               S01:00E01E50:  70 00
F00:5967       	MOVE.l	d0,d1				* zero mantissa
               S01:00E01E52:  22 00
F00:5968       	BRA		LAB_XDIV			* exit divide
               S01:00E01E54:  60 E8
F00:5969       
F00:5970       * divide 16 bits into 32, AB/Ex
F00:5971       *
F00:5972       * d4			AAAA	BBBB			* 32 bit numerator
F00:5973       * d3			EEEE	xxxx			* 16 bit denominator
F00:5974       *
F00:5975       * returns -
F00:5976       *
F00:5977       * d1			xxxx	DDDD			* 16 bit result
F00:5978       * d2				HHHH	IIII		* 32 bit remainder
F00:5979       
F00:5980       LAB_32_16
F00:5981       	MOVE.l	d4,d2				* copy FAC2 mantissa		(AB)
               S01:00E01E56:  24 04
F00:5982       LAB_3216
F00:5983       	MOVE.l	d3,d5				* copy FAC1 mantissa		(EF)
               S01:00E01E58:  2A 03
F00:5984       	CLR.w		d5				* clear low word d1		(Ex)
               S01:00E01E5A:  42 45
F00:5985       	SWAP		d5				* swap high word to low word	(xE)
               S01:00E01E5C:  48 45
F00:5986       
F00:5987       * d3			EEEE	FFFF			* denominator copy
F00:5988       * d5		0000	EEEE				* denominator high word
F00:5989       * d2			AAAA	BBBB			* numerator copy
F00:5990       * d4			AAAA	BBBB			* numerator
F00:5991       
F00:5992       	DIVU.w	d5,d4				* do FAC2/FAC1 high word	(AB/E)
               S01:00E01E5E:  88 C5
F00:5993       	BVC.s		LAB_LT_1			* if no overflow DIV was ok
               S01:00E01E60:  68 02
F00:5994       
F00:5995       	MOVEQ		#-1,d4			* else set default value
               S01:00E01E62:  78 FF
F00:5996       
F00:5997       ; done the divide, now check the result, we have ...
F00:5998       
F00:5999       * d3			EEEE	FFFF			* denominator copy
F00:6000       * d5		0000	EEEE				* denominator high word
F00:6001       * d2			AAAA	BBBB			* numerator copy
F00:6002       * d4			MMMM	DDDD			* result MOD and DIV
F00:6003       
F00:6004       LAB_LT_1
F00:6005       	MOVE.w	d4,d6				* copy 16 bit result
               S01:00E01E64:  3C 04
F00:6006       	MOVE.w	d4,d1				* copy 16 bit result again
               S01:00E01E66:  32 04
F00:6007       
F00:6008       * we now have ..
F00:6009       * d3			EEEE	FFFF			* denominator copy
F00:6010       * d5		0000	EEEE				* denominator high word
F00:6011       * d6			xxxx  DDDD			* result DIV copy
F00:6012       * d1			xxxx  DDDD			* result DIV copy
F00:6013       * d2			AAAA	BBBB			* numerator copy
F00:6014       * d4			MMMM	DDDD			* result MOD and DIV
F00:6015       
F00:6016       * now multiply out 32 bit denominator by 16 bit result
F00:6017       * QRS = AB*D
F00:6018       
F00:6019       	MULU.w	d3,d6				* FFFF * DDDD =       rrrr  SSSS
               S01:00E01E68:  CC C3
F00:6020       	MULU.w	d5,d4				* EEEE * DDDD = QQQQ  rrrr
               S01:00E01E6A:  C8 C5
F00:6021       
F00:6022       * we now have ..
F00:6023       * d3			EEEE	FFFF			* denominator copy
F00:6024       * d5		0000	EEEE				* denominator high word
F00:6025       * d6				rrrr  SSSS		* 48 bit result partial low
F00:6026       * d1			xxxx  DDDD			* result DIV copy
F00:6027       * d2			AAAA	BBBB			* numerator copy
F00:6028       * d4			QQQQ	rrrr			* 48 bit result partial
F00:6029       
F00:6030       	MOVE.w	d6,d7				* copy low word of low multiply
               S01:00E01E6C:  3E 06
F00:6031       
F00:6032       * d7				xxxx	SSSS		* 48 bit result partial low
F00:6033       
F00:6034       	CLR.w		d6				* clear low word of low multiply
               S01:00E01E6E:  42 46
F00:6035       	SWAP		d6				* high word of low multiply to low word
               S01:00E01E70:  48 46
F00:6036       
F00:6037       * d6			0000	rrrr			* high word of 48 bit result partial low
F00:6038       
F00:6039       	ADD.l		d6,d4
               S01:00E01E72:  D8 86
F00:6040       
F00:6041       * d4			QQQQ	RRRR			* 48 bit result partial high longword
F00:6042       
F00:6043       	MOVEQ		#0,d6				* clear to extend numerator to 48 bits
               S01:00E01E74:  7C 00
F00:6044       
F00:6045       * now do GHI = AB0 - QRS (which is the remainder)
F00:6046       
F00:6047       	SUB.w		d7,d6				* low word subtract
               S01:00E01E76:  9C 47
F00:6048       
F00:6049       * d6				xxxx	IIII		* remainder low word
F00:6050       
F00:6051       	SUBX.l	d4,d2				* high longword subtract
               S01:00E01E78:  95 84
F00:6052       
F00:6053       * d2			GGGG	HHHH			* remainder high longword
F00:6054       
F00:6055       * now if we got the divide correct then the remainder high longword will be +ve
F00:6056       
F00:6057       	BPL.s		L_DDIV			* branch if result is ok (<needed)
               S01:00E01E7A:  6A 08
F00:6058       
F00:6059       * remainder was -ve so DDDD is too big
F00:6060       
F00:6061       LAB_REMM
F00:6062       	SUBQ.w	#1,d1				* adjust DDDD
               S01:00E01E7C:  53 41
F00:6063       
F00:6064       * d3				xxxx	FFFF		* denominator copy
F00:6065       * d6				xxxx	IIII		* remainder low word
F00:6066       
F00:6067       	ADD.w		d3,d6				* add EF*1 low remainder low word
               S01:00E01E7E:  DC 43
F00:6068       
F00:6069       * d5			0000	EEEE			* denominator high word
F00:6070       * d2			GGGG	HHHH			* remainder high longword
F00:6071       
F00:6072       	ADDX.l	d5,d2				* add extend EF*1 to remainder high longword
               S01:00E01E80:  D5 85
F00:6073       	BMI.s		LAB_REMM			* loop if result still too big
               S01:00E01E82:  6B F8
F00:6074       
F00:6075       * all done and result correct or <
F00:6076       
F00:6077       L_DDIV
F00:6078       	SWAP		d2				* remainder mid word to high word
               S01:00E01E84:  48 42
F00:6079       
F00:6080       * d2			HHHH	GGGG			* (high word /should/ be $0000)
F00:6081       
F00:6082       	MOVE.w	d6,d2				* remainder in high word
               S01:00E01E86:  34 06
F00:6083       
F00:6084       * d2				HHHH	IIII		* now is 32 bit remainder
F00:6085       * d1			xxxx	DDDD			* 16 bit result
F00:6086       
F00:6087       	RTS
               S01:00E01E88:  4E 75
F00:6088       
F00:6089       
F00:6090       *************************************************************************************
F00:6091       *
F00:6092       * unpack memory (a0) into FAC1
F00:6093       
F00:6094       LAB_UFAC
F00:6095       	MOVE.l	(a0),d0			* get packed value
               S01:00E01E8A:  20 10
F00:6096       	SWAP		d0				* exponent and sign into least significant word
               S01:00E01E8C:  48 40
F00:6097       	MOVE.w	d0,FAC1_e(a3)		* save exponent and sign
               S01:00E01E8E:  37 40 05 94
F00:6098       	BEQ.s		LAB_NB1T			* branch if exponent (and the rest) zero
               S01:00E01E92:  67 08
F00:6099       
F00:6100       	OR.w		#$80,d0			* set MSb
               S01:00E01E94:  80 7C 00 80
F00:6101       	SWAP		d0				* word order back to normal
               S01:00E01E98:  48 40
F00:6102       	ASL.l		#8,d0				* shift exponent & clear guard byte
               S01:00E01E9A:  E1 80
F00:6103       LAB_NB1T
F00:6104       	MOVE.l	d0,FAC1_m(a3)		* move into FAC1
               S01:00E01E9C:  27 40 05 90
F00:6105       
F00:6106       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E01EA0:  10 2B 05 94
F00:6107       	RTS
               S01:00E01EA4:  4E 75
F00:6108       
F00:6109       
F00:6110       *************************************************************************************
F00:6111       *
F00:6112       * set numeric variable, pack FAC1 into Lvarpl
F00:6113       
F00:6114       LAB_PFAC
F00:6115       	MOVE.l	a0,-(sp)			* save pointer
               S01:00E01EA6:  2F 08
F00:6116       	MOVEA.l	Lvarpl(a3),a0		* get destination pointer
               S01:00E01EA8:  20 6B 04 72
F00:6117       	BTST		#6,Dtypef(a3)		* test data type
               S01:00E01EAC:  08 2B 00 06 05 B5
F00:6118       	BEQ.s		LAB_277C			* branch if floating
               S01:00E01EB2:  67 0C
F00:6119       
F00:6120       	BSR		LAB_2831			* convert FAC1 floating to fixed
               S01:00E01EB4:  61 00 00 C6
F00:6121       							* result in d0 and Itemp
F00:6122       	MOVE.l	d0,(a0)			* save in var
               S01:00E01EB8:  20 80
F00:6123       	MOVE.l	(sp)+,a0			* restore pointer
               S01:00E01EBA:  20 5F
F00:6124       	RTS
               S01:00E01EBC:  4E 75
F00:6125       
F00:6126       
F00:6127       *************************************************************************************
F00:6128       *
F00:6129       * normalise round and pack FAC1 into (a0)
F00:6130       
F00:6131       LAB_2778
F00:6132       	MOVE.l	a0,-(sp)			* save pointer
               S01:00E01EBE:  2F 08
F00:6133       LAB_277C
F00:6134       	BSR		LAB_24D5			* normalise FAC1
               S01:00E01EC0:  61 00 FD 60
F00:6135       	BSR.s		LAB_27BA			* round FAC1
               S01:00E01EC4:  61 2C
F00:6136       	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
               S01:00E01EC6:  20 2B 05 90
F00:6137       	ROR.l		#8,d0				* align 24/32 bit mantissa
               S01:00E01ECA:  E0 98
F00:6138       	SWAP		d0				* exponent/sign into 0-15
               S01:00E01ECC:  48 40
F00:6139       	AND.w		#$7F,d0			* clear exponent and sign bit
               S01:00E01ECE:  C0 7C 00 7F
F00:6140       	ANDI.b	#$80,FAC1_s(a3)		* clear non sign bits in sign
               S01:00E01ED2:  02 2B 00 80 05 95
F00:6141       	OR.w		FAC1_e(a3),d0		* OR in exponent and sign
               S01:00E01ED8:  80 6B 05 94
F00:6142       	SWAP		d0				* move exponent and sign back to 16-31
               S01:00E01EDC:  48 40
F00:6143       	MOVE.l	d0,(a0)			* store in destination
               S01:00E01EDE:  20 80
F00:6144       	MOVE.l	(sp)+,a0			* restore pointer
               S01:00E01EE0:  20 5F
F00:6145       	RTS
               S01:00E01EE2:  4E 75
F00:6146       
F00:6147       
F00:6148       *************************************************************************************
F00:6149       *
F00:6150       * copy FAC2 to FAC1
F00:6151       
F00:6152       LAB_279B
F00:6153       	MOVE.w	FAC2_e(a3),FAC1_e(a3)	* copy exponent & sign
               S01:00E01EE4:  37 6B 05 9C 05 94
F00:6154       	MOVE.l	FAC2_m(a3),FAC1_m(a3)	* copy mantissa
               S01:00E01EEA:  27 6B 05 98 05 90
F00:6155       	RTS
               S01:00E01EF0:  4E 75
F00:6156       
F00:6157       
F00:6158       *************************************************************************************
F00:6159       *
F00:6160       * round FAC1
F00:6161       
F00:6162       LAB_27BA
F00:6163       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E01EF2:  10 2B 05 94
F00:6164       	BEQ.s		LAB_27C4			* branch if zero
               S01:00E01EF6:  67 20
F00:6165       
F00:6166       	MOVE.l	FAC1_m(a3),d0		* get FAC1
               S01:00E01EF8:  20 2B 05 90
F00:6167       	ADD.l		#$80,d0			* round to 24 bit
               S01:00E01EFC:  D0 BC 00 00 00 80
F00:6168       	BCC.s		LAB_27C3			* branch if no overflow
               S01:00E01F02:  64 0A
F00:6169       
F00:6170       	ROXR.l	#1,d0				* shift FAC1 mantissa
               S01:00E01F04:  E2 90
F00:6171       	ADDQ.b	#1,FAC1_e(a3)		* correct exponent
               S01:00E01F06:  52 2B 05 94
F00:6172       	BCS		LAB_OFER			* if carry do overflow error & warm start
               S01:00E01F0A:  65 00 E3 5E
F00:6173       
F00:6174       LAB_27C3
F00:6175       	AND.b		#$00,d0			* clear guard byte
               S01:00E01F0E:  C0 3C 00 00
F00:6176       	MOVE.l	d0,FAC1_m(a3)		* save back to FAC1
               S01:00E01F12:  27 40 05 90
F00:6177       	RTS
               S01:00E01F16:  4E 75
F00:6178       
F00:6179       LAB_27C4
F00:6180       	MOVE.b	d0,FAC1_s(a3)		* make zero always +ve
               S01:00E01F18:  17 40 05 95
F00:6181       RTS_017
F00:6182       	RTS
               S01:00E01F1C:  4E 75
F00:6183       
F00:6184       
F00:6185       *************************************************************************************
F00:6186       *
F00:6187       * get FAC1 sign
F00:6188       * return d0=-1,C=1/-ve d0=+1,C=0/+ve
F00:6189       
F00:6190       LAB_27CA
F00:6191       	MOVEQ		#0,d0				* clear d0
               S01:00E01F1E:  70 00
F00:6192       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E01F20:  10 2B 05 94
F00:6193       	BEQ.s		RTS_017			* exit if zero (already correct SGN(0)=0)
               S01:00E01F24:  67 F6
F00:6194       
F00:6195       
F00:6196       *************************************************************************************
F00:6197       *
F00:6198       * return d0=-1,C=1/-ve d0=+1,C=0/+ve
F00:6199       * no = 0 check
F00:6200       
F00:6201       LAB_27CE
F00:6202       	MOVE.b	FAC1_s(a3),d0		* else get FAC1 sign (b7)
               S01:00E01F26:  10 2B 05 95
F00:6203       
F00:6204       
F00:6205       *************************************************************************************
F00:6206       *
F00:6207       * return d0=-1,C=1/-ve d0=+1,C=0/+ve
F00:6208       * no = 0 check, sign in d0
F00:6209       
F00:6210       LAB_27D0
F00:6211       	EXT.w		d0				* make word
               S01:00E01F2A:  48 80
F00:6212       	EXT.l		d0				* make longword
               S01:00E01F2C:  48 C0
F00:6213       	ASR.l		#8,d0				* move sign bit through byte to carry
               S01:00E01F2E:  E0 80
F00:6214       	BCS.s		RTS_017			* exit if carry set
               S01:00E01F30:  65 EA
F00:6215       
F00:6216       	MOVEQ		#1,d0				* set result for +ve sign
               S01:00E01F32:  70 01
F00:6217       	RTS
               S01:00E01F34:  4E 75
F00:6218       
F00:6219       
F00:6220       *************************************************************************************
F00:6221       *
F00:6222       * perform SGN()
F00:6223       
F00:6224       LAB_SGN
F00:6225       	BSR.s		LAB_27CA			* get FAC1 sign
               S01:00E01F36:  61 E6
F00:6226       							* return d0=-1/-ve d0=+1/+ve
F00:6227       
F00:6228       
F00:6229       *************************************************************************************
F00:6230       *
F00:6231       * save d0 as integer longword
F00:6232       
F00:6233       LAB_27DB
F00:6234       	MOVE.l	d0,FAC1_m(a3)		* save FAC1 mantissa
               S01:00E01F38:  27 40 05 90
F00:6235       	MOVE.w	#$A000,FAC1_e(a3)		* set FAC1 exponent & sign
               S01:00E01F3C:  37 7C A0 00 05 94
F00:6236       	ADD.l		d0,d0				* top bit into carry
               S01:00E01F42:  D0 80
F00:6237       	BRA		LAB_24D0			* do +/- (carry is sign) & normalise FAC1
               S01:00E01F44:  60 00 FC D2
F00:6238       
F00:6239       
F00:6240       *************************************************************************************
F00:6241       *
F00:6242       * perform ABS()
F00:6243       
F00:6244       LAB_ABS
F00:6245       	MOVE.b	#0,FAC1_s(a3)		* clear FAC1 sign
               S01:00E01F48:  17 7C 00 00 05 95
F00:6246       	RTS
               S01:00E01F4E:  4E 75
F00:6247       
F00:6248       
F00:6249       *************************************************************************************
F00:6250       *
F00:6251       * compare FAC1 with FAC2
F00:6252       * returns d0=+1 Cb=0 if FAC1 > FAC2
F00:6253       * returns d0= 0 Cb=0 if FAC1 = FAC2
F00:6254       * returns d0=-1 Cb=1 if FAC1 < FAC2
F00:6255       
F00:6256       LAB_27FA
F00:6257       	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
               S01:00E01F50:  12 2B 05 9C
F00:6258       	BEQ.s		LAB_27CA			* branch if FAC2 exponent=0 & get FAC1 sign
               S01:00E01F54:  67 C8
F00:6259       							* d0=-1,C=1/-ve d0=+1,C=0/+ve
F00:6260       
F00:6261       	MOVE.b	FAC_sc(a3),d0		* get FAC sign compare
               S01:00E01F56:  10 2B 05 9E
F00:6262       	BMI.s		LAB_27CE			* if signs <> do return d0=-1,C=1/-ve
               S01:00E01F5A:  6B CA
F00:6263       							* d0=+1,C=0/+ve & return
F00:6264       
F00:6265       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
               S01:00E01F5C:  10 2B 05 95
F00:6266       	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
               S01:00E01F60:  B2 2B 05 94
F00:6267       	BNE.s		LAB_2828			* branch if different
               S01:00E01F64:  66 0A
F00:6268       
F00:6269       	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
               S01:00E01F66:  22 2B 05 98
F00:6270       	CMP.l		FAC1_m(a3),d1		* compare mantissas
               S01:00E01F6A:  B2 AB 05 90
F00:6271       	BEQ.s		LAB_282F			* exit if mantissas equal
               S01:00E01F6E:  67 08
F00:6272       
F00:6273       * gets here if number <> FAC1
F00:6274       
F00:6275       LAB_2828
F00:6276       	BCS.s		LAB_27D0			* if FAC1 > FAC2 return d0=-1,C=1/-ve d0=+1,
               S01:00E01F70:  65 B8
F00:6277       							* C=0/+ve
F00:6278       
F00:6279       	EORI.b	#$80,d0			* else toggle FAC1 sign
               S01:00E01F72:  0A 00 00 80
F00:6280       LAB_282E
F00:6281       	BRA.s		LAB_27D0			* return d0=-1,C=1/-ve d0=+1,C=0/+ve
               S01:00E01F76:  60 B2
F00:6282       
F00:6283       LAB_282F
F00:6284       	MOVEQ		#0,d0				* clear result
               S01:00E01F78:  70 00
F00:6285       	RTS
               S01:00E01F7A:  4E 75
F00:6286       
F00:6287       
F00:6288       *************************************************************************************
F00:6289       *
F00:6290       * convert FAC1 floating to fixed
F00:6291       * result in d0 and Itemp, sets flags correctly
F00:6292       
F00:6293       LAB_2831
F00:6294       	MOVE.l	FAC1_m(a3),d0		* copy mantissa
               S01:00E01F7C:  20 2B 05 90
F00:6295       	BEQ.s		LAB_284J			* branch if mantissa = 0
               S01:00E01F80:  67 30
F00:6296       
F00:6297       	MOVE.l	d1,-(sp)			* save d1
               S01:00E01F82:  2F 01
F00:6298       	MOVEQ		#$A0,d1			* set for no floating bits
               S01:00E01F84:  72 A0
F00:6299       	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent
               S01:00E01F86:  92 2B 05 94
F00:6300       	BCS		LAB_OFER			* do overflow if too big
               S01:00E01F8A:  65 00 E2 DE
F00:6301       
F00:6302       	BNE.s		LAB_284G			* branch if exponent was not $A0
               S01:00E01F8E:  66 0E
F00:6303       
F00:6304       	TST.b		FAC1_s(a3)			* test FAC1 sign
               S01:00E01F90:  4A 2B 05 95
F00:6305       	BPL.s		LAB_284H			* branch if FAC1 +ve
               S01:00E01F94:  6A 1A
F00:6306       
F00:6307       	NEG.l		d0
               S01:00E01F96:  44 80
F00:6308       	BVS.s		LAB_284H			* branch if was $80000000
               S01:00E01F98:  69 16
F00:6309       
F00:6310       	BRA		LAB_OFER			* do overflow if too big
               S01:00E01F9A:  60 00 E2 CE
F00:6311       
F00:6312       LAB_284G
F00:6313       	CMP.b		#$20,d1			* compare with minimum result for integer
               S01:00E01F9E:  B2 3C 00 20
F00:6314       	BCS		LAB_284L			* if < minimum just do shift
               S01:00E01FA2:  65 02
F00:6315       
F00:6316       	MOVEQ		#0,d0				* else return zero
               S01:00E01FA4:  70 00
F00:6317       LAB_284L
F00:6318       	LSR.l		d1,d0				* shift integer
               S01:00E01FA6:  E2 A8
F00:6319       
F00:6320       	TST.b		FAC1_s(a3)			* test FAC1 sign (b7)
               S01:00E01FA8:  4A 2B 05 95
F00:6321       	BPL.s		LAB_284H			* branch if FAC1 +ve
               S01:00E01FAC:  6A 02
F00:6322       
F00:6323       	NEG.l		d0				* negate integer value
               S01:00E01FAE:  44 80
F00:6324       LAB_284H
F00:6325       	MOVE.l	(sp)+,d1			* restore d1
               S01:00E01FB0:  22 1F
F00:6326       LAB_284J
F00:6327       	MOVE.l	d0,Itemp(a3)		* save the result
               S01:00E01FB2:  27 40 04 2A
F00:6328       	RTS
               S01:00E01FB6:  4E 75
F00:6329       
F00:6330       
F00:6331       *************************************************************************************
F00:6332       *
F00:6333       * perform INT()
F00:6334       
F00:6335       LAB_INT
F00:6336       	MOVEQ		#$A0,d0			* set for no floating bits
               S01:00E01FB8:  70 A0
F00:6337       	SUB.b		FAC1_e(a3),d0		* subtract FAC1 exponent
               S01:00E01FBA:  90 2B 05 94
F00:6338       	BLS.s		LAB_IRTS			* exit if exponent >= $A0
               S01:00E01FBE:  63 10
F00:6339       							* (too big for fraction part!)
F00:6340       
F00:6341       	CMP.b		#$20,d0			* compare with minimum result for integer
               S01:00E01FC0:  B0 3C 00 20
F00:6342       	BCC		LAB_POZE			* if >= minimum go return 0
               S01:00E01FC4:  64 00 02 5E
F00:6343       							* (too small for integer part!)
F00:6344       
F00:6345       	MOVEQ		#-1,d1			* set integer mask
               S01:00E01FC8:  72 FF
F00:6346       	ASL.l		d0,d1				* shift mask [8+2*d0]
               S01:00E01FCA:  E1 A1
F00:6347       	AND.l		d1,FAC1_m(a3)		* mask mantissa
               S01:00E01FCC:  C3 AB 05 90
F00:6348       LAB_IRTS
F00:6349       	RTS
               S01:00E01FD0:  4E 75
F00:6350       
F00:6351       
F00:6352       *************************************************************************************
F00:6353       *
F00:6354       * print " in line [LINE #]"
F00:6355       
F00:6356       LAB_2953
F00:6357       	LEA		LAB_LMSG(pc),a0		* point to " in line " message
               S01:00E01FD2:  41 FA 18 84
F00:6358       	BSR		LAB_18C3			* print null terminated string
               S01:00E01FD6:  61 00 EB 14
F00:6359       
F00:6360       							* Print Basic line #
F00:6361       	MOVE.l	Clinel(a3),d0		* get current line
               S01:00E01FDA:  20 2B 04 52
F00:6362       
F00:6363       
F00:6364       *************************************************************************************
F00:6365       *
F00:6366       * print d0 as unsigned integer
F00:6367       
F00:6368       LAB_295E
F00:6369       	LEA		Bin2dec(pc),a1		* get table address
               S01:00E01FDE:  43 FA 0D DE
F00:6370       	MOVEQ		#0,d1				* table index
               S01:00E01FE2:  72 00
F00:6371       	LEA		Usdss(a3),a0		* output string start
               S01:00E01FE4:  41 EB 05 CC
F00:6372       	MOVE.l	d1,d2				* output string index
               S01:00E01FE8:  24 01
F00:6373       LAB_2967
F00:6374       	MOVE.l	(a1,d1.w),d3		* get table value
               S01:00E01FEA:  26 31 10 00
F00:6375       	BEQ.s		LAB_2969			* exit if end marker
               S01:00E01FEE:  67 14
F00:6376       
F00:6377       	MOVEQ		#'0'-1,d4			* set character to "0"-1
               S01:00E01FF0:  78 2F
F00:6378       LAB_2968
F00:6379       	ADDQ.w	#1,d4				* next numeric character
               S01:00E01FF2:  52 44
F00:6380       	SUB.l		d3,d0				* subtract table value
               S01:00E01FF4:  90 83
F00:6381       	BPL.s		LAB_2968			* not overdone so loop
               S01:00E01FF6:  6A FA
F00:6382       
F00:6383       	ADD.l		d3,d0				* correct value
               S01:00E01FF8:  D0 83
F00:6384       	MOVE.b	d4,(a0,d2.w)		* character out to string
               S01:00E01FFA:  11 84 20 00
F00:6385       	ADDQ.w	#4,d1				* increment table pointer
               S01:00E01FFE:  58 41
F00:6386       	ADDQ.w	#1,d2				* increment output string pointer
               S01:00E02000:  52 42
F00:6387       	BRA.s		LAB_2967			* loop
               S01:00E02002:  60 E6
F00:6388       
F00:6389       LAB_2969
F00:6390       	ADD.b		#'0',d0			* make last character
               S01:00E02004:  D0 3C 00 30
F00:6391       	MOVE.b	d0,(a0,d2.w)		* character out to string
               S01:00E02008:  11 80 20 00
F00:6392       	SUBQ.w	#1,a0				* decrement a0 (allow simple loop)
               S01:00E0200C:  53 48
F00:6393       
F00:6394       							* now find non zero start of string
F00:6395       LAB_296A
F00:6396       	ADDQ.w	#1,a0				* increment a0 (this will never carry to b16)
               S01:00E0200E:  52 48
F00:6397       	LEA		BHsend-1(a3),a1		* get string end
               S01:00E02010:  43 EB 05 D5
F00:6398       	CMPA.l	a1,a0				* are we at end
               S01:00E02014:  B1 C9
F00:6399       	BEQ		LAB_18C3			* if so print null terminated string and RETURN
               S01:00E02016:  67 00 EA D4
F00:6400       
F00:6401       	CMPI.b	#'0',(a0)			* is character "0" ?
               S01:00E0201A:  0C 10 00 30
F00:6402       	BEQ.s		LAB_296A			* loop if so
               S01:00E0201E:  67 EE
F00:6403       
F00:6404       	BRA		LAB_18C3			* print null terminated string from memory & RET
               S01:00E02020:  60 00 EA CA
F00:6405       
F00:6406       
F00:6407       *************************************************************************************
F00:6408       *
F00:6409       * convert FAC1 to ASCII string result in (a0)
F00:6410       * STR$() function enters here
F00:6411       
F00:6412       * now outputs 7 significant digits
F00:6413       
F00:6414       * d0 is character out
F00:6415       * d1 is save index
F00:6416       * d2 is gash
F00:6417       
F00:6418       * a0 is output string pointer
F00:6419       
F00:6420       LAB_2970
F00:6421       	LEA		Decss(a3),a1		* set output string start
               S01:00E02024:  43 EB 05 C6
F00:6422       
F00:6423       	MOVEQ		#' ',d2			* character = " ", assume +ve
               S01:00E02028:  74 20
F00:6424       	BCLR.b	#7,FAC1_s(a3)		* test and clear FAC1 sign (b7)
               S01:00E0202A:  08 AB 00 07 05 95
F00:6425       	BEQ.s		LAB_2978			* branch if +ve
               S01:00E02030:  67 02
F00:6426       
F00:6427       	MOVEQ		#'-',d2			* else character = "-"
               S01:00E02032:  74 2D
F00:6428       LAB_2978
F00:6429       	MOVE.b	d2,(a1)			* save the sign character
               S01:00E02034:  12 82
F00:6430       	MOVE.b	FAC1_e(a3),d2		* get FAC1 exponent
               S01:00E02036:  14 2B 05 94
F00:6431       	BNE.s		LAB_2989			* branch if FAC1<>0
               S01:00E0203A:  66 08
F00:6432       
F00:6433       							* exponent was $00 so FAC1 is 0
F00:6434       	MOVEQ		#'0',d0			* set character = "0"
               S01:00E0203C:  70 30
F00:6435       	MOVEQ		#1,d1				* set output string index
               S01:00E0203E:  72 01
F00:6436       	BRA		LAB_2A89			* save last character, [EOT] & exit
               S01:00E02040:  60 00 01 A4
F00:6437       
F00:6438       							* FAC1 is some non zero value
F00:6439       LAB_2989
F00:6440       	MOVE.b	#0,numexp(a3)		* clear number exponent count
               S01:00E02044:  17 7C 00 00 05 AC
F00:6441       	CMP.b		#$81,d2			* compare FAC1 exponent with $81 (>1.00000)
               S01:00E0204A:  B4 3C 00 81
F00:6442       
F00:6443       	BCC.s		LAB_299C			* branch if FAC1=>1
               S01:00E0204E:  64 48
F00:6444       
F00:6445       							* else FAC1 < 1
F00:6446       	MOVE.l	#$98968000,FAC2_m(a3)	* 10000000 mantissa
               S01:00E02050:  27 7C 98 96 80 00 05 98
F00:6447       	MOVE.w	#$9800,FAC2_e(a3)		* 10000000 exponent & sign
               S01:00E02058:  37 7C 98 00 05 9C
F00:6448       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* make FAC1 sign sign compare
               S01:00E0205E:  17 6B 05 95 05 9E
F00:6449       	BSR		LAB_MULTIPLY		* do FAC2*FAC1
               S01:00E02064:  61 00 FC E4
F00:6450       
F00:6451       	MOVE.b	#$F9,numexp(a3)		* set number exponent count (-7)
               S01:00E02068:  17 7C 00 F9 05 AC
F00:6452       	BRA.s		LAB_299C			* go test for fit
               S01:00E0206E:  60 28
F00:6453       
F00:6454       LAB_29B9
F00:6455       	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
               S01:00E02070:  37 6B 05 94 05 9C
F00:6456       	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
               S01:00E02076:  27 6B 05 90 05 98
F00:6457       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* save FAC1_s as sign compare
               S01:00E0207C:  17 6B 05 95 05 9E
F00:6458       
F00:6459       	MOVE.l	#$CCCCCCCD,FAC1_m(a3)	* 1/10 mantissa
               S01:00E02082:  27 7C CC CC CC CD 05 90
F00:6460       	MOVE.w	#$7D00,FAC1_e(a3)		* 1/10 exponent & sign
               S01:00E0208A:  37 7C 7D 00 05 94
F00:6461       	BSR		LAB_MULTIPLY		* do FAC2*FAC1, effectively divide by 10 but
               S01:00E02090:  61 00 FC B8
F00:6462       							* faster
F00:6463       
F00:6464       	ADDQ.b	#1,numexp(a3)		* increment number exponent count
               S01:00E02094:  52 2B 05 AC
F00:6465       LAB_299C
F00:6466       	MOVE.l	#$98967F70,FAC2_m(a3)	* 9999999.4375 mantissa
               S01:00E02098:  27 7C 98 96 7F 70 05 98
F00:6467       	MOVE.w	#$9800,FAC2_e(a3)		* 9999999.4375 exponent & sign
               S01:00E020A0:  37 7C 98 00 05 9C
F00:6468       							* (max before scientific notation)
F00:6469       	BSR		LAB_27F0			* fast compare FAC1 with FAC2
               S01:00E020A6:  61 00 01 4C
F00:6470       							* returns d0=+1 C=0 if FAC1 > FAC2
F00:6471       							* returns d0= 0 C=0 if FAC1 = FAC2
F00:6472       							* returns d0=-1 C=1 if FAC1 < FAC2
F00:6473       	BHI.s		LAB_29B9			* go do /10 if FAC1 > 9999999.4375
               S01:00E020AA:  62 C4
F00:6474       
F00:6475       	BEQ.s		LAB_29C3			* branch if FAC1 = 9999999.4375
               S01:00E020AC:  67 50
F00:6476       
F00:6477       							* FAC1 < 9999999.4375
F00:6478       	MOVE.l	#$F423F800,FAC2_m(a3)	* set mantissa for 999999.5
               S01:00E020AE:  27 7C F4 23 F8 00 05 98
F00:6479       	MOVE.w	#$9400,FAC2_e(a3)		* set exponent for 999999.5
               S01:00E020B6:  37 7C 94 00 05 9C
F00:6480       	LEA		FAC1_m(a3),a0		* set pointer for x10
               S01:00E020BC:  41 EB 05 90
F00:6481       LAB_29A7
F00:6482       	BSR		LAB_27F0			* fast compare FAC1 with FAC2
               S01:00E020C0:  61 00 01 32
F00:6483       							* returns d0=+1 C=0 if FAC1 > FAC2
F00:6484       							* returns d0= 0 C=0 if FAC1 = FAC2
F00:6485       							* returns d0=-1 C=1 if FAC1 < FAC2
F00:6486       	BHI.s		LAB_29C0			* branch if FAC1 > 99999.9375,no decimal places
               S01:00E020C4:  62 20
F00:6487       
F00:6488       							* FAC1 <= 999999.5 so do x 10
F00:6489       	MOVE.l	(a0),d0			* get FAC1 mantissa
               S01:00E020C6:  20 10
F00:6490       	MOVE.b	4(a0),d1			* get FAC1 exponent
               S01:00E020C8:  12 28 00 04
F00:6491       	MOVE.l	d0,d2				* copy it
               S01:00E020CC:  24 00
F00:6492       	LSR.l		#2,d0				* /4
               S01:00E020CE:  E4 88
F00:6493       	ADD.l		d2,d0				* add FAC1 (x1.125)
               S01:00E020D0:  D0 82
F00:6494       	BCC.s		LAB_29B7			* branch if no carry
               S01:00E020D2:  64 04
F00:6495       
F00:6496       	ROXR.l	#1,d0				* shift carry back in
               S01:00E020D4:  E2 90
F00:6497       	ADDQ.b	#1,d1				* increment exponent (never overflows)
               S01:00E020D6:  52 01
F00:6498       LAB_29B7
F00:6499       	ADDQ.b	#3,d1				* correct exponent ( 8 x 1.125 = 10 )
               S01:00E020D8:  56 01
F00:6500       							* (never overflows)
F00:6501       	MOVE.l	d0,(a0)			* save new mantissa
               S01:00E020DA:  20 80
F00:6502       	MOVE.b	d1,4(a0)			* save new exponent
               S01:00E020DC:  11 41 00 04
F00:6503       	SUBQ.b	#1,numexp(a3)		* decrement number exponent count
               S01:00E020E0:  53 2B 05 AC
F00:6504       	BRA.s		LAB_29A7			* go test again
               S01:00E020E4:  60 DA
F00:6505       
F00:6506       							* now we have just the digits to do
F00:6507       LAB_29C0
F00:6508       	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 0.5
               S01:00E020E6:  27 7C 80 00 00 00 05 98
F00:6509       	MOVE.w	#$8000,FAC2_e(a3)		* set exponent for 0.5
               S01:00E020EE:  37 7C 80 00 05 9C
F00:6510       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
               S01:00E020F4:  17 6B 05 95 05 9E
F00:6511       	BSR		LAB_ADD			* add the 0.5 to FAC1 (round FAC1)
               S01:00E020FA:  61 00 FA AC
F00:6512       
F00:6513       LAB_29C3
F00:6514       	BSR		LAB_2831			* convert FAC1 floating to fixed
               S01:00E020FE:  61 00 FE 7C
F00:6515       							* result in d0 and Itemp
F00:6516       	MOVEQ		#$01,d2			* set default digits before dp = 1
               S01:00E02102:  74 01
F00:6517       	MOVE.b	numexp(a3),d0		* get number exponent count
               S01:00E02104:  10 2B 05 AC
F00:6518       	ADD.b		#8,d0				* allow 7 digits before point
               S01:00E02108:  50 00
F00:6519       	BMI.s		LAB_29D9			* if -ve then 1 digit before dp
               S01:00E0210A:  6B 0C
F00:6520       
F00:6521       	CMP.b		#$09,d0			* d0>=9 if n>=1E7
               S01:00E0210C:  B0 3C 00 09
F00:6522       	BCC.s		LAB_29D9			* branch if >= $09
               S01:00E02110:  64 06
F00:6523       
F00:6524       							* < $08
F00:6525       	SUBQ.b	#1,d0				* take 1 from digit count
               S01:00E02112:  53 00
F00:6526       	MOVE.b	d0,d2				* copy byte
               S01:00E02114:  14 00
F00:6527       	MOVEQ		#$02,d0			* set exponent adjust
               S01:00E02116:  70 02
F00:6528       LAB_29D9
F00:6529       	MOVEQ		#0,d1				* set output string index
               S01:00E02118:  72 00
F00:6530       	SUBQ.b	#2,d0				* -2
               S01:00E0211A:  55 00
F00:6531       	MOVE.b	d0,expcnt(a3)		* save exponent adjust
               S01:00E0211C:  17 40 05 AD
F00:6532       	MOVE.b	d2,numexp(a3)		* save digits before dp count
               S01:00E02120:  17 42 05 AC
F00:6533       	MOVE.b	d2,d0				* copy digits before dp count
               S01:00E02124:  10 02
F00:6534       	BEQ.s		LAB_29E4			* branch if no digits before dp
               S01:00E02126:  67 02
F00:6535       
F00:6536       	BPL.s		LAB_29F7			* branch if digits before dp
               S01:00E02128:  6A 14
F00:6537       
F00:6538       LAB_29E4
F00:6539       	ADDQ.l	#1,d1				* increment index
               S01:00E0212A:  52 81
F00:6540       	MOVE.b	#'.',(a1,d1.w)		* save to output string
               S01:00E0212C:  13 BC 00 2E 10 00
F00:6541       
F00:6542       	TST.b		d2				* test digits before dp count
               S01:00E02132:  4A 02
F00:6543       	BEQ.s		LAB_29F7			* branch if no digits before dp
               S01:00E02134:  67 08
F00:6544       
F00:6545       	ADDQ.l	#1,d1				* increment index
               S01:00E02136:  52 81
F00:6546       	MOVE.b	#'0',(a1,d1.w)		* save to output string
               S01:00E02138:  13 BC 00 30 10 00
F00:6547       LAB_29F7
F00:6548       	MOVEQ		#0,d2				* clear index (point to 1,000,000)
               S01:00E0213E:  74 00
F00:6549       	MOVEQ		#$80-$100,d0		* set output character
               S01:00E02140:  70 80
F00:6550       LAB_29FB
F00:6551       	LEA		LAB_2A9A(pc),a0		* get base of table
               S01:00E02142:  41 FA 11 36
F00:6552       	MOVE.l	(a0,d2.w),d3		* get table value
               S01:00E02146:  26 30 20 00
F00:6553       LAB_29FD
F00:6554       	ADDQ.b	#1,d0				* increment output character
               S01:00E0214A:  52 00
F00:6555       	ADD.l		d3,Itemp(a3)		* add to (now fixed) mantissa
               S01:00E0214C:  D7 AB 04 2A
F00:6556       	BTST		#7,d0				* set test sense (z flag only)
               S01:00E02150:  08 00 00 07
F00:6557       	BCS.s		LAB_2A18			* did carry so has wrapped past zero
               S01:00E02154:  65 04
F00:6558       
F00:6559       	BEQ.s		LAB_29FD			* no wrap and +ve test so try again
               S01:00E02156:  67 F2
F00:6560       
F00:6561       	BRA.s		LAB_2A1A			* found this digit
               S01:00E02158:  60 02
F00:6562       
F00:6563       LAB_2A18
F00:6564       	BNE.s		LAB_29FD			* wrap and -ve test so try again
               S01:00E0215A:  66 EE
F00:6565       
F00:6566       LAB_2A1A
F00:6567       	BCC.s		LAB_2A21			* branch if +ve test result
               S01:00E0215C:  64 06
F00:6568       
F00:6569       	NEG.b		d0				* negate the digit number
               S01:00E0215E:  44 00
F00:6570       	ADD.b		#$0B,d0			* and subtract from 11 decimal
               S01:00E02160:  D0 3C 00 0B
F00:6571       LAB_2A21
F00:6572       	ADD.b		#$2F,d0			* add "0"-1 to result
               S01:00E02164:  D0 3C 00 2F
F00:6573       	ADDQ.w	#4,d2				* increment index to next less power of ten
               S01:00E02168:  58 42
F00:6574       	ADDQ.w	#1,d1				* increment output string index
               S01:00E0216A:  52 41
F00:6575       	MOVE.b	d0,d3				* copy character to d3
               S01:00E0216C:  16 00
F00:6576       	AND.b		#$7F,d3			* mask out top bit
               S01:00E0216E:  C6 3C 00 7F
F00:6577       	MOVE.b	d3,(a1,d1.w)		* save to output string
               S01:00E02172:  13 83 10 00
F00:6578       	SUB.b		#1,numexp(a3)		* decrement # of characters before the dp
               S01:00E02176:  53 2B 05 AC
F00:6579       	BNE.s		LAB_2A3B			* branch if still characters to do
               S01:00E0217A:  66 08
F00:6580       
F00:6581       							* else output the point
F00:6582       	ADDQ.l	#1,d1				* increment index
               S01:00E0217C:  52 81
F00:6583       	MOVE.b	#'.',(a1,d1.w)		* save to output string
               S01:00E0217E:  13 BC 00 2E 10 00
F00:6584       LAB_2A3B
F00:6585       	AND.b		#$80,d0			* mask test sense bit
               S01:00E02184:  C0 3C 00 80
F00:6586       	EORI.b	#$80,d0			* invert it
               S01:00E02188:  0A 00 00 80
F00:6587       	CMP.b		#LAB_2A9B-LAB_2A9A,d2	* compare table index with max+4
               S01:00E0218C:  B4 3C 00 1C
F00:6588       	BNE.s		LAB_29FB			* loop if not max
               S01:00E02190:  66 B0
F00:6589       
F00:6590       							* now remove trailing zeroes
F00:6591       LAB_2A4B
F00:6592       	MOVE.b	(a1,d1.w),d0		* get character from output string
               S01:00E02192:  10 31 10 00
F00:6593       	SUBQ.l	#1,d1				* decrement output string index
               S01:00E02196:  53 81
F00:6594       	CMP.b		#'0',d0			* compare with "0"
               S01:00E02198:  B0 3C 00 30
F00:6595       	BEQ.s		LAB_2A4B			* loop until non "0" character found
               S01:00E0219C:  67 F4
F00:6596       
F00:6597       	CMP.b		#'.',d0			* compare with "."
               S01:00E0219E:  B0 3C 00 2E
F00:6598       	BEQ.s		LAB_2A58			* branch if was dp
               S01:00E021A2:  67 02
F00:6599       
F00:6600       							* else restore last character
F00:6601       	ADDQ.l	#1,d1				* increment output string index
               S01:00E021A4:  52 81
F00:6602       LAB_2A58
F00:6603       	MOVE.b	#'+',2(a1,d1.w)		* save character "+" to output string
               S01:00E021A6:  13 BC 00 2B 10 02
F00:6604       	TST.b		expcnt(a3)			* test exponent count
               S01:00E021AC:  4A 2B 05 AD
F00:6605       	BEQ.s		LAB_2A8C			* if zero go set null terminator & exit
               S01:00E021B0:  67 38
F00:6606       
F00:6607       							* exponent isn't zero so write exponent
F00:6608       	BPL.s		LAB_2A68			* branch if exponent count +ve
               S01:00E021B2:  6A 0A
F00:6609       
F00:6610       	MOVE.b	#'-',2(a1,d1.w)		* save character "-" to output string
               S01:00E021B4:  13 BC 00 2D 10 02
F00:6611       	NEG.b		expcnt(a3)			* convert -ve to +ve
               S01:00E021BA:  44 2B 05 AD
F00:6612       LAB_2A68
F00:6613       	MOVE.b	#'E',1(a1,d1.w)		* save character "E" to output string
               S01:00E021BE:  13 BC 00 45 10 01
F00:6614       	MOVE.b	expcnt(a3),d2		* get exponent count
               S01:00E021C4:  14 2B 05 AD
F00:6615       	MOVEQ		#$2F,d0			* one less than "0" character
               S01:00E021C8:  70 2F
F00:6616       LAB_2A74
F00:6617       	ADDQ.b	#1,d0				* increment 10's character
               S01:00E021CA:  52 00
F00:6618       	SUB.b		#$0A,d2			* subtract 10 from exponent count
               S01:00E021CC:  94 3C 00 0A
F00:6619       	BCC.s		LAB_2A74			* loop while still >= 0
               S01:00E021D0:  64 F8
F00:6620       
F00:6621       	ADD.b		#$3A,d2			* add character ":", $30+$0A, result is 10-value
               S01:00E021D2:  D4 3C 00 3A
F00:6622       	MOVE.b	d0,3(a1,d1.w)		* save 10's character to output string
               S01:00E021D6:  13 80 10 03
F00:6623       	MOVE.b	d2,4(a1,d1.w)		* save 1's character to output string
               S01:00E021DA:  13 82 10 04
F00:6624       	MOVE.b	#0,5(a1,d1.w)		* save null terminator after last character
               S01:00E021DE:  13 BC 00 00 10 05
F00:6625       	BRA.s		LAB_2A91			* go set string pointer (a0) and exit
               S01:00E021E4:  60 0A
F00:6626       
F00:6627       LAB_2A89
F00:6628       	MOVE.b	d0,(a1,d1.w)		* save last character to output string
               S01:00E021E6:  13 80 10 00
F00:6629       LAB_2A8C
F00:6630       	MOVE.b	#0,1(a1,d1.w)		* save null terminator after last character
               S01:00E021EA:  13 BC 00 00 10 01
F00:6631       LAB_2A91
F00:6632       	MOVEA.l	a1,a0				* set result string pointer (a0)
               S01:00E021F0:  20 49
F00:6633       	RTS
               S01:00E021F2:  4E 75
F00:6634       
F00:6635       
F00:6636       *************************************************************************************
F00:6637       *
F00:6638       * fast compare FAC1 with FAC2
F00:6639       * assumes both are +ve and FAC2>0
F00:6640       * returns d0=+1 C=0 if FAC1 > FAC2
F00:6641       * returns d0= 0 C=0 if FAC1 = FAC2
F00:6642       * returns d0=-1 C=1 if FAC1 < FAC2
F00:6643       
F00:6644       LAB_27F0
F00:6645       	MOVEQ		#0,d0				* set for FAC1 = FAC2
               S01:00E021F4:  70 00
F00:6646       	MOVE.b	FAC2_e(a3),d1		* get FAC2 exponent
               S01:00E021F6:  12 2B 05 9C
F00:6647       	CMP.b		FAC1_e(a3),d1		* compare FAC1 exponent with FAC2 exponent
               S01:00E021FA:  B2 2B 05 94
F00:6648       	BNE.s		LAB_27F1			* branch if different
               S01:00E021FE:  66 0A
F00:6649       
F00:6650       	MOVE.l	FAC2_m(a3),d1		* get FAC2 mantissa
               S01:00E02200:  22 2B 05 98
F00:6651       	CMP.l		FAC1_m(a3),d1		* compare mantissas
               S01:00E02204:  B2 AB 05 90
F00:6652       	BEQ.s		LAB_27F3			* exit if mantissas equal
               S01:00E02208:  67 08
F00:6653       
F00:6654       LAB_27F1
F00:6655       	BCS.s		LAB_27F2			* if FAC1 > FAC2 return d0=+1,C=0
               S01:00E0220A:  65 04
F00:6656       
F00:6657       	SUBQ.l	#1,d0				* else FAC1 < FAC2 return d0=-1,C=1
               S01:00E0220C:  53 80
F00:6658       	RTS
               S01:00E0220E:  4E 75
F00:6659       
F00:6660       LAB_27F2
F00:6661       	ADDQ.l	#1,d0
               S01:00E02210:  52 80
F00:6662       LAB_27F3
F00:6663       	RTS
               S01:00E02212:  4E 75
F00:6664       
F00:6665       
F00:6666       *************************************************************************************
F00:6667       *
F00:6668       * make FAC1 = 1
F00:6669       
F00:6670       LAB_POON
F00:6671       	MOVE.l	#$80000000,FAC1_m(a3)	* 1 mantissa
               S01:00E02214:  27 7C 80 00 00 00 05 90
F00:6672       	MOVE.w	#$8100,FAC1_e(a3)		* 1 exonent & sign
               S01:00E0221C:  37 7C 81 00 05 94
F00:6673       	RTS
               S01:00E02222:  4E 75
F00:6674       
F00:6675       
F00:6676       *************************************************************************************
F00:6677       *
F00:6678       * make FAC1 = 0
F00:6679       
F00:6680       LAB_POZE
F00:6681       	MOVEQ		#0,d0				* clear longword
               S01:00E02224:  70 00
F00:6682       	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
               S01:00E02226:  27 40 05 90
F00:6683       	MOVE.w	d0,FAC1_e(a3)		* 0 exonent & sign
               S01:00E0222A:  37 40 05 94
F00:6684       	RTS
               S01:00E0222E:  4E 75
F00:6685       
F00:6686       
F00:6687       *************************************************************************************
F00:6688       *
F00:6689       * Perform power function
F00:6690       * The number is in FAC2, the power is in FAC1
F00:6691       * no longer trashes Itemp
F00:6692       
F00:6693       LAB_POWER
F00:6694       	TST.b		FAC1_e(a3)			* test power
               S01:00E02230:  4A 2B 05 94
F00:6695       	BEQ.s		LAB_POON			* if zero go return 1
               S01:00E02234:  67 DE
F00:6696       
F00:6697       	TST.b		FAC2_e(a3)			* test number
               S01:00E02236:  4A 2B 05 9C
F00:6698       	BEQ.s		LAB_POZE			* if zero go return 0
               S01:00E0223A:  67 E8
F00:6699       
F00:6700       	MOVE.b	FAC2_s(a3),-(sp)		* save number sign
               S01:00E0223C:  1F 2B 05 9D
F00:6701       	BPL.s		LAB_POWP			* power of positive number
               S01:00E02240:  6A 20
F00:6702       
F00:6703       	MOVEQ		#0,d1				* clear d1
               S01:00E02242:  72 00
F00:6704       	MOVE.b	d1,FAC2_s(a3)		* make sign +ve
               S01:00E02244:  17 41 05 9D
F00:6705       
F00:6706       							* number sign was -ve and can only be raised to
F00:6707       							* an integer power which gives an x +j0 result,
F00:6708       							* else do 'function call' error
F00:6709       	MOVE.b	FAC1_e(a3),d1		* get power exponent
               S01:00E02248:  12 2B 05 94
F00:6710       	SUB.w		#$80,d1			* normalise to .5
               S01:00E0224C:  92 7C 00 80
F00:6711       	BLS		LAB_FCER			* if 0<power<1 then do 'function call' error
               S01:00E02250:  63 00 E0 1C
F00:6712       
F00:6713       							* now shift all the integer bits out
F00:6714       	MOVE.l	FAC1_m(a3),d0		* get power mantissa
               S01:00E02254:  20 2B 05 90
F00:6715       	ASL.l		d1,d0				* shift mantissa
               S01:00E02258:  E3 A0
F00:6716       	BNE		LAB_FCER			* if power<>INT(power) then do 'function call'
               S01:00E0225A:  66 00 E0 12
F00:6717       							* error
F00:6718       
F00:6719       	BCS.s		LAB_POWP			* if integer value odd then leave result -ve
               S01:00E0225E:  65 02
F00:6720       
F00:6721       	MOVE.b	d0,(sp)			* save result sign +ve
               S01:00E02260:  1E 80
F00:6722       LAB_POWP
F00:6723       	MOVE.l	FAC1_m(a3),-(sp)		* save power mantissa
               S01:00E02262:  2F 2B 05 90
F00:6724       	MOVE.w	FAC1_e(a3),-(sp)		* save power sign & exponent
               S01:00E02266:  3F 2B 05 94
F00:6725       
F00:6726       	BSR		LAB_279B			* copy number to FAC1
               S01:00E0226A:  61 00 FC 78
F00:6727       	BSR		LAB_LOG			* find log of number
               S01:00E0226E:  61 00 F9 E8
F00:6728       
F00:6729       	MOVE.w	(sp)+,d0			* get power sign & exponent
               S01:00E02272:  30 1F
F00:6730       	MOVE.l	(sp)+,FAC2_m(a3)		* get power mantissa
               S01:00E02274:  27 5F 05 98
F00:6731       	MOVE.w	d0,FAC2_e(a3)		* save sign & exponent to FAC2
               S01:00E02278:  37 40 05 9C
F00:6732       	MOVE.b	d0,FAC_sc(a3)		* save sign as sign compare
               S01:00E0227C:  17 40 05 9E
F00:6733       	MOVE.b	FAC1_s(a3),d0		* get FAC1 sign
               S01:00E02280:  10 2B 05 95
F00:6734       	EOR.b		d0,FAC_sc(a3)		* make sign compare (FAC1_s EOR FAC2_s)
               S01:00E02284:  B1 2B 05 9E
F00:6735       
F00:6736       	BSR		LAB_MULTIPLY		* multiply by power
               S01:00E02288:  61 00 FA C0
F00:6737       	BSR.s		LAB_EXP			* find exponential
               S01:00E0228C:  61 58
F00:6738       	MOVE.b	(sp)+,FAC1_s(a3)		* restore number sign
               S01:00E0228E:  17 5F 05 95
F00:6739       	RTS
               S01:00E02292:  4E 75
F00:6740       
F00:6741       
F00:6742       *************************************************************************************
F00:6743       *
F00:6744       * do - FAC1
F00:6745       
F00:6746       LAB_GTHAN
F00:6747       	TST.b		FAC1_e(a3)			* test for non zero FAC1
               S01:00E02294:  4A 2B 05 94
F00:6748       	BEQ.s		RTS_020			* branch if null
               S01:00E02298:  67 06
F00:6749       
F00:6750       	EORI.b	#$80,FAC1_s(a3)		* (else) toggle FAC1 sign bit
               S01:00E0229A:  0A 2B 00 80 05 95
F00:6751       RTS_020
F00:6752       	RTS
               S01:00E022A0:  4E 75
F00:6753       
F00:6754       
F00:6755       *************************************************************************************
F00:6756       *
F00:6757       							* return +1
F00:6758       LAB_EX1
F00:6759       	MOVE.l	#$80000000,FAC1_m(a3)	* +1 mantissa
               S01:00E022A2:  27 7C 80 00 00 00 05 90
F00:6760       	MOVE.w	#$8100,FAC1_e(a3)		* +1 sign & exponent
               S01:00E022AA:  37 7C 81 00 05 94
F00:6761       	RTS
               S01:00E022B0:  4E 75
F00:6762       							* do over/under flow
F00:6763       LAB_EXOU
F00:6764       	TST.b		FAC1_s(a3)			* test sign
               S01:00E022B2:  4A 2B 05 95
F00:6765       	BPL		LAB_OFER			* was +ve so do overflow error
               S01:00E022B6:  6A 00 DF B2
F00:6766       
F00:6767       							* else underflow so return zero
F00:6768       	MOVEQ		#0,d0				* clear longword
               S01:00E022BA:  70 00
F00:6769       	MOVE.l	d0,FAC1_m(a3)		* 0 mantissa
               S01:00E022BC:  27 40 05 90
F00:6770       	MOVE.w	d0,FAC1_e(a3)		* 0 sign & exponent
               S01:00E022C0:  37 40 05 94
F00:6771       	RTS
               S01:00E022C4:  4E 75
F00:6772       							* fraction was zero so do 2^n
F00:6773       LAB_EXOF
F00:6774       	MOVE.l	#$80000000,FAC1_m(a3)	* +n mantissa
               S01:00E022C6:  27 7C 80 00 00 00 05 90
F00:6775       	MOVE.b	#0,FAC1_s(a3)		* clear sign
               S01:00E022CE:  17 7C 00 00 05 95
F00:6776       	TST.b		cosout(a3)			* test sign flag
               S01:00E022D4:  4A 2B 05 B4
F00:6777       	BPL.s		LAB_EXOL			* branch if +ve
               S01:00E022D8:  6A 02
F00:6778       
F00:6779       	NEG.l		d1				* else do 1/2^n
               S01:00E022DA:  44 81
F00:6780       LAB_EXOL
F00:6781       	ADD.b		#$81,d1			* adjust exponent
               S01:00E022DC:  D2 3C 00 81
F00:6782       	MOVE.b	d1,FAC1_e(a3)		* save exponent
               S01:00E022E0:  17 41 05 94
F00:6783       	RTS
               S01:00E022E4:  4E 75
F00:6784       
F00:6785       * perform EXP()	(x^e)
F00:6786       * valid input range is -88 to +88
F00:6787       
F00:6788       LAB_EXP
F00:6789       	MOVE.b	FAC1_e(a3),d0		* get exponent
               S01:00E022E6:  10 2B 05 94
F00:6790       	BEQ.s		LAB_EX1			* return 1 for zero in
               S01:00E022EA:  67 B6
F00:6791       
F00:6792       	CMP.b		#$64,d0			* compare exponent with min
               S01:00E022EC:  B0 3C 00 64
F00:6793       	BCS.s		LAB_EX1			* if smaller just return 1
               S01:00E022F0:  65 B0
F00:6794       
F00:6795       **	MOVEM.l	d1-d6/a0,-(sp)		* save the registers
F00:6796       	MOVE.b	#0,cosout(a3)		* flag +ve number
               S01:00E022F2:  17 7C 00 00 05 B4
F00:6797       	MOVE.l	FAC1_m(a3),d1		* get mantissa
               S01:00E022F8:  22 2B 05 90
F00:6798       	CMP.b		#$87,d0			* compare exponent with max
               S01:00E022FC:  B0 3C 00 87
F00:6799       	BHI.s		LAB_EXOU			* go do over/under flow if greater
               S01:00E02300:  62 B0
F00:6800       
F00:6801       	BNE.s		LAB_EXCM			* branch if less
               S01:00E02302:  66 08
F00:6802       
F00:6803       							* else is 2^7
F00:6804       	CMP.l		#$B00F33C7,d1		* compare mantissa with n*2^7 max
               S01:00E02304:  B2 BC B0 0F 33 C7
F00:6805       	BCC.s		LAB_EXOU			* if => go over/underflow
               S01:00E0230A:  64 A6
F00:6806       
F00:6807       LAB_EXCM
F00:6808       	TST.b		FAC1_s(a3)			* test sign
               S01:00E0230C:  4A 2B 05 95
F00:6809       	BPL.s		LAB_EXPS			* branch if arg +ve
               S01:00E02310:  6A 0C
F00:6810       
F00:6811       	MOVE.b	#$FF,cosout(a3)		* flag -ve number
               S01:00E02312:  17 7C 00 FF 05 B4
F00:6812       	MOVE.b	#0,FAC1_s(a3)		* take absolute value
               S01:00E02318:  17 7C 00 00 05 95
F00:6813       LAB_EXPS
F00:6814       							* now do n/LOG(2)
F00:6815       	MOVE.l	#$B8AA3B29,FAC2_m(a3)	* 1/LOG(2) mantissa
               S01:00E0231E:  27 7C B8 AA 3B 29 05 98
F00:6816       	MOVE.w	#$8100,FAC2_e(a3)		* 1/LOG(2) exponent & sign
               S01:00E02326:  37 7C 81 00 05 9C
F00:6817       	MOVE.b	#0,FAC_sc(a3)		* we know they're both +ve
               S01:00E0232C:  17 7C 00 00 05 9E
F00:6818       	BSR		LAB_MULTIPLY		* effectively divide by log(2)
               S01:00E02332:  61 00 FA 16
F00:6819       
F00:6820       							* max here is +/- 127
F00:6821       							* now separate integer and fraction
F00:6822       	MOVE.b	#0,tpower(a3)		* clear exponent add byte
               S01:00E02336:  17 7C 00 00 05 D9
F00:6823       	MOVE.b	FAC1_e(a3),d5		* get exponent
               S01:00E0233C:  1A 2B 05 94
F00:6824       	SUB.b		#$80,d5			* normalise
               S01:00E02340:  9A 3C 00 80
F00:6825       	BLS.s		LAB_ESML			* branch if < 1 (d5 is 0 or -ve)
               S01:00E02344:  63 24
F00:6826       
F00:6827       							* result is > 1
F00:6828       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E02346:  20 2B 05 90
F00:6829       	MOVE.l	d0,d1				* copy it
               S01:00E0234A:  22 00
F00:6830       	MOVE.l	d5,d6				* copy normalised exponent
               S01:00E0234C:  2C 05
F00:6831       
F00:6832       	NEG.w		d6				* make -ve
               S01:00E0234E:  44 46
F00:6833       	ADD.w		#32,d6			* is now 32-d6
               S01:00E02350:  DC 7C 00 20
F00:6834       	LSR.l		d6,d1				* just integer bits
               S01:00E02354:  EC A9
F00:6835       	MOVE.b	d1,tpower(a3)		* set exponent add byte
               S01:00E02356:  17 41 05 D9
F00:6836       
F00:6837       	LSL.l		d5,d0				* shift out integer bits
               S01:00E0235A:  EB A8
F00:6838       	BEQ		LAB_EXOF			* fraction is zero so do 2^n
               S01:00E0235C:  67 00 FF 68
F00:6839       
F00:6840       	MOVE.l	d0,FAC1_m(a3)		* fraction to FAC1
               S01:00E02360:  27 40 05 90
F00:6841       	MOVE.w	#$8000,FAC1_e(a3)		* set exponent & sign
               S01:00E02364:  37 7C 80 00 05 94
F00:6842       
F00:6843       							* multiple was < 1
F00:6844       LAB_ESML
F00:6845       	MOVE.l	#$B17217F8,FAC2_m(a3)	* LOG(2) mantissa
               S01:00E0236A:  27 7C B1 72 17 F8 05 98
F00:6846       	MOVE.w	#$8000,FAC2_e(a3)		* LOG(2) exponent & sign
               S01:00E02372:  37 7C 80 00 05 9C
F00:6847       	MOVE.b	#0,FAC_sc(a3)		* clear sign compare
               S01:00E02378:  17 7C 00 00 05 9E
F00:6848       	BSR		LAB_MULTIPLY		* multiply by log(2)
               S01:00E0237E:  61 00 F9 CA
F00:6849       
F00:6850       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E02382:  20 2B 05 90
F00:6851       	MOVE.b	FAC1_e(a3),d5		* get exponent
               S01:00E02386:  1A 2B 05 94
F00:6852       	SUB.w		#$82,d5			* normalise and -2 (result is -1 to -30)
               S01:00E0238A:  9A 7C 00 82
F00:6853       	NEG.w		d5				* make +ve
               S01:00E0238E:  44 45
F00:6854       	LSR.l		d5,d0				* shift for 2 integer bits
               S01:00E02390:  EA A8
F00:6855       
F00:6856       * d0 = arg
F00:6857       * d6 = x, d1 = y
F00:6858       * d2 = x1, d3 = y1
F00:6859       * d4 = shift count
F00:6860       * d5 = loop count
F00:6861       							* now do cordic set-up
F00:6862       	MOVEQ		#0,d1				* y = 0
               S01:00E02392:  72 00
F00:6863       	MOVE.l	#KFCTSEED,d6		* x = 1 with jkh inverse factored out
               S01:00E02394:  2C 3C E6 A3 D1 10
F00:6864       	LEA		TAB_HTHET(pc),a0		* get pointer to hyperbolic arctan table
               S01:00E0239A:  41 FA 0D 20
F00:6865       	MOVEQ		#0,d4				* clear shift count
               S01:00E0239E:  78 00
F00:6866        
F00:6867       							* cordic loop, shifts 4 and 13 (and 39
F00:6868       							* if it went that far) need to be repeated
F00:6869       	MOVEQ		#3,d5				* 4 loops
               S01:00E023A0:  7A 03
F00:6870       	BSR.s		LAB_EXCC			* do loops 1 through 4
               S01:00E023A2:  61 36
F00:6871       	SUBQ.w	#4,a0				* do table entry again
               S01:00E023A4:  59 48
F00:6872       	SUBQ.l	#1,d4				* do shift count again
               S01:00E023A6:  53 84
F00:6873       	MOVEQ		#9,d5				* 10 loops
               S01:00E023A8:  7A 09
F00:6874       	BSR.s		LAB_EXCC			* do loops 4 (again) through 13
               S01:00E023AA:  61 2E
F00:6875       	SUBQ.w	#4,a0				* do table entry again
               S01:00E023AC:  59 48
F00:6876       	SUBQ.l	#1,d4				* do shift count again
               S01:00E023AE:  53 84
F00:6877       	MOVEQ		#18,d5			* 19 loops
               S01:00E023B0:  7A 12
F00:6878       	BSR.s		LAB_EXCC			* do loops 13 (again) through 31
               S01:00E023B2:  61 26
F00:6879        
F00:6880       							* now get the result
F00:6881       	TST.b		cosout(a3)			* test sign flag
               S01:00E023B4:  4A 2B 05 B4
F00:6882       	BPL.s		LAB_EXPL			* branch if +ve
               S01:00E023B8:  6A 06
F00:6883       
F00:6884       	NEG.l		d1				* do -y
               S01:00E023BA:  44 81
F00:6885       	NEG.b		tpower(a3)			* do -exp
               S01:00E023BC:  44 2B 05 D9
F00:6886       LAB_EXPL
F00:6887       	MOVEQ		#$83-$100,d0		* set exponent
               S01:00E023C0:  70 83
F00:6888       	ADD.l		d1,d6				* y = y +/- x
               S01:00E023C2:  DC 81
F00:6889       	BMI.s		LAB_EXRN			* branch if result normal
               S01:00E023C4:  6B 06
F00:6890       
F00:6891       LAB_EXNN
F00:6892       	SUBQ.l	#1,d0				* decrement exponent
               S01:00E023C6:  53 80
F00:6893       	ADD.l		d6,d6				* shift mantissa
               S01:00E023C8:  DC 86
F00:6894       	BPL.s		LAB_EXNN			* loop if not normal
               S01:00E023CA:  6A FA
F00:6895       
F00:6896       LAB_EXRN
F00:6897       	MOVE.l	d6,FAC1_m(a3)		* save exponent result
               S01:00E023CC:  27 46 05 90
F00:6898       	ADD.b		tpower(a3),d0		* add integer part
               S01:00E023D0:  D0 2B 05 D9
F00:6899       	MOVE.b	d0,FAC1_e(a3)		* save exponent
               S01:00E023D4:  17 40 05 94
F00:6900       **	MOVEM.l	(sp)+,d1-d6/a0		* restore registers
F00:6901       	RTS
               S01:00E023D8:  4E 75
F00:6902        
F00:6903       							* cordic loop
F00:6904       LAB_EXCC
F00:6905       	ADDQ.l	#1,d4				* increment shift count
               S01:00E023DA:  52 84
F00:6906       	MOVE.l	d6,d2				* x1 = x
               S01:00E023DC:  24 06
F00:6907       	ASR.l		d4,d2				* x1 >> n
               S01:00E023DE:  E8 A2
F00:6908       	MOVE.l	d1,d3				* y1 = y
               S01:00E023E0:  26 01
F00:6909       	ASR.l		d4,d3				* y1 >> n
               S01:00E023E2:  E8 A3
F00:6910       	TST.l		d0				* test arg
               S01:00E023E4:  4A 80
F00:6911       	BMI.s		LAB_EXAD			* branch if -ve
               S01:00E023E6:  6B 0C
F00:6912       
F00:6913       	ADD.l		d2,d1				* y = y + x1
               S01:00E023E8:  D2 82
F00:6914       	ADD.l		d3,d6				* x = x + y1
               S01:00E023EA:  DC 83
F00:6915       	SUB.l		(a0)+,d0			* arg = arg - atnh(a0)
               S01:00E023EC:  90 98
F00:6916       	DBF		d5,LAB_EXCC			* decrement and loop if not done
               S01:00E023EE:  51 CD FF EA
F00:6917       
F00:6918       	RTS
               S01:00E023F2:  4E 75
F00:6919       
F00:6920       LAB_EXAD
F00:6921       	SUB.l		d2,d1				* y = y - x1
               S01:00E023F4:  92 82
F00:6922       	SUB.l		d3,d6				* x = x + y1
               S01:00E023F6:  9C 83
F00:6923       	ADD.l		(a0)+,d0			* arg = arg + atnh(a0)
               S01:00E023F8:  D0 98
F00:6924       	DBF		d5,LAB_EXCC			* decrement and loop if not done
               S01:00E023FA:  51 CD FF DE
F00:6925       
F00:6926       	RTS
               S01:00E023FE:  4E 75
F00:6927       
F00:6928       
F00:6929       *************************************************************************************
F00:6930       *
F00:6931       * RND(n), 32 bit Galois version. make n=0 for 19th next number in sequence or n<>0
F00:6932       * to get 19th next number in sequence after seed n. This version of the PRNG uses
F00:6933       * the Galois method and a sample of 65536 bytes produced gives the following values.
F00:6934       
F00:6935       * Entropy = 7.997442 bits per byte
F00:6936       * Optimum compression would reduce these 65536 bytes by 0 percent
F00:6937       
F00:6938       * Chi square distribution for 65536 samples is 232.01, and
F00:6939       * randomly would exceed this value 75.00 percent of the time
F00:6940       
F00:6941       * Arithmetic mean value of data bytes is 127.6724, 127.5 would be random
F00:6942       * Monte Carlo value for Pi is 3.122871269, error 0.60 percent
F00:6943       * Serial correlation coefficient is -0.000370, totally uncorrelated would be 0.0
F00:6944       
F00:6945       LAB_RND
F00:6946       	TST.b		FAC1_e(a3)			* get FAC1 exponent
               S01:00E02400:  4A 2B 05 94
F00:6947       	BEQ.s		NextPRN			* do next random number if zero
               S01:00E02404:  67 08
F00:6948       
F00:6949       							* else get seed into random number store
F00:6950       	LEA		PRNlword(a3),a0		* set PRNG pointer
               S01:00E02406:  41 EB 05 A0
F00:6951       	BSR		LAB_2778			* pack FAC1 into (a0)
               S01:00E0240A:  61 00 FA B2
F00:6952       NextPRN
F00:6953       	MOVEQ		#$AF-$100,d1		* set EOR value
               S01:00E0240E:  72 AF
F00:6954       	MOVEQ		#18,d2			* do this 19 times
               S01:00E02410:  74 12
F00:6955       	MOVE.l	PRNlword(a3),d0		* get current
               S01:00E02412:  20 2B 05 A0
F00:6956       Ninc0
F00:6957       	ADD.l		d0,d0				* shift left 1 bit
               S01:00E02416:  D0 80
F00:6958       	BCC.s		Ninc1				* branch if bit 32 not set
               S01:00E02418:  64 02
F00:6959       
F00:6960       	EOR.b		d1,d0				* do Galois LFSR feedback
               S01:00E0241A:  B3 00
F00:6961       Ninc1
F00:6962       	DBF		d2,Ninc0			* loop
               S01:00E0241C:  51 CA FF F8
F00:6963       
F00:6964       	MOVE.l	d0,PRNlword(a3)		* save back to seed word
               S01:00E02420:  27 40 05 A0
F00:6965       	MOVE.l	d0,FAC1_m(a3)		* copy to FAC1 mantissa
               S01:00E02424:  27 40 05 90
F00:6966       	MOVE.w	#$8000,FAC1_e(a3)		* set the exponent and clear the sign
               S01:00E02428:  37 7C 80 00 05 94
F00:6967       	BRA		LAB_24D5			* normalise FAC1 & return
               S01:00E0242E:  60 00 F7 F2
F00:6968       
F00:6969       
F00:6970       *************************************************************************************
F00:6971       *
F00:6972       * cordic TAN(x) routine, TAN(x) = SIN(x)/COS(x)
F00:6973       * x = angle in radians
F00:6974       
F00:6975       LAB_TAN
F00:6976       	BSR.s		LAB_SIN			* go do SIN/COS cordic compute
               S01:00E02432:  61 38
F00:6977       	MOVE.w	FAC1_e(a3),FAC2_e(a3)	* copy exponent & sign from FAC1 to FAC2
               S01:00E02434:  37 6B 05 94 05 9C
F00:6978       	MOVE.l	FAC1_m(a3),FAC2_m(a3)	* copy FAC1 mantissa to FAC2 mantissa
               S01:00E0243A:  27 6B 05 90 05 98
F00:6979       	MOVE.l	d1,FAC1_m(a3)		* get COS(x) mantissa
               S01:00E02440:  27 41 05 90
F00:6980       	MOVE.b	d3,FAC1_e(a3)		* get COS(x) exponent
               S01:00E02444:  17 43 05 94
F00:6981       	BEQ		LAB_OFER			* do overflow if COS = 0
               S01:00E02448:  67 00 DE 20
F00:6982       
F00:6983       	BSR		LAB_24D5			* normalise FAC1
               S01:00E0244C:  61 00 F7 D4
F00:6984       	BRA		LAB_DIVIDE			* do FAC2/FAC1 and return, FAC_sc set by SIN
               S01:00E02450:  60 00 F9 84
F00:6985       							* COS calculation
F00:6986       
F00:6987       
F00:6988       *************************************************************************************
F00:6989       *
F00:6990       * cordic SIN(x), COS(x) routine
F00:6991       * x = angle in radians
F00:6992       
F00:6993       LAB_COS
F00:6994       	MOVE.l	#$C90FDAA3,FAC2_m(a3)	* pi/2 mantissa (LSB is rounded up so
               S01:00E02454:  27 7C C9 0F DA A3 05 98
F00:6995       							* COS(PI/2)=0)
F00:6996       	MOVE.w	#$8100,FAC2_e(a3)		* pi/2 exponent and sign
               S01:00E0245C:  37 7C 81 00 05 9C
F00:6997       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
               S01:00E02462:  17 6B 05 95 05 9E
F00:6998       	BSR		LAB_ADD			* add FAC2 to FAC1, adjust for COS(x)
               S01:00E02468:  61 00 F7 3E
F00:6999       
F00:7000       
F00:7001       *************************************************************************************
F00:7002       *
F00:7003       * SIN/COS cordic calculator
F00:7004       
F00:7005       LAB_SIN
F00:7006       	MOVE.b	#0,cosout(a3)		* set needed result
               S01:00E0246C:  17 7C 00 00 05 B4
F00:7007       
F00:7008       	MOVE.l	#$A2F9836F,FAC2_m(a3)	* 1/pi mantissa (LSB is rounded up so SIN(PI)=0)
               S01:00E02472:  27 7C A2 F9 83 6F 05 98
F00:7009       	MOVE.w	#$7F00,FAC2_e(a3)		* 1/pi exponent & sign
               S01:00E0247A:  37 7C 7F 00 05 9C
F00:7010       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign = FAC1 sign (b7)
               S01:00E02480:  17 6B 05 95 05 9E
F00:7011       	BSR		LAB_MULTIPLY		* multiply by 1/pi
               S01:00E02486:  61 00 F8 C2
F00:7012       
F00:7013       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E0248A:  10 2B 05 94
F00:7014       	BEQ.s		LAB_SCZE			* branch if zero
               S01:00E0248E:  67 1C
F00:7015       
F00:7016       	LEA		TAB_SNCO(pc),a0		* get pointer to constants table
               S01:00E02490:  41 FA 0B 2A
F00:7017       	MOVE.l	FAC1_m(a3),d6		* get FAC1 mantissa
               S01:00E02494:  2C 2B 05 90
F00:7018       	SUBQ.b	#1,d0				* 2 radians in 360 degrees so /2
               S01:00E02498:  53 00
F00:7019       	BEQ.s		LAB_SCZE			* branch if zero
               S01:00E0249A:  67 10
F00:7020       
F00:7021       	SUB.b		#$80,d0			* normalise exponent
               S01:00E0249C:  90 3C 00 80
F00:7022       	BMI.s		LAB_SCL0			* branch if < 1
               S01:00E024A0:  6B 18
F00:7023       
F00:7024       							* X is > 1
F00:7025       	CMP.b		#$20,d0			* is it >= 2^32
               S01:00E024A2:  B0 3C 00 20
F00:7026       	BCC.s		LAB_SCZE			* may as well do zero
               S01:00E024A6:  64 04
F00:7027       
F00:7028       	LSL.l		d0,d6				* shift out integer part bits
               S01:00E024A8:  E1 AE
F00:7029       	BNE.s		LAB_CORD			* if fraction go test quadrant and adjust
               S01:00E024AA:  66 18
F00:7030       
F00:7031       							* else no fraction so do zero
F00:7032       LAB_SCZE
F00:7033       	MOVEQ		#$81-$100,d2		* set exponent for 1.0
               S01:00E024AC:  74 81
F00:7034       	MOVEQ		#0,d3				* set exponent for 0.0
               S01:00E024AE:  76 00
F00:7035       	MOVE.l	#$80000000,d0		* mantissa for 1.0
               S01:00E024B0:  20 3C 80 00 00 00
F00:7036       	MOVE.l	d3,d1				* mantissa for 0.0
               S01:00E024B6:  22 03
F00:7037       	BRA.s		outloop			* go output it
               S01:00E024B8:  60 5C
F00:7038       
F00:7039       							* x is < 1
F00:7040       LAB_SCL0
F00:7041       	NEG.b		d0				* make +ve
               S01:00E024BA:  44 00
F00:7042       	CMP.b		#$1E,d0			* is it <= 2^-30
               S01:00E024BC:  B0 3C 00 1E
F00:7043       	BCC.s		LAB_SCZE			* may as well do zero
               S01:00E024C0:  64 EA
F00:7044       
F00:7045       	LSR.l		d0,d6				* shift out <= 2^-32 bits
               S01:00E024C2:  E0 AE
F00:7046       
F00:7047       * cordic calculator, argument in d6
F00:7048       * table pointer in a0, returns in d0-d3
F00:7049       
F00:7050       LAB_CORD
F00:7051       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* copy as sign compare for TAN
               S01:00E024C4:  17 6B 05 95 05 9E
F00:7052       	ADD.l		d6,d6				* shift 0.5 bit into carry
               S01:00E024CA:  DC 86
F00:7053       	BCC.s		LAB_LTPF			* branch if less than 0.5
               S01:00E024CC:  64 04
F00:7054       
F00:7055       	EORI.b	#$FF,FAC1_s(a3)		* toggle result sign
               S01:00E024CE:  46 2B 05 95
F00:7056       LAB_LTPF
F00:7057       	ADD.l		d6,d6				* shift 0.25 bit into carry
               S01:00E024D2:  DC 86
F00:7058       	BCC.s		LAB_LTPT			* branch if less than 0.25
               S01:00E024D4:  64 08
F00:7059       
F00:7060       	EORI.b	#$FF,cosout(a3)		* toggle needed result
               S01:00E024D6:  46 2B 05 B4
F00:7061       	EORI.b	#$FF,FAC_sc(a3)		* toggle sign compare for TAN
               S01:00E024DA:  46 2B 05 9E
F00:7062       
F00:7063       LAB_LTPT
F00:7064       	LSR.l		#2,d6				* shift the bits back (clear integer bits)
               S01:00E024DE:  E4 8E
F00:7065       	BEQ.s		LAB_SCZE			* no fraction so go do zero
               S01:00E024E0:  67 CA
F00:7066       
F00:7067       							* set start values
F00:7068       	MOVEQ		#1,d5				* set bit count
               S01:00E024E2:  7A 01
F00:7069       	MOVE.l	-4(a0),d0			* get multiply constant (1st itteration d0)
               S01:00E024E4:  20 28 FF FC
F00:7070       	MOVE.l	d0,d1				* 1st itteration d1
               S01:00E024E8:  22 00
F00:7071       	SUB.l		(a0)+,d6			* 1st always +ve so do 1st step
               S01:00E024EA:  9C 98
F00:7072       	BRA.s		mainloop			* jump into routine
               S01:00E024EC:  60 08
F00:7073       
F00:7074       subloop
F00:7075       	SUB.l		(a0)+,d6			* z = z - arctan(i)/2pi
               S01:00E024EE:  9C 98
F00:7076       	SUB.l		d3,d0				* x = x - y1
               S01:00E024F0:  90 83
F00:7077       	ADD.l		d2,d1				* y = y + x1
               S01:00E024F2:  D2 82
F00:7078       	BRA.s		nexta				* back to main loop
               S01:00E024F4:  60 12
F00:7079       
F00:7080       mainloop
F00:7081       	MOVE.l	d0,d2				* x1 = x
               S01:00E024F6:  24 00
F00:7082       	ASR.l		d5,d2				* / (2 ^ i)
               S01:00E024F8:  EA A2
F00:7083       	MOVE.l	d1,d3				* y1 = y
               S01:00E024FA:  26 01
F00:7084       	ASR.l		d5,d3				* / (2 ^ i)
               S01:00E024FC:  EA A3
F00:7085       	TST.l		d6				* test sign (is 2^0 bit)
               S01:00E024FE:  4A 86
F00:7086       	BPL.s		subloop			* go do subtract if > 1
               S01:00E02500:  6A EC
F00:7087       
F00:7088       	ADD.l		(a0)+,d6			* z = z + arctan(i)/2pi
               S01:00E02502:  DC 98
F00:7089       	ADD.l		d3,d0				* x = x + y1
               S01:00E02504:  D0 83
F00:7090       	SUB.l		d2,d1				* y = y + x1
               S01:00E02506:  92 82
F00:7091       nexta
F00:7092       	ADDQ.l	#1,d5				* i = i + 1
               S01:00E02508:  52 85
F00:7093       	CMP.l		#$1E,d5			* check end condition
               S01:00E0250A:  BA BC 00 00 00 1E
F00:7094       	BNE.s		mainloop			* loop if not all done
               S01:00E02510:  66 E4
F00:7095       
F00:7096       							* now untangle output value
F00:7097       	MOVEQ		#$81-$100,d2		* set exponent for 0 to .99 rec.
               S01:00E02512:  74 81
F00:7098       	MOVE.l	d2,d3				* copy it for cos output
               S01:00E02514:  26 02
F00:7099       outloop
F00:7100       	TST.b		cosout(a3)			* did we want cos output?
               S01:00E02516:  4A 2B 05 B4
F00:7101       	BMI.s		subexit			* if so skip
               S01:00E0251A:  6B 04
F00:7102       
F00:7103       	EXG		d0,d1				* swap SIN and COS mantissas
               S01:00E0251C:  C1 41
F00:7104       	EXG		d2,d3				* swap SIN and COS exponents
               S01:00E0251E:  C5 43
F00:7105       subexit
F00:7106       	MOVE.l	d0,FAC1_m(a3)		* set result mantissa
               S01:00E02520:  27 40 05 90
F00:7107       	MOVE.b	d2,FAC1_e(a3)		* set result exponent
               S01:00E02524:  17 42 05 94
F00:7108       	BRA		LAB_24D5			* normalise FAC1 & return
               S01:00E02528:  60 00 F6 F8
F00:7109       
F00:7110       
F00:7111       
F00:7112       *************************************************************************************
F00:7113       *
F00:7114       * perform ATN()
F00:7115       
F00:7116       LAB_ATN
F00:7117       	MOVE.b	FAC1_e(a3),d0		* get FAC1 exponent
               S01:00E0252C:  10 2B 05 94
F00:7118       	BEQ		RTS_021			* ATN(0) = 0 so skip calculation
               S01:00E02530:  67 00 00 AA
F00:7119       
F00:7120       	MOVE.b	#0,cosout(a3)		* set result needed
               S01:00E02534:  17 7C 00 00 05 B4
F00:7121       	CMP.b		#$81,d0			* compare exponent with 1
               S01:00E0253A:  B0 3C 00 81
F00:7122       	BCS.s		LAB_ATLE			* branch if n<1
               S01:00E0253E:  65 28
F00:7123       
F00:7124       	BNE.s		LAB_ATGO			* branch if n>1
               S01:00E02540:  66 08
F00:7125       
F00:7126       	MOVE.l	FAC1_m(a3),d0		* get mantissa
               S01:00E02542:  20 2B 05 90
F00:7127       	ADD.l		d0,d0				* shift left
               S01:00E02546:  D0 80
F00:7128       	BEQ.s		LAB_ATLE			* branch if n=1
               S01:00E02548:  67 1E
F00:7129       
F00:7130       LAB_ATGO
F00:7131       	MOVE.l	#$80000000,FAC2_m(a3)	* set mantissa for 1
               S01:00E0254A:  27 7C 80 00 00 00 05 98
F00:7132       	MOVE.w	#$8100,FAC2_e(a3)		* set exponent for 1
               S01:00E02552:  37 7C 81 00 05 9C
F00:7133       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* sign compare = sign
               S01:00E02558:  17 6B 05 95 05 9E
F00:7134       	BSR		LAB_DIVIDE			* do 1/n
               S01:00E0255E:  61 00 F8 76
F00:7135       	MOVE.b	#$FF,cosout(a3)		* set inverse result needed
               S01:00E02562:  17 7C 00 FF 05 B4
F00:7136       LAB_ATLE
F00:7137       	MOVE.l	FAC1_m(a3),d0		* get FAC1 mantissa
               S01:00E02568:  20 2B 05 90
F00:7138       	MOVEQ		#$82,d1			* set to correct exponent
               S01:00E0256C:  72 82
F00:7139       	SUB.b		FAC1_e(a3),d1		* subtract FAC1 exponent (always <= 1)
               S01:00E0256E:  92 2B 05 94
F00:7140       	LSR.l		d1,d0				* shift in two integer part bits
               S01:00E02572:  E2 A8
F00:7141       	LEA		TAB_ATNC(pc),a0		* get pointer to arctan table
               S01:00E02574:  41 FA 0A C6
F00:7142       	MOVEQ		#0,d6				* Z = 0
               S01:00E02578:  7C 00
F00:7143       	MOVE.l	#1<<30,d1			* y = 1
               S01:00E0257A:  22 3C 40 00 00 00
F00:7144       	MOVEQ		#29,d5			* loop 30 times
               S01:00E02580:  7A 1D
F00:7145       	MOVEQ		#1,d4				* shift counter
               S01:00E02582:  78 01
F00:7146       	BRA.s		LAB_ATCD			* enter loop
               S01:00E02584:  60 06
F00:7147       
F00:7148       LAB_ATNP
F00:7149       	ASR.l		d4,d2				* x1 / 2^i
               S01:00E02586:  E8 A2
F00:7150       	ADD.l		d2,d1				* y = y + x1
               S01:00E02588:  D2 82
F00:7151       	ADD.l		(a0),d6			* z = z + atn(i)
               S01:00E0258A:  DC 90
F00:7152       LAB_ATCD
F00:7153       	MOVE.l	d0,d2				* x1 = x
               S01:00E0258C:  24 00
F00:7154       	MOVE.l	d1,d3				* y1 = y
               S01:00E0258E:  26 01
F00:7155       	ASR.l		d4,d3				* y1 / 2^i
               S01:00E02590:  E8 A3
F00:7156       LAB_CATN
F00:7157       	SUB.l		d3,d0				* x = x - y1
               S01:00E02592:  90 83
F00:7158       	BPL.s		LAB_ATNP			* branch if x >= 0
               S01:00E02594:  6A F0
F00:7159       
F00:7160       	MOVE.l	d2,d0				* else get x back
               S01:00E02596:  20 02
F00:7161       	ADDQ.w	#4,a0				* increment pointer
               S01:00E02598:  58 48
F00:7162       	ADDQ.l	#1,d4				* increment i
               S01:00E0259A:  52 84
F00:7163       	ASR.l		#1,d3				* y1 / 2^i
               S01:00E0259C:  E2 83
F00:7164       	DBF		d5,LAB_CATN			* decrement and loop if not done
               S01:00E0259E:  51 CD FF F2
F00:7165       
F00:7166       	MOVE.b	#$82,FAC1_e(a3)		* set new exponent
               S01:00E025A2:  17 7C 00 82 05 94
F00:7167       	MOVE.l	d6,FAC1_m(a3)		* save mantissa
               S01:00E025A8:  27 46 05 90
F00:7168       	BSR		LAB_24D5			* normalise FAC1
               S01:00E025AC:  61 00 F6 74
F00:7169       
F00:7170       	TST.b		cosout(a3)			* was it > 1 ?
               S01:00E025B0:  4A 2B 05 B4
F00:7171       	BPL.s		RTS_021			* branch if not
               S01:00E025B4:  6A 26
F00:7172       
F00:7173       	MOVE.b	FAC1_s(a3),d7		* get sign
               S01:00E025B6:  1E 2B 05 95
F00:7174       	MOVE.b	#0,FAC1_s(a3)		* clear sign
               S01:00E025BA:  17 7C 00 00 05 95
F00:7175       	MOVE.l	#$C90FDAA2,FAC2_m(a3)	* set -(pi/2)
               S01:00E025C0:  27 7C C9 0F DA A2 05 98
F00:7176       	MOVE.w	#$8180,FAC2_e(a3)		* set exponent and sign
               S01:00E025C8:  37 7C 81 80 05 9C
F00:7177       	MOVE.b	#$FF,FAC_sc(a3)		* set sign compare
               S01:00E025CE:  17 7C 00 FF 05 9E
F00:7178       	BSR		LAB_ADD			* perform addition, FAC2 to FAC1
               S01:00E025D4:  61 00 F5 D2
F00:7179       	MOVE.b	d7,FAC1_s(a3)		* restore sign
               S01:00E025D8:  17 47 05 95
F00:7180       RTS_021
F00:7181       	RTS
               S01:00E025DC:  4E 75
F00:7182       
F00:7183       
F00:7184       *************************************************************************************
F00:7185       *
F00:7186       * perform BITSET
F00:7187       
F00:7188       LAB_BITSET
F00:7189       	BSR		LAB_GADB			* get two parameters for POKE or WAIT
               S01:00E025DE:  61 00 F2 94
F00:7190       							* first parameter in a0, second in d0
F00:7191       	CMP.b		#$08,d0			* only 0 to 7 are allowed
               S01:00E025E2:  B0 3C 00 08
F00:7192       	BCC		LAB_FCER			* branch if > 7
               S01:00E025E6:  64 00 DC 86
F00:7193       
F00:7194       	BSET		d0,(a0)			* set bit
               S01:00E025EA:  01 D0
F00:7195       	RTS
               S01:00E025EC:  4E 75
F00:7196       
F00:7197       
F00:7198       *************************************************************************************
F00:7199       *
F00:7200       * perform BITCLR
F00:7201       
F00:7202       LAB_BITCLR
F00:7203       	BSR		LAB_GADB			* get two parameters for POKE or WAIT
               S01:00E025EE:  61 00 F2 84
F00:7204       							* first parameter in a0, second in d0
F00:7205       	CMP.b		#$08,d0			* only 0 to 7 are allowed
               S01:00E025F2:  B0 3C 00 08
F00:7206       	BCC		LAB_FCER			* branch if > 7
               S01:00E025F6:  64 00 DC 76
F00:7207       
F00:7208       	BCLR		d0,(a0)			* clear bit
               S01:00E025FA:  01 90
F00:7209       	RTS
               S01:00E025FC:  4E 75
F00:7210       
F00:7211       
F00:7212       *************************************************************************************
F00:7213       *
F00:7214       * perform BITTST()
F00:7215       
F00:7216       LAB_BTST
F00:7217       	MOVE.b	(a5)+,d0			* increment BASIC pointer
               S01:00E025FE:  10 1D
F00:7218       	BSR		LAB_GADB			* get two parameters for POKE or WAIT
               S01:00E02600:  61 00 F2 72
F00:7219       							* first parameter in a0, second in d0
F00:7220       	CMP.b		#$08,d0			* only 0 to 7 are allowed
               S01:00E02604:  B0 3C 00 08
F00:7221       	BCC		LAB_FCER			* branch if > 7
               S01:00E02608:  64 00 DC 64
F00:7222       
F00:7223       	MOVE.l	d0,d1				* copy bit # to test
               S01:00E0260C:  22 00
F00:7224       	BSR		LAB_GBYT			* get next BASIC byte
               S01:00E0260E:  61 00 E8 A8
F00:7225       	CMP.b		#')',d0			* is next character ")"
               S01:00E02612:  B0 3C 00 29
F00:7226       	BNE		LAB_SNER			* if not ")" go do syntax error, then warm start
               S01:00E02616:  66 00 DC 62
F00:7227       
F00:7228       	BSR		LAB_IGBY			* update execute pointer (to character past ")")
               S01:00E0261A:  61 00 E8 9A
F00:7229       	MOVEQ		#0,d0				* set the result as zero
               S01:00E0261E:  70 00
F00:7230       	BTST		d1,(a0)			* test bit
               S01:00E02620:  03 10
F00:7231       	BEQ		LAB_27DB			* branch if zero (already correct)
               S01:00E02622:  67 00 F9 14
F00:7232       
F00:7233       	MOVEQ		#-1,d0			* set for -1 result
               S01:00E02626:  70 FF
F00:7234       	BRA		LAB_27DB			* go do SGN tail
               S01:00E02628:  60 00 F9 0E
F00:7235       
F00:7236       
F00:7237       *************************************************************************************
F00:7238       *
F00:7239       * perform USING$()
F00:7240       
F00:7241       fsd	EQU	 0					*   (sp) format string descriptor pointer
F00:7242       fsti	EQU	 4					*  4(sp) format string this index
F00:7243       fsli	EQU	 6					*  6(sp) format string last index
F00:7244       fsdpi	EQU	 8					*  8(sp) format string decimal point index
F00:7245       fsdc	EQU	10					* 10(sp) format string decimal characters
F00:7246       fend	EQU	12-4					*  x(sp) end-4, fsd is popped by itself
F00:7247       
F00:7248       ofchr	EQU	'#'					* the overflow character
F00:7249       
F00:7250       LAB_USINGS
F00:7251       	TST.b		Dtypef(a3)			* test data type, $80=string
               S01:00E0262C:  4A 2B 05 B5
F00:7252       	BPL		LAB_FOER			* if not string type go do format error
               S01:00E02630:  6A 00 DB F4
F00:7253       
F00:7254       	MOVEA.l	FAC1_m(a3),a2		* get the format string descriptor pointer
               S01:00E02634:  24 6B 05 90
F00:7255       	MOVE.w	4(a2),d7			* get the format string length
               S01:00E02638:  3E 2A 00 04
F00:7256       	BEQ		LAB_FOER			* if null string go do format error
               S01:00E0263C:  67 00 DB E8
F00:7257       
F00:7258       * clear the format string values
F00:7259       
F00:7260       	MOVEQ		#0,d0				* clear d0
               S01:00E02640:  70 00
F00:7261       	MOVE.w	d0,-(sp)			* clear the format string decimal characters
               S01:00E02642:  3F 00
F00:7262       	MOVE.w	d0,-(sp)			* clear the format string decimal point index
               S01:00E02644:  3F 00
F00:7263       	MOVE.w	d0,-(sp)			* clear the format string last index
               S01:00E02646:  3F 00
F00:7264       	MOVE.w	d0,-(sp)			* clear the format string this index
               S01:00E02648:  3F 00
F00:7265       	MOVE.l	a2,-(sp)			* save the format string descriptor pointer
               S01:00E0264A:  2F 0A
F00:7266       
F00:7267       * make a null return string for the first string add
F00:7268       
F00:7269       	MOVEQ		#0,d1				* make a null string
               S01:00E0264C:  72 00
F00:7270       	MOVEA.l	d1,a0				* with a null pointer
               S01:00E0264E:  20 41
F00:7271       	BSR		LAB_RTST			* push a string on the descriptor stack
               S01:00E02650:  61 00 EE C6
F00:7272       							* a0 = pointer, d1 = length
F00:7273       
F00:7274       * do the USING$() function next value
F00:7275       
F00:7276       	MOVE.b	(a5)+,d0			* get the next BASIC byte
               S01:00E02654:  10 1D
F00:7277       LAB_U002
F00:7278       	CMP.b		#',',d0			* compare with comma
               S01:00E02656:  B0 3C 00 2C
F00:7279       	BNE		LAB_SNER			* if not "," go do syntax error
               S01:00E0265A:  66 00 DC 1E
F00:7280       
F00:7281       	BSR		LAB_ProcFo			* process the format string
               S01:00E0265E:  61 00 02 8C
F00:7282       	TST.b		d2				* test the special characters flag
               S01:00E02662:  4A 02
F00:7283       	BEQ		LAB_FOER			* if no special characters go do format error
               S01:00E02664:  67 00 DB C0
F00:7284       
F00:7285       	BSR		LAB_EVEX			* evaluate the expression
               S01:00E02668:  61 00 E6 EC
F00:7286       	TST.b		Dtypef(a3)			* test the data type
               S01:00E0266C:  4A 2B 05 B5
F00:7287       	BMI		LAB_TMER			* if string type go do type missmatch error
               S01:00E02670:  6B 00 DB DC
F00:7288       
F00:7289       	TST.b		FAC1_e(a3)			* test FAC1 exponent
               S01:00E02674:  4A 2B 05 94
F00:7290       	BEQ.s		LAB_U004			* if FAC1 = 0 skip the rounding
               S01:00E02678:  67 32
F00:7291       
F00:7292       	MOVE.w	fsdc(sp),d1			* get the format string decimal character count
               S01:00E0267A:  32 2F 00 0A
F00:7293       	CMP.w		#8,d1				* compare the fraction digit count with 8
               S01:00E0267E:  B2 7C 00 08
F00:7294       	BCC.s		LAB_U004			* if >= 8 skip the rounding
               S01:00E02682:  64 28
F00:7295       
F00:7296       	MOVE.w	d1,d0				* else copy the fraction digit count
               S01:00E02684:  30 01
F00:7297       	ADD.w		d1,d1				* * 2
               S01:00E02686:  D2 41
F00:7298       	ADD.w		d0,d1				* * 3
               S01:00E02688:  D2 40
F00:7299       	ADD.w		d1,d1				* * 6
               S01:00E0268A:  D2 41
F00:7300       	LEA		LAB_P_10(pc),a0		* get the rounding table base
               S01:00E0268C:  41 FA 08 40
F00:7301       	MOVE.l	2(a0,d1.w),FAC2_m(a3)	* get the rounding mantissa
               S01:00E02690:  27 70 10 02 05 98
F00:7302       	MOVE.w	(a0,d1.w),d0		* get the rounding exponent
               S01:00E02696:  30 30 10 00
F00:7303       	SUB.w		#$100,d0			* effectively divide the mantissa by 2
               S01:00E0269A:  90 7C 01 00
F00:7304       	MOVE.w	d0,FAC2_e(a3)		* save the rounding exponent
               S01:00E0269E:  37 40 05 9C
F00:7305       	MOVE.b	#$00,FAC_sc(a3)		* clear the sign compare
               S01:00E026A2:  17 7C 00 00 05 9E
F00:7306       	BSR		LAB_ADD			* round the value to n places
               S01:00E026A8:  61 00 F4 FE
F00:7307       LAB_U004
F00:7308       	BSR		LAB_2970			* convert FAC1 to string - not on stack
               S01:00E026AC:  61 00 F9 76
F00:7309       
F00:7310       	BSR		LAB_DupFmt			* duplicate the processed format string section
               S01:00E026B0:  61 00 01 FC
F00:7311       							* returns length in d1, pointer in a0
F00:7312       
F00:7313       * process the number string, length in d6, decimal point index in d2
F00:7314       
F00:7315       	LEA		Decss(a3),a2		* set the number string start
               S01:00E026B4:  45 EB 05 C6
F00:7316       	MOVEQ		#0,d6				* clear the number string index
               S01:00E026B8:  7C 00
F00:7317       	MOVEQ		#'.',d4			* set the decimal point character
               S01:00E026BA:  78 2E
F00:7318       LAB_U005
F00:7319       	MOVE.w	d6,d2				* save the index to flag the decimal point
               S01:00E026BC:  34 06
F00:7320       LAB_U006
F00:7321       	ADDQ.w	#1,d6				* increment the number string index
               S01:00E026BE:  52 46
F00:7322       	MOVE.b	(a2,d6.w),d0		* get a number string character
               S01:00E026C0:  10 32 60 00
F00:7323       	BEQ.s		LAB_U010			* if null then number complete
               S01:00E026C4:  67 7A
F00:7324       
F00:7325       	CMP.b		#'E',d0			* compare the character with an "E"
               S01:00E026C6:  B0 3C 00 45
F00:7326       	BEQ.s		LAB_U008			* was sx[.x]Esxx so go handle sci notation
               S01:00E026CA:  67 06
F00:7327       
F00:7328       	CMP.b		d4,d0				* compare the character with "."
               S01:00E026CC:  B0 04
F00:7329       	BNE.s		LAB_U006			* if not decimal point go get the next digit
               S01:00E026CE:  66 EE
F00:7330       
F00:7331       	BRA.s		LAB_U005			* go save the index and get the next digit
               S01:00E026D0:  60 EA
F00:7332       
F00:7333       * have found an sx[.x]Esxx number, the [.x] will not be present for a single digit
F00:7334       
F00:7335       LAB_U008
F00:7336       	MOVE.w	d6,d3				* copy the index to the "E"
               S01:00E026D2:  36 06
F00:7337       	SUBQ.w	#1,d3				* -1 gives the last digit index
               S01:00E026D4:  53 43
F00:7338       
F00:7339       	ADDQ.w	#1,d6				* increment the index to the exponent sign
               S01:00E026D6:  52 46
F00:7340       	MOVE.b	(a2,d6.w),d0		* get the exponent sign character
               S01:00E026D8:  10 32 60 00
F00:7341       	CMP.b		#'-',d0			* compare the exponent sign with "-"
               S01:00E026DC:  B0 3C 00 2D
F00:7342       	BNE		LAB_FCER			* if it wasn't sx[.x]E-xx go do function
               S01:00E026E0:  66 00 DB 8C
F00:7343       							* call error
F00:7344       
F00:7345       * found an sx[.x]E-xx number so check the exponent magnitude
F00:7346       
F00:7347       	ADDQ.w	#1,d6				* increment the index to the exponent 10s
               S01:00E026E4:  52 46
F00:7348       	MOVE.b	(a2,d6.w),d0		* get the exponent 10s character
               S01:00E026E6:  10 32 60 00
F00:7349       	CMP.b		#'0',d0			* compare the exponent 10s with "0"
               S01:00E026EA:  B0 3C 00 30
F00:7350       	BEQ.s		LAB_U009			* if it was sx[.x]E-0x go get the exponent
               S01:00E026EE:  67 04
F00:7351       							* 1s character
F00:7352       
F00:7353       	MOVEQ		#10,d0			* else start writing at index 10
               S01:00E026F0:  70 0A
F00:7354       	BRA.s		LAB_U00A			* go copy the digits
               S01:00E026F2:  60 08
F00:7355       
F00:7356       * found an sx[.x]E-0x number so get the exponent magnitude
F00:7357       
F00:7358       LAB_U009
F00:7359       	ADDQ.w	#1,d6				* increment the index to the exponent 1s
               S01:00E026F4:  52 46
F00:7360       	MOVEQ		#$0F,d0			* set the mask for the exponent 1s digit
               S01:00E026F6:  70 0F
F00:7361       	AND.b		(a2,d6.w),d0		* get and convert the exponent 1s digit
               S01:00E026F8:  C0 32 60 00
F00:7362       LAB_U00A
F00:7363       	MOVE.w	d3,d2				* copy the number last digit index
               S01:00E026FC:  34 03
F00:7364       	CMPI.w	#1,d2				* is the number of the form sxE-0x
               S01:00E026FE:  0C 42 00 01
F00:7365       	BNE.s		LAB_U00B			* if it is sx.xE-0x skip the increment
               S01:00E02702:  66 02
F00:7366       
F00:7367       							* else make room for the decimal point
F00:7368       	ADDQ.w	#1,d2				* add 1 to the write index
               S01:00E02704:  52 42
F00:7369       LAB_U00B
F00:7370       	ADD.w		d0,d2				* add the exponent 1s to the write index
               S01:00E02706:  D4 40
F00:7371       	MOVEQ		#10,d0			* set the maximum write index
               S01:00E02708:  70 0A
F00:7372       	SUB.w		d2,d0				* compare the index with the maximum
               S01:00E0270A:  90 42
F00:7373       	BGT.s		LAB_U00C			* if the index < the maximum continue
               S01:00E0270C:  6E 0C
F00:7374       
F00:7375       	ADD.w		d0,d2				* else set the index to the maximum
               S01:00E0270E:  D4 40
F00:7376       	ADD.w		d0,d3				* adjust the read index
               S01:00E02710:  D6 40
F00:7377       	CMPI.w	#1,d3				* compare the adjusted index with 1
               S01:00E02712:  0C 43 00 01
F00:7378       	BGT.s		LAB_U00C			* if > 1 continue
               S01:00E02716:  6E 02
F00:7379       
F00:7380       	MOVEQ		#0,d3				* else allow for the decimal point
               S01:00E02718:  76 00
F00:7381       LAB_U00C
F00:7382       	MOVE.w		d2,d6				* copy the write index as the number
               S01:00E0271A:  3C 02
F00:7383       							* string length
F00:7384       	MOVEQ		#0,d0				* clear d0 to null terminate the number
               S01:00E0271C:  70 00
F00:7385       							* string
F00:7386       LAB_U00D
F00:7387       	MOVE.b	d0,(a2,d2.w)		* save the character to the number string
               S01:00E0271E:  15 80 20 00
F00:7388       	SUBQ.w	#1,d2				* decrement the number write index
               S01:00E02722:  53 42
F00:7389       	CMPI.w	#1,d2				* compare the number write index with 1
               S01:00E02724:  0C 42 00 01
F00:7390       	BEQ.s		LAB_U00F			* if at the decimal point go save it
               S01:00E02728:  67 12
F00:7391       
F00:7392       							* else write a digit to the number string
F00:7393       	MOVEQ		#'0',d0			* default to "0"
               S01:00E0272A:  70 30
F00:7394       	TST.w		d3				* test the number read index
               S01:00E0272C:  4A 43
F00:7395       	BEQ.s		LAB_U00D			* if zero just go save the "0"
               S01:00E0272E:  67 EE
F00:7396       
F00:7397       LAB_U00E
F00:7398       	MOVE.b	(a2,d3.w),d0		* read the next number digit
               S01:00E02730:  10 32 30 00
F00:7399       	SUBQ.w	#1,d3				* decrement the read index
               S01:00E02734:  53 43
F00:7400       	CMP.b		d4,d0				* compare the digit with "."
               S01:00E02736:  B0 04
F00:7401       	BNE.s		LAB_U00D			* if not "." go save the digit
               S01:00E02738:  66 E4
F00:7402       
F00:7403       	BRA.s		LAB_U00E			* else go get the next digit
               S01:00E0273A:  60 F4
F00:7404       
F00:7405       LAB_U00F
F00:7406       	MOVE.b	d4,(a2,d2.w)		* save the decimal point
               S01:00E0273C:  15 84 20 00
F00:7407       LAB_U010
F00:7408       	TST.w		d2				* test the number string decimal point index
               S01:00E02740:  4A 42
F00:7409       	BNE.s		LAB_U014			* if dp present skip the reset
               S01:00E02742:  66 02
F00:7410       
F00:7411       	MOVE.w	d6,d2				* make the decimal point index = the length
               S01:00E02744:  34 06
F00:7412       
F00:7413       * copy the fractional digit characters from the number string
F00:7414       
F00:7415       LAB_U014
F00:7416       	MOVE.w	d2,d3				* copy the number string decimal point index
               S01:00E02746:  36 02
F00:7417       	ADDQ.w	#1,d3				* increment the number string index
               S01:00E02748:  52 43
F00:7418       	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
               S01:00E0274A:  38 2F 00 08
F00:7419       LAB_U018
F00:7420       	ADDQ.w	#1,d4				* increment the new format string index
               S01:00E0274E:  52 44
F00:7421       	CMP.w		d4,d1				* compare it with the new format string length
               S01:00E02750:  B2 44
F00:7422       	BLS.s		LAB_U022			* if done the fraction digits go do integer
               S01:00E02752:  63 22
F00:7423       
F00:7424       	MOVE.b	(a0,d4.w),d0		* get a new format string character
               S01:00E02754:  10 30 40 00
F00:7425       	CMP.b		#'%',d0			* compare it with "%"
               S01:00E02758:  B0 3C 00 25
F00:7426       	BEQ.s		LAB_U01C			* if "%" go copy a number character
               S01:00E0275C:  67 06
F00:7427       
F00:7428       	CMP.b		#'#',d0			* compare it with "#"
               S01:00E0275E:  B0 3C 00 23
F00:7429       	BNE.s		LAB_U018			* if not "#" go do the next new format character
               S01:00E02762:  66 EA
F00:7430       
F00:7431       LAB_U01C
F00:7432       	MOVEQ		#'0',d0			* default to "0" character
               S01:00E02764:  70 30
F00:7433       	CMP.w		d3,d6				* compare the number string index with length
               S01:00E02766:  BC 43
F00:7434       	BLS.s		LAB_U020			* if there skip the character get
               S01:00E02768:  63 06
F00:7435       
F00:7436       	MOVE.b	(a2,d3.w),d0		* get a character from the number string
               S01:00E0276A:  10 32 30 00
F00:7437       	ADDQ.w	#1,d3				* increment the number string index
               S01:00E0276E:  52 43
F00:7438       LAB_U020
F00:7439       	MOVE.b	d0,(a0,d4.w)		* save the number character to the new format
               S01:00E02770:  11 80 40 00
F00:7440       							* string
F00:7441       	BRA.s		LAB_U018			* go do the next new format character
               S01:00E02774:  60 D8
F00:7442       
F00:7443       * now copy the integer digit characters from the number string
F00:7444       
F00:7445       LAB_U022
F00:7446       	MOVEQ		#0,d6				* clear the sign done flag
               S01:00E02776:  7C 00
F00:7447       	MOVEQ		#0,d5				* clear the sign present flag
               S01:00E02778:  7A 00
F00:7448       	SUBQ.w	#1,d2				* decrement the number string index
               S01:00E0277A:  53 42
F00:7449       	BNE.s		LAB_U026			* if not now at sign continue
               S01:00E0277C:  66 08
F00:7450       
F00:7451       	MOVEQ		#1,d2				* increment the number string index
               S01:00E0277E:  74 01
F00:7452       	MOVE.b	#'0',(a2,d2.w)		* replace the point with a zero
               S01:00E02780:  15 BC 00 30 20 00
F00:7453       LAB_U026
F00:7454       	MOVE.w	fsdpi(sp),d4		* get the new format string decimal point index
               S01:00E02786:  38 2F 00 08
F00:7455       	CMP.w		d4,d1				* compare it with the new format string length
               S01:00E0278A:  B2 44
F00:7456       	BCC.s		LAB_U02A			* if within the string go use the index
               S01:00E0278C:  64 02
F00:7457       
F00:7458       	MOVE.w	d1,d4				* else set the index to the end of the string
               S01:00E0278E:  38 01
F00:7459       LAB_U02A
F00:7460       	SUBQ.w	#1,d4				* decrement the new format string index
               S01:00E02790:  53 44
F00:7461       	BMI.s		LAB_U03E			* if all done go test for any overflow
               S01:00E02792:  6B 62
F00:7462       
F00:7463       	MOVE.b	(a0,d4.w),d0		* else get a new format string character
               S01:00E02794:  10 30 40 00
F00:7464       
F00:7465       	MOVEQ		#'0',d7			* default to "0" character
               S01:00E02798:  7E 30
F00:7466       	CMP.b		#'%',d0			* compare it with "%"
               S01:00E0279A:  B0 3C 00 25
F00:7467       	BEQ.s		LAB_U02B			* if "%" go copy a number character
               S01:00E0279E:  67 08
F00:7468       
F00:7469       	MOVEQ		#' ',d7			* default to " " character
               S01:00E027A0:  7E 20
F00:7470       	CMP.b		#'#',d0			* compare it with "#"
               S01:00E027A2:  B0 3C 00 23
F00:7471       	BNE.s		LAB_U02C			* if not "#" go try ","
               S01:00E027A6:  66 06
F00:7472       
F00:7473       LAB_U02B
F00:7474       	TST.w		d2				* test the number string index
               S01:00E027A8:  4A 42
F00:7475       	BNE.s		LAB_U036			* if not at the sign go get a number character
               S01:00E027AA:  66 34
F00:7476       
F00:7477       	BRA.s		LAB_U03C			* else go save the default character
               S01:00E027AC:  60 42
F00:7478       
F00:7479       LAB_U02C
F00:7480       	CMP.b		#',',d0			* compare it with ","
               S01:00E027AE:  B0 3C 00 2C
F00:7481       	BNE.s		LAB_U030			* if not "," go try the sign characters
               S01:00E027B2:  66 10
F00:7482       
F00:7483       	TST.w		d2				* test the number string index
               S01:00E027B4:  4A 42
F00:7484       	BNE.s		LAB_U02E			* if not at the sign keep the ","
               S01:00E027B6:  66 08
F00:7485       
F00:7486       	CMP.b		#'%',-1(a0,d4.w)		* else compare the next format string character
               S01:00E027B8:  0C 30 00 25 40 FF
F00:7487       							* with "%"
F00:7488       	BNE.s		LAB_U03C			* if not "%" keep the default character
               S01:00E027BE:  66 30
F00:7489       
F00:7490       LAB_U02E
F00:7491       	MOVE.b	d0,d7				* else use the "," character
               S01:00E027C0:  1E 00
F00:7492       	BRA.s		LAB_U03C			* go save the character to the string
               S01:00E027C2:  60 2C
F00:7493       
F00:7494       LAB_U030
F00:7495       	CMP.b		#'-',d0			* compare it with "-"
               S01:00E027C4:  B0 3C 00 2D
F00:7496       	BEQ.s		LAB_U034			* if "-" go do the sign character
               S01:00E027C8:  67 10
F00:7497       
F00:7498       	CMP.b		#'+',d0			* compare it with "+"
               S01:00E027CA:  B0 3C 00 2B
F00:7499       	BNE.s		LAB_U02A			* if not "+" go do the next new format character
               S01:00E027CE:  66 C0
F00:7500       
F00:7501       	CMP.b		#'-',(a2)			* compare the sign character with "-"
               S01:00E027D0:  0C 12 00 2D
F00:7502       	BEQ.s		LAB_U034			* if "-" don't change the sign character
               S01:00E027D4:  67 04
F00:7503       
F00:7504       	MOVE.b	#'+',(a2)			* else make the sign character "+"
               S01:00E027D6:  14 BC 00 2B
F00:7505       LAB_U034
F00:7506       	MOVE.b	d0,d5				* set the sign present flag
               S01:00E027DA:  1A 00
F00:7507       	TST.w		d2				* test the number string index
               S01:00E027DC:  4A 42
F00:7508       	BEQ.s		LAB_U038			* if at the sign keep the default character
               S01:00E027DE:  67 08
F00:7509       
F00:7510       LAB_U036
F00:7511       	MOVE.b	(a2,d2.w),d7		* else get a character from the number string
               S01:00E027E0:  1E 32 20 00
F00:7512       	SUBQ.w	#1,d2				* decrement the number string index
               S01:00E027E4:  53 42
F00:7513       	BRA.s		LAB_U03C			* go save the character
               S01:00E027E6:  60 08
F00:7514       
F00:7515       LAB_U038
F00:7516       	TST.b		d6				* test the sign done flag
               S01:00E027E8:  4A 06
F00:7517       	BNE.s		LAB_U03C			* if the sign has been done go use the space
               S01:00E027EA:  66 04
F00:7518       							* character
F00:7519       
F00:7520       	MOVE.b	(a2),d7			* else get the sign character
               S01:00E027EC:  1E 12
F00:7521       	MOVE.b	d7,d6				* flag that the sign has been done
               S01:00E027EE:  1C 07
F00:7522       LAB_U03C
F00:7523       	MOVE.b	d7,(a0,d4.w)		* save the number character to the new format
               S01:00E027F0:  11 87 40 00
F00:7524       							* string
F00:7525       	BRA.s		LAB_U02A			* go do the next new format character
               S01:00E027F4:  60 9A
F00:7526       
F00:7527       * test for overflow conditions
F00:7528       
F00:7529       LAB_U03E
F00:7530       	TST.w		d2				* test the number string index
               S01:00E027F6:  4A 42
F00:7531       	BNE.s		LAB_U040			* if all the digits aren't done go output
               S01:00E027F8:  66 14
F00:7532       							* an overflow indication
F00:7533       
F00:7534       * test for sign overflows
F00:7535       
F00:7536       	TST.b		d5				* test the sign present flag
               S01:00E027FA:  4A 05
F00:7537       	BEQ.s		LAB_U04A			* if no sign present go add the string
               S01:00E027FC:  67 54
F00:7538       
F00:7539       * there was a sign in the format string
F00:7540       
F00:7541       	TST.b		d6				* test the sign done flag
               S01:00E027FE:  4A 06
F00:7542       	BNE.s		LAB_U04A			* if the sign is done go add the string
               S01:00E02800:  66 50
F00:7543       
F00:7544       * the sign isn't done so see if it was mandatory
F00:7545       
F00:7546       	CMPI.b	#'+',d5			* compare the sign with "+"
               S01:00E02802:  0C 05 00 2B
F00:7547       	BEQ.s		LAB_U040			* if it was "+" go output an overflow
               S01:00E02806:  67 06
F00:7548       							* indication
F00:7549       
F00:7550       * the sign wasn't mandatory but the number may have been negative
F00:7551       
F00:7552       	CMP.b		#'-',(a2)			* compare the sign character with "-"
               S01:00E02808:  0C 12 00 2D
F00:7553       	BNE.s		LAB_U04A			* if it wasn't "-" go add the string
               S01:00E0280C:  66 44
F00:7554       
F00:7555       * else the sign was "-" and a sign hasn't been output so ..
F00:7556       
F00:7557       * the number overflowed the format string so replace all the special format characters
F00:7558       * with the overflow character
F00:7559       
F00:7560       LAB_U040
F00:7561       	MOVEQ		#ofchr,d5			* set the overflow character
               S01:00E0280E:  7A 23
F00:7562       	MOVE.w	d1,d7				* copy the new format string length
               S01:00E02810:  3E 01
F00:7563       	SUBQ.w	#1,d7				* adjust for the loop type
               S01:00E02812:  53 47
F00:7564       	MOVE.w	fsti(sp),d6			* copy the new format string last index
               S01:00E02814:  3C 2F 00 04
F00:7565       	SUBQ.w	#1,d6				* -1 gives the last character of this string
               S01:00E02818:  53 46
F00:7566       	BGT.s		LAB_U044			* if not zero continue
               S01:00E0281A:  6E 02
F00:7567       
F00:7568       	MOVE.w	d7,d6				* else set the format string index to the end
               S01:00E0281C:  3C 07
F00:7569       LAB_U044
F00:7570       	MOVE.b	(a1,d6.w),d0		* get a character from the format string
               S01:00E0281E:  10 31 60 00
F00:7571       	CMPI.b	#'#',d0			* compare it with "#" special format character
               S01:00E02822:  0C 00 00 23
F00:7572       	BEQ.s		LAB_U046			* if "#" go use the overflow character
               S01:00E02826:  67 1E
F00:7573       
F00:7574       	CMPI.b	#'%',d0			* compare it with "%" special format character
               S01:00E02828:  0C 00 00 25
F00:7575       	BEQ.s		LAB_U046			* if "%" go use the overflow character
               S01:00E0282C:  67 18
F00:7576       
F00:7577       	CMPI.b	#',',d0			* compare it with "," special format character
               S01:00E0282E:  0C 00 00 2C
F00:7578       	BEQ.s		LAB_U046			* if "," go use the overflow character
               S01:00E02832:  67 12
F00:7579       
F00:7580       	CMPI.b	#'+',d0			* compare it with "+" special format character
               S01:00E02834:  0C 00 00 2B
F00:7581       	BEQ.s		LAB_U046			* if "+" go use the overflow character
               S01:00E02838:  67 0C
F00:7582       
F00:7583       	CMPI.b	#'-',d0			* compare it with "-" special format character
               S01:00E0283A:  0C 00 00 2D
F00:7584       	BEQ.s		LAB_U046			* if "-" go use the overflow character
               S01:00E0283E:  67 06
F00:7585       
F00:7586       	CMPI.b	#'.',d0			* compare it with "." special format character
               S01:00E02840:  0C 00 00 2E
F00:7587       	BNE.s		LAB_U048			* if not "." skip the using overflow character
               S01:00E02844:  66 02
F00:7588       
F00:7589       LAB_U046
F00:7590       	MOVE.b	d5,d0				* use the overflow character
               S01:00E02846:  10 05
F00:7591       LAB_U048
F00:7592       	MOVE.b	d0,(a0,d7.w)		* save the character to the new format string
               S01:00E02848:  11 80 70 00
F00:7593       	SUBQ.w	#1,d6				* decrement the format string index
               S01:00E0284C:  53 46
F00:7594       	DBF		d7,LAB_U044			* decrement the count and loop if not all done
               S01:00E0284E:  51 CF FF CE
F00:7595       
F00:7596       * add the new string to the previous string
F00:7597       
F00:7598       LAB_U04A
F00:7599       	LEA		6(a4),a0			* get the descriptor pointer for string 1
               S01:00E02852:  41 EC 00 06
F00:7600       	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
               S01:00E02856:  27 4C 05 90
F00:7601       	BSR		LAB_224E			* concatenate the strings
               S01:00E0285A:  61 00 EE 04
F00:7602       
F00:7603       * now check for any tail on the format string
F00:7604       
F00:7605       	MOVE.w	fsti(sp),d0			* get this index
               S01:00E0285E:  30 2F 00 04
F00:7606       	BEQ.s		LAB_U04C			* if at start of string skip the output
               S01:00E02862:  67 20
F00:7607       
F00:7608       	MOVE.w	d0,fsli(sp)			* save this index to the last index
               S01:00E02864:  3F 40 00 06
F00:7609       	BSR		LAB_ProcFo			* now process the format string
               S01:00E02868:  61 00 00 82
F00:7610       	TST.b		d2				* test the special characters flag
               S01:00E0286C:  4A 02
F00:7611       	BNE.s		LAB_U04C			* if special characters present skip the output
               S01:00E0286E:  66 14
F00:7612       
F00:7613       * else output the new string part
F00:7614       
F00:7615       	BSR.s		LAB_DupFmt			* duplicate the processed format string section
               S01:00E02870:  61 3C
F00:7616       	MOVE.w	fsti(sp),fsli(sp)		* copy this index to the last index
               S01:00E02872:  3F 6F 00 04 00 06
F00:7617       
F00:7618       * add the new string to the previous string
F00:7619       
F00:7620       	LEA		6(a4),a0			* get the descriptor pointer for string 1
               S01:00E02878:  41 EC 00 06
F00:7621       	MOVE.l	a4,FAC1_m(a3)		* save the descriptor pointer for string 2
               S01:00E0287C:  27 4C 05 90
F00:7622       	BSR		LAB_224E			* concatenate the strings
               S01:00E02880:  61 00 ED DE
F00:7623       
F00:7624       * check for another value or end of function
F00:7625       
F00:7626       LAB_U04C
F00:7627       	MOVE.b	(a5)+,d0			* get the next BASIC byte
               S01:00E02884:  10 1D
F00:7628       	CMP.b		#')',d0			* compare with close bracket
               S01:00E02886:  B0 3C 00 29
F00:7629       	BNE		LAB_U002			* if not ")" go do next value
               S01:00E0288A:  66 00 FD CA
F00:7630       
F00:7631       * pop the result string off the descriptor stack
F00:7632       
F00:7633       	MOVEA.l	a4,a0				* copy the result string descriptor pointer
               S01:00E0288E:  20 4C
F00:7634       	MOVE.l	Sstorl(a3),d1		* save the bottom of string space
               S01:00E02890:  22 2B 04 46
F00:7635       	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E02894:  61 00 EE 2C
F00:7636       							* d0 = length, a0 = pointer
F00:7637       	MOVE.l	d1,Sstorl(a3)		* restore the bottom of string space
               S01:00E02898:  27 41 04 46
F00:7638       	MOVEA.l	a0,a1				* copy the string result pointer
               S01:00E0289C:  22 48
F00:7639       	MOVE.w	d0,d1				* copy the string result length
               S01:00E0289E:  32 00
F00:7640       
F00:7641       * pop the format string off the descriptor stack
F00:7642       
F00:7643       	MOVEA.l	(sp)+,a0			* pull the format string descriptor pointer
               S01:00E028A0:  20 5F
F00:7644       	BSR		LAB_22BA			* pop (a0) descriptor, returns with ..
               S01:00E028A2:  61 00 EE 1E
F00:7645       							* d0 = length, a0 = pointer
F00:7646       
F00:7647       	LEA		fend(sp),sp			* dump the saved values
               S01:00E028A6:  50 8F
F00:7648       
F00:7649       * push the result string back on the descriptor stack and return
F00:7650       
F00:7651       	MOVEA.l	a1,a0				* copy the result string pointer back
               S01:00E028A8:  20 49
F00:7652       	BRA		LAB_RTST			* push a string on the descriptor stack and
               S01:00E028AA:  60 00 EC 6C
F00:7653       							* return. a0 = pointer, d1 = length
F00:7654       
F00:7655       
F00:7656       *************************************************************************************
F00:7657       *
F00:7658       * duplicate the processed format string section
F00:7659       
F00:7660       							* make a string as long as the format string
F00:7661       LAB_DupFmt
F00:7662       	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
               S01:00E028AE:  22 6F 00 04
F00:7663       	MOVE.w	4(a1),d7			* get the format string length
               S01:00E028B2:  3E 29 00 04
F00:7664       	MOVE.w	4+fsli(sp),d2		* get the format string last index
               S01:00E028B6:  34 2F 00 0A
F00:7665       	MOVE.w	4+fsti(sp),d6		* get the format string this index
               S01:00E028BA:  3C 2F 00 08
F00:7666       	MOVE.w	d6,d1				* copy the format string this index
               S01:00E028BE:  32 06
F00:7667       	SUB.w		d2,d1				* subtract the format string last index
               S01:00E028C0:  92 42
F00:7668       	BHI.s		LAB_D002			* if > 0 skip the correction
               S01:00E028C2:  62 02
F00:7669       
F00:7670       	ADD.w		d7,d1				* else add the format string length as the
               S01:00E028C4:  D2 47
F00:7671       							* correction
F00:7672       LAB_D002
F00:7673       	BSR		LAB_2115			* make string space d1 bytes long
               S01:00E028C6:  61 00 EC 6A
F00:7674       							* return a0/Sutill = pointer, others unchanged
F00:7675       
F00:7676       * push the new string on the descriptor stack
F00:7677       
F00:7678       	BSR		LAB_RTST			* push a string on the descriptor stack and
               S01:00E028CA:  61 00 EC 4C
F00:7679       							* return. a0 = pointer, d1 = length
F00:7680       
F00:7681       * copy the characters from the format string
F00:7682       
F00:7683       	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
               S01:00E028CE:  22 6F 00 04
F00:7684       	MOVEA.l	(a1),a1			* get the format string pointer
               S01:00E028D2:  22 51
F00:7685       	MOVEQ		#0,d4				* clear the new string index
               S01:00E028D4:  78 00
F00:7686       LAB_D00A
F00:7687       	MOVE.b	(a1,d2.w),(a0,d4.w)	* get a character from the format string and
               S01:00E028D6:  11 B1 20 00 40 00
F00:7688       							* save it to the new string
F00:7689       	ADDQ.w	#1,d4				* increment the new string index
               S01:00E028DC:  52 44
F00:7690       	ADDQ.w	#1,d2				* increment the format string index
               S01:00E028DE:  52 42
F00:7691       	CMP.w		d2,d7				* compare the format index with the length
               S01:00E028E0:  BE 42
F00:7692       	BNE.s		LAB_D00E			* if not there skip the reset
               S01:00E028E2:  66 02
F00:7693       
F00:7694       	MOVEQ		#0,d2				* else reset the format string index
               S01:00E028E4:  74 00
F00:7695       LAB_D00E
F00:7696       	CMP.w		d2,d6				* compare the index with this index
               S01:00E028E6:  BC 42
F00:7697       	BNE.s		LAB_D00A			* if not equal go do the next character
               S01:00E028E8:  66 EC
F00:7698       
F00:7699       	RTS
               S01:00E028EA:  4E 75
F00:7700       
F00:7701       
F00:7702       **************************************************************************************
F00:7703       *
F00:7704       * process the format string
F00:7705       
F00:7706       LAB_ProcFo
F00:7707       	MOVEA.l	4+fsd(sp),a1		* get the format string descriptor pointer
               S01:00E028EC:  22 6F 00 04
F00:7708       	MOVE.w	4(a1),d7			* get the format string length
               S01:00E028F0:  3E 29 00 04
F00:7709       	MOVEA.l	(a1),a1			* get the format string pointer
               S01:00E028F4:  22 51
F00:7710       	MOVE.w	4+fsli(sp),d6		* get the format string last index
               S01:00E028F6:  3C 2F 00 0A
F00:7711       
F00:7712       	MOVE.w	d7,4+fsdpi(sp)		* set the format string decimal point index
               S01:00E028FA:  3F 47 00 0C
F00:7713       	MOVEQ		#0,d5				* no decimal point
               S01:00E028FE:  7A 00
F00:7714       	MOVEQ		#0,d3				* no decimal characters
               S01:00E02900:  76 00
F00:7715       	MOVEQ		#0,d2				* no special characters
               S01:00E02902:  74 00
F00:7716       LAB_P004
F00:7717       	MOVE.b	(a1,d6.w),d0		* get a format string byte
               S01:00E02904:  10 31 60 00
F00:7718       
F00:7719       	CMP.b		#',',d0			* compare it with ","
               S01:00E02908:  B0 3C 00 2C
F00:7720       	BEQ.s		LAB_P01A			* if "," go do the next format string byte
               S01:00E0290C:  67 42
F00:7721       
F00:7722       	CMP.b		#'#',d0			* compare it with "#"
               S01:00E0290E:  B0 3C 00 23
F00:7723       	BEQ.s		LAB_P008			* if "#" go flag special characters
               S01:00E02912:  67 06
F00:7724       
F00:7725       	CMP.b		#'%',d0			* compare it with "%"
               S01:00E02914:  B0 3C 00 25
F00:7726       	BNE.s		LAB_P00C			* if not "%" go try "+"
               S01:00E02918:  66 08
F00:7727       
F00:7728       LAB_P008
F00:7729       	TST.l		d5				* test the decimal point flag
               S01:00E0291A:  4A 85
F00:7730       	BPL.s		LAB_P00E			* if no point skip counting decimal characters
               S01:00E0291C:  6A 10
F00:7731       
F00:7732       	ADDQ.w	#1,d3				* else increment the decimal character count
               S01:00E0291E:  52 43
F00:7733       	BRA.s		LAB_P01A			* go do the next character
               S01:00E02920:  60 2E
F00:7734       
F00:7735       LAB_P00C
F00:7736       	CMP.b		#'+',d0			* compare it with "+"
               S01:00E02922:  B0 3C 00 2B
F00:7737       	BEQ.s		LAB_P00E			* if "+" go flag special characters
               S01:00E02926:  67 06
F00:7738       
F00:7739       	CMP.b		#'-',d0			* compare it with "-"
               S01:00E02928:  B0 3C 00 2D
F00:7740       	BNE.s		LAB_P010			* if not "-" go check decimal point
               S01:00E0292C:  66 04
F00:7741       
F00:7742       LAB_P00E
F00:7743       	OR.b		d0,d2				* flag special characters
               S01:00E0292E:  84 00
F00:7744       	BRA.s		LAB_P01A			* go do the next character
               S01:00E02930:  60 1E
F00:7745       
F00:7746       LAB_P010
F00:7747       	CMP.b		#'.',d0			* compare it with "."
               S01:00E02932:  B0 3C 00 2E
F00:7748       	BNE.s		LAB_P018			* if not "." go check next
               S01:00E02936:  66 14
F00:7749       
F00:7750       * "." a decimal point
F00:7751       
F00:7752       	TST.l		d5				* if there is already a decimal point
               S01:00E02938:  4A 85
F00:7753       	BMI.s		LAB_P01A			* go do the next character
               S01:00E0293A:  6B 14
F00:7754       
F00:7755       	MOVE.w	d6,d0				* copy the decimal point index
               S01:00E0293C:  30 06
F00:7756       	SUB.w		4+fsli(sp),d0		* calculate it from the scan start
               S01:00E0293E:  90 6F 00 0A
F00:7757       	MOVE.w	d0,4+fsdpi(sp)		* save the decimal point index
               S01:00E02942:  3F 40 00 0C
F00:7758       	MOVEQ		#-1,d5			* flag decimal point
               S01:00E02946:  7A FF
F00:7759       	OR.b		d0,d2				* flag special characters
               S01:00E02948:  84 00
F00:7760       	BRA.s		LAB_P01A			* go do the next character
               S01:00E0294A:  60 04
F00:7761       
F00:7762       * was not a special character
F00:7763       
F00:7764       LAB_P018
F00:7765       	TST.b		d2				* test if there have been special characters
               S01:00E0294C:  4A 02
F00:7766       	BNE.s		LAB_P01E			* if so exit the format string process
               S01:00E0294E:  66 08
F00:7767       
F00:7768       LAB_P01A
F00:7769       	ADDQ.w	#1,d6				* increment the format string index
               S01:00E02950:  52 46
F00:7770       	CMP.w		d6,d7				* compare it with the format string length
               S01:00E02952:  BE 46
F00:7771       	BHI.s		LAB_P004			* if length > index go get the next character
               S01:00E02954:  62 AE
F00:7772       
F00:7773       	MOVEQ		#0,d6				* length = index so reset the format string
               S01:00E02956:  7C 00
F00:7774       							* index
F00:7775       LAB_P01E
F00:7776       	MOVE.w	d6,4+fsti(sp)		* save the format string this index
               S01:00E02958:  3F 46 00 08
F00:7777       	MOVE.w	d3,4+fsdc(sp)		* save the format string decimal characters
               S01:00E0295C:  3F 43 00 0E
F00:7778       
F00:7779       	RTS
               S01:00E02960:  4E 75
F00:7780       
F00:7781       
F00:7782       *************************************************************************************
F00:7783       *
F00:7784       * perform BIN$()
F00:7785       * # of leading 0s is in d1, the number is in d0
F00:7786       
F00:7787       LAB_BINS
F00:7788       	CMP.b		#$21,d1			* max + 1
               S01:00E02962:  B2 3C 00 21
F00:7789       	BCC		LAB_FCER			* exit if too big ( > or = )
               S01:00E02966:  64 00 D9 06
F00:7790       
F00:7791       	MOVEQ		#$1F,d2			* bit count-1
               S01:00E0296A:  74 1F
F00:7792       	LEA		Binss(a3),a0		* point to string
               S01:00E0296C:  41 EB 05 B6
F00:7793       	MOVEQ		#$30,d4			* "0" character for ADDX
               S01:00E02970:  78 30
F00:7794       NextB1
F00:7795       	MOVEQ		#0,d3				* clear byte
               S01:00E02972:  76 00
F00:7796       	LSR.l		#1,d0				* shift bit into Xb
               S01:00E02974:  E2 88
F00:7797       	ADDX.b	d4,d3				* add carry and character to zero
               S01:00E02976:  D7 04
F00:7798       	MOVE.b	d3,(a0,d2.w)		* save character to string
               S01:00E02978:  11 83 20 00
F00:7799       	DBF		d2,NextB1			* decrement and loop if not done
               S01:00E0297C:  51 CA FF F4
F00:7800       
F00:7801       * this is the exit code and is also used by HEX$()
F00:7802       
F00:7803       EndBHS
F00:7804       	MOVE.b	#0,BHsend(a3)		* null terminate the string
               S01:00E02980:  17 7C 00 00 05 D6
F00:7805       	TST.b		d1				* test # of characters
               S01:00E02986:  4A 01
F00:7806       	BEQ.s		NextB2			* go truncate string
               S01:00E02988:  67 0E
F00:7807       
F00:7808       	NEG.l		d1				* make -ve
               S01:00E0298A:  44 81
F00:7809       	ADD.l		#BHsend,d1			* effectively (end-length)
               S01:00E0298C:  D2 BC 00 00 05 D6
F00:7810       	LEA		0(a3,d1.w),a0		* effectively add (end-length) to pointer
               S01:00E02992:  41 F3 10 00
F00:7811       	BRA.s		BinPr				* go print string
               S01:00E02996:  60 0E
F00:7812       
F00:7813       * truncate string to remove leading "0"s
F00:7814       
F00:7815       NextB2
F00:7816       	MOVE.b	(a0),d0			* get byte
               S01:00E02998:  10 10
F00:7817       	BEQ.s		BinPr				* if null then end of string so add 1 and go
               S01:00E0299A:  67 0A
F00:7818       							* print it
F00:7819       
F00:7820       	CMP.b		#'0',d0			* compare with "0"
               S01:00E0299C:  B0 3C 00 30
F00:7821       	BNE.s		GoPr				* if not "0" then go print string from here
               S01:00E029A0:  66 0E
F00:7822       
F00:7823       	ADDQ.w	#1,a0				* else increment pointer
               S01:00E029A2:  52 48
F00:7824       	BRA.s		NextB2			* loop always
               S01:00E029A4:  60 F2
F00:7825       
F00:7826       * make fixed length output string - ignore overflows!
F00:7827       
F00:7828       BinPr
F00:7829       	LEA		BHsend(a3),a1		* get string end
               S01:00E029A6:  43 EB 05 D6
F00:7830       	CMPA.l	a1,a0				* are we at the string end
               S01:00E029AA:  B1 C9
F00:7831       	BNE.s		GoPr				* branch if not
               S01:00E029AC:  66 02
F00:7832       
F00:7833       	SUBQ.w	#1,a0				* else need at least one zero
               S01:00E029AE:  53 48
F00:7834       GoPr
F00:7835       	BRA		LAB_20AE			* print " terminated string to FAC1, stack & RET
               S01:00E029B0:  60 00 EB 20
F00:7836       
F00:7837       
F00:7838       *************************************************************************************
F00:7839       *
F00:7840       * perform HEX$()
F00:7841       * # of leading 0s is in d1, the number is in d0
F00:7842       
F00:7843       LAB_HEXS
F00:7844       	CMP.b		#$09,d1			* max + 1
               S01:00E029B4:  B2 3C 00 09
F00:7845       	BCC		LAB_FCER			* exit if too big ( > or = )
               S01:00E029B8:  64 00 D8 B4
F00:7846       
F00:7847       	MOVEQ		#$07,d2			* nibble count-1
               S01:00E029BC:  74 07
F00:7848       	LEA		Hexss(a3),a0		* point to string
               S01:00E029BE:  41 EB 05 CE
F00:7849       	MOVEQ		#$30,d4			* "0" character for ABCD
               S01:00E029C2:  78 30
F00:7850       NextH1
F00:7851       	MOVE.b	d0,d3				* copy lowest byte
               S01:00E029C4:  16 00
F00:7852       	ROR.l		#4,d0				* shift nibble into 0-3
               S01:00E029C6:  E8 98
F00:7853       	AND.b		#$0F,d3			* just this nibble
               S01:00E029C8:  C6 3C 00 0F
F00:7854       	MOVE.b	d3,d5				* copy it
               S01:00E029CC:  1A 03
F00:7855       	ADD.b		#$F6,d5			* set extend bit
               S01:00E029CE:  DA 3C 00 F6
F00:7856       	ABCD		d4,d3				* decimal add extend and character to zero
               S01:00E029D2:  C7 04
F00:7857       	MOVE.b	d3,(a0,d2.w)		* save character to string
               S01:00E029D4:  11 83 20 00
F00:7858       	DBF		d2,NextH1			* decrement and loop if not done
               S01:00E029D8:  51 CA FF EA
F00:7859       
F00:7860       	BRA.s		EndBHS			* go process string
               S01:00E029DC:  60 A2
F00:7861       
F00:7862       
F00:7863       *************************************************************************************
F00:7864       *
F00:7865       * ctrl-c check routine. includes limited "life" byte save for INGET routine
F00:7866       
F00:7867       VEC_CC
F00:7868       	TST.b		ccflag(a3)			* check [CTRL-C] check flag
               S01:00E029DE:  4A 2B 05 E8
F00:7869       	BNE.s		RTS_022			* exit if [CTRL-C] check inhibited
               S01:00E029E2:  66 1E
F00:7870       
F00:7871       	JSR		V_INPT(a3)			* scan input device
               S01:00E029E4:  4E AB 04 0C
F00:7872       	BCC.s		LAB_FBA0			* exit if buffer empty
               S01:00E029E8:  64 0E
F00:7873       
F00:7874       	MOVE.b	d0,ccbyte(a3)		* save received byte
               S01:00E029EA:  17 40 05 E9
F00:7875       	MOVE.b	#$20,ccnull(a3)		* set "life" timer for bytes countdown
               S01:00E029EE:  17 7C 00 20 05 EA
F00:7876       	BRA		LAB_1636			* return to BASIC
               S01:00E029F4:  60 00 DC EA
F00:7877       
F00:7878       LAB_FBA0
F00:7879       	TST.b		ccnull(a3)			* get countdown byte
               S01:00E029F8:  4A 2B 05 EA
F00:7880       	BEQ.s		RTS_022			* exit if finished
               S01:00E029FC:  67 04
F00:7881       
F00:7882       	SUBQ.b	#1,ccnull(a3)		* else decrement countdown
               S01:00E029FE:  53 2B 05 EA
F00:7883       RTS_022
F00:7884       	RTS
               S01:00E02A02:  4E 75
F00:7885       
F00:7886       
F00:7887       *************************************************************************************
F00:7888       *
F00:7889       * get byte from input device, no waiting
F00:7890       * returns with carry set if byte in A
F00:7891       
F00:7892       INGET
F00:7893       	JSR		V_INPT(a3)			* call scan input device
               S01:00E02A04:  4E AB 04 0C
F00:7894       	BCS.s		LAB_FB95			* if byte go reset timer
               S01:00E02A08:  65 0A
F00:7895       
F00:7896       	MOVE.b	ccnull(a3),d0		* get countdown
               S01:00E02A0A:  10 2B 05 EA
F00:7897       	BEQ.s		RTS_022			* exit if empty
               S01:00E02A0E:  67 F2
F00:7898       
F00:7899       	MOVE.b	ccbyte(a3),d0		* get last received byte
               S01:00E02A10:  10 2B 05 E9
F00:7900       LAB_FB95
F00:7901       	MOVE.b	#$00,ccnull(a3)		* clear timer because we got a byte
               S01:00E02A14:  17 7C 00 00 05 EA
F00:7902       	ORI.b		#1,CCR			* set carry, flag we got a byte
               S01:00E02A1A:  00 3C 00 01
F00:7903       	RTS
               S01:00E02A1E:  4E 75
F00:7904       
F00:7905       
F00:7906       *************************************************************************************
F00:7907       *
F00:7908       * perform MAX()
F00:7909       
F00:7910       LAB_MAX
F00:7911       	BSR		LAB_EVEZ			* evaluate expression (no decrement)
               S01:00E02A20:  61 00 E3 36
F00:7912       	TST.b		Dtypef(a3)			* test data type
               S01:00E02A24:  4A 2B 05 B5
F00:7913       	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
               S01:00E02A28:  6B 00 D8 24
F00:7914       
F00:7915       LAB_MAXN
F00:7916       	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
               S01:00E02A2C:  61 2C
F00:7917       							* pull FAC2 & compare with FAC1
F00:7918       	BCC.s		LAB_MAXN			* branch if no swap to do
               S01:00E02A2E:  64 FC
F00:7919       
F00:7920       	BSR		LAB_279B			* copy FAC2 to FAC1
               S01:00E02A30:  61 00 F4 B2
F00:7921       	BRA.s		LAB_MAXN			* go do next
               S01:00E02A34:  60 F6
F00:7922       
F00:7923       
F00:7924       *************************************************************************************
F00:7925       *
F00:7926       * perform MIN()
F00:7927       
F00:7928       LAB_MIN
F00:7929       	BSR		LAB_EVEZ			* evaluate expression (no decrement)
               S01:00E02A36:  61 00 E3 20
F00:7930       	TST.b		Dtypef(a3)			* test data type
               S01:00E02A3A:  4A 2B 05 B5
F00:7931       	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
               S01:00E02A3E:  6B 00 D8 0E
F00:7932       
F00:7933       LAB_MINN
F00:7934       	BSR.s		LAB_PHFA			* push FAC1, evaluate expression,
               S01:00E02A42:  61 16
F00:7935       							* pull FAC2 & compare with FAC1
F00:7936       	BLS.s		LAB_MINN			* branch if no swap to do
               S01:00E02A44:  63 FC
F00:7937       
F00:7938       	BSR		LAB_279B			* copy FAC2 to FAC1
               S01:00E02A46:  61 00 F4 9C
F00:7939       	BRA.s		LAB_MINN			* go do next (branch always)
               S01:00E02A4A:  60 F6
F00:7940       
F00:7941       * exit routine. don't bother returning to the loop code
F00:7942       * check for correct exit, else so syntax error
F00:7943       
F00:7944       LAB_MMEC
F00:7945       	CMP.b		#')',d0			* is it end of function?
               S01:00E02A4C:  B0 3C 00 29
F00:7946       	BNE		LAB_SNER			* if not do MAX MIN syntax error
               S01:00E02A50:  66 00 D8 28
F00:7947       
F00:7948       	LEA		4(sp),sp			* dump return address (faster)
               S01:00E02A54:  58 8F
F00:7949       	BRA		LAB_IGBY			* update BASIC execute pointer (to chr past ")")
               S01:00E02A56:  60 00 E4 5E
F00:7950       							* and return
F00:7951       
F00:7952       * check for next, evaluate & return or exit
F00:7953       * this is the routine that does most of the work
F00:7954       
F00:7955       LAB_PHFA
F00:7956       	BSR		LAB_GBYT			* get next BASIC byte
               S01:00E02A5A:  61 00 E4 5C
F00:7957       	CMP.b		#',',d0			* is there more ?
               S01:00E02A5E:  B0 3C 00 2C
F00:7958       	BNE.s		LAB_MMEC			* if not go do end check
               S01:00E02A62:  66 E8
F00:7959       
F00:7960       	MOVE.w	FAC1_e(a3),-(sp)		* push exponent and sign
               S01:00E02A64:  3F 2B 05 94
F00:7961       	MOVE.l	FAC1_m(a3),-(sp)		* push mantissa
               S01:00E02A68:  2F 2B 05 90
F00:7962       
F00:7963       	BSR		LAB_EVEZ			* evaluate expression (no decrement)
               S01:00E02A6C:  61 00 E2 EA
F00:7964       	TST.b		Dtypef(a3)			* test data type
               S01:00E02A70:  4A 2B 05 B5
F00:7965       	BMI		LAB_TMER			* if string do Type missmatch Error/warm start
               S01:00E02A74:  6B 00 D7 D8
F00:7966       
F00:7967       
F00:7968       							* pop FAC2 (MAX/MIN expression so far)
F00:7969       	MOVE.l	(sp)+,FAC2_m(a3)		* pop mantissa
               S01:00E02A78:  27 5F 05 98
F00:7970       
F00:7971       	MOVE.w	(sp)+,d0			* pop exponent and sign
               S01:00E02A7C:  30 1F
F00:7972       	MOVE.w	d0,FAC2_e(a3)		* save exponent and sign
               S01:00E02A7E:  37 40 05 9C
F00:7973       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* get FAC1 sign
               S01:00E02A82:  17 6B 05 95 05 9E
F00:7974       	EOR.b		d0,FAC_sc(a3)		* EOR to create sign compare
               S01:00E02A88:  B1 2B 05 9E
F00:7975       	BRA		LAB_27FA			* compare FAC1 with FAC2 & return
               S01:00E02A8C:  60 00 F4 C2
F00:7976       							* returns d0=+1 Cb=0 if FAC1 > FAC2
F00:7977       							* returns d0= 0 Cb=0 if FAC1 = FAC2
F00:7978       							* returns d0=-1 Cb=1 if FAC1 < FAC2
F00:7979       
F00:7980       
F00:7981       *************************************************************************************
F00:7982       *
F00:7983       * perform WIDTH
F00:7984       
F00:7985       LAB_WDTH
F00:7986       	CMP.b		#',',d0			* is next byte ","
               S01:00E02A90:  B0 3C 00 2C
F00:7987       	BEQ.s		LAB_TBSZ			* if so do tab size
               S01:00E02A94:  67 2C
F00:7988       
F00:7989       	BSR		LAB_GTBY			* get byte parameter, result in d0 and Itemp
               S01:00E02A96:  61 00 ED 86
F00:7990       	TST.b		d0				* test result
               S01:00E02A9A:  4A 00
F00:7991       	BEQ.s		LAB_NSTT			* branch if set for infinite line
               S01:00E02A9C:  67 12
F00:7992       
F00:7993       	CMP.b		#$10,d0			* else make min width = 16d
               S01:00E02A9E:  B0 3C 00 10
F00:7994       	BCS		LAB_FCER			* if less do function call error & exit
               S01:00E02AA2:  65 00 D7 CA
F00:7995       
F00:7996       * this next compare ensures that we can't exit WIDTH via an error leaving the
F00:7997       * tab size greater than the line length.
F00:7998       
F00:7999       	CMP.b		TabSiz(a3),d0		* compare with tab size
               S01:00E02AA6:  B0 2B 05 E2
F00:8000       	BCC.s		LAB_NSTT			* branch if >= tab size
               S01:00E02AAA:  64 04
F00:8001       
F00:8002       	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
               S01:00E02AAC:  17 40 05 E2
F00:8003       LAB_NSTT
F00:8004       	MOVE.b	d0,TWidth(a3)		* set the terminal width
               S01:00E02AB0:  17 40 05 E6
F00:8005       	BSR		LAB_GBYT			* get BASIC byte back
               S01:00E02AB4:  61 00 E4 02
F00:8006       	BEQ.s		WExit				* exit if no following
               S01:00E02AB8:  67 2C
F00:8007       
F00:8008       	CMP.b		#',',d0			* else is it ","
               S01:00E02ABA:  B0 3C 00 2C
F00:8009       	BNE		LAB_SNER			* if not do syntax error
               S01:00E02ABE:  66 00 D7 BA
F00:8010       
F00:8011       LAB_TBSZ
F00:8012       	BSR		LAB_SGBY			* increment and get byte, result in d0 and Itemp
               S01:00E02AC2:  61 00 ED 56
F00:8013       	TST.b		d0				* test TAB size
               S01:00E02AC6:  4A 00
F00:8014       	BMI		LAB_FCER			* if >127 do function call error & exit
               S01:00E02AC8:  6B 00 D7 A4
F00:8015       
F00:8016       	CMP.b		#1,d0				* compare with min-1
               S01:00E02ACC:  B0 3C 00 01
F00:8017       	BCS		LAB_FCER			* if <=1 do function call error & exit
               S01:00E02AD0:  65 00 D7 9C
F00:8018       
F00:8019       	MOVE.b	TWidth(a3),d1		* set flags for width
               S01:00E02AD4:  12 2B 05 E6
F00:8020       	BEQ.s		LAB_SVTB			* skip check if infinite line
               S01:00E02AD8:  67 08
F00:8021       
F00:8022       	CMP.b		TWidth(a3),d0		* compare TAB with width
               S01:00E02ADA:  B0 2B 05 E6
F00:8023       	BGT		LAB_FCER			* branch if too big
               S01:00E02ADE:  6E 00 D7 8E
F00:8024       
F00:8025       LAB_SVTB
F00:8026       	MOVE.b	d0,TabSiz(a3)		* save TAB size
               S01:00E02AE2:  17 40 05 E2
F00:8027       
F00:8028       * calculate tab column limit from TAB size. The Iclim is set to the last tab
F00:8029       * position on a line that still has at least one whole tab width between it
F00:8030       * and the end of the line.
F00:8031       
F00:8032       WExit
F00:8033       	MOVE.b	TWidth(a3),d0		* get width
               S01:00E02AE6:  10 2B 05 E6
F00:8034       	BEQ.s		LAB_WDLP			* branch if infinite line
               S01:00E02AEA:  67 0A
F00:8035       
F00:8036       	CMP.b		TabSiz(a3),d0		* compare with tab size
               S01:00E02AEC:  B0 2B 05 E2
F00:8037       	BCC.s		LAB_WDLP			* branch if >= tab size
               S01:00E02AF0:  64 04
F00:8038       
F00:8039       	MOVE.b	d0,TabSiz(a3)		* else make tab size = terminal width
               S01:00E02AF2:  17 40 05 E2
F00:8040       LAB_WDLP
F00:8041       	SUB.b		TabSiz(a3),d0		* subtract tab size
               S01:00E02AF6:  90 2B 05 E2
F00:8042       	BCC.s		LAB_WDLP			* loop while no borrow
               S01:00E02AFA:  64 FA
F00:8043       
F00:8044       	ADD.b		TabSiz(a3),d0		* add tab size back
               S01:00E02AFC:  D0 2B 05 E2
F00:8045       	ADD.b		TabSiz(a3),d0		* add tab size back again
               S01:00E02B00:  D0 2B 05 E2
F00:8046       
F00:8047       	NEG.b		d0				* make -ve
               S01:00E02B04:  44 00
F00:8048       	ADD.b		TWidth(a3),d0		* subtract remainder from width
               S01:00E02B06:  D0 2B 05 E6
F00:8049       	MOVE.b	d0,Iclim(a3)		* save tab column limit
               S01:00E02B0A:  17 40 05 E7
F00:8050       RTS_023
F00:8051       	RTS
               S01:00E02B0E:  4E 75
F00:8052       
F00:8053       
F00:8054       *************************************************************************************
F00:8055       *
F00:8056       * perform SQR()
F00:8057       
F00:8058       * d0 is number to find the root of
F00:8059       * d1 is the root result
F00:8060       * d2 is the remainder
F00:8061       * d3 is a counter
F00:8062       * d4 is temp
F00:8063       
F00:8064       LAB_SQR
F00:8065       	TST.b		FAC1_s(a3)			* test FAC1 sign
               S01:00E02B10:  4A 2B 05 95
F00:8066       	BMI		LAB_FCER			* if -ve do function call error
               S01:00E02B14:  6B 00 D7 58
F00:8067       
F00:8068       	TST.b		FAC1_e(a3)			* test exponent
               S01:00E02B18:  4A 2B 05 94
F00:8069       	BEQ.s		RTS_023			* exit if zero
               S01:00E02B1C:  67 F0
F00:8070       
F00:8071       	MOVEM.l	d1-d4,-(sp)			* save registers
               S01:00E02B1E:  48 E7 78 00
F00:8072       	MOVE.l	FAC1_m(a3),d0		* copy FAC1
               S01:00E02B22:  20 2B 05 90
F00:8073       	MOVEQ		#0,d2				* clear remainder
               S01:00E02B26:  74 00
F00:8074       	MOVE.l	d2,d1				* clear root
               S01:00E02B28:  22 02
F00:8075       
F00:8076       	MOVEQ		#$1F,d3			* $1F for DBF, 64 pairs of bits to
               S01:00E02B2A:  76 1F
F00:8077       							* do for a 32 bit result
F00:8078       	BTST		#0,FAC1_e(a3)		* test exponent odd/even
               S01:00E02B2C:  08 2B 00 00 05 94
F00:8079       	BNE.s		LAB_SQE2			* if odd only 1 shift first time
               S01:00E02B32:  66 06
F00:8080       
F00:8081       LAB_SQE1
F00:8082       	ADD.l		d0,d0				* shift highest bit of number ..
               S01:00E02B34:  D0 80
F00:8083       	ADDX.l	d2,d2				* .. into remainder .. never overflows
               S01:00E02B36:  D5 82
F00:8084       	ADD.l		d1,d1				* root = root * 2 .. never overflows
               S01:00E02B38:  D2 81
F00:8085       LAB_SQE2
F00:8086       	ADD.l		d0,d0				* shift highest bit of number ..
               S01:00E02B3A:  D0 80
F00:8087       	ADDX.l	d2,d2				* .. into remainder .. never overflows
               S01:00E02B3C:  D5 82
F00:8088       
F00:8089       	MOVE.l	d1,d4				* copy root
               S01:00E02B3E:  28 01
F00:8090       	ADD.l		d4,d4				* 2n
               S01:00E02B40:  D8 84
F00:8091       	ADDQ.l	#1,d4				* 2n+1
               S01:00E02B42:  52 84
F00:8092       
F00:8093       	CMP.l		d4,d2				* compare 2n+1 to remainder
               S01:00E02B44:  B4 84
F00:8094       	BCS.s		LAB_SQNS			* skip sub if remainder smaller
               S01:00E02B46:  65 04
F00:8095       
F00:8096       	SUB.l		d4,d2				* subtract temp from remainder
               S01:00E02B48:  94 84
F00:8097       	ADDQ.l	#1,d1				* increment root
               S01:00E02B4A:  52 81
F00:8098       LAB_SQNS
F00:8099       	DBF		d3,LAB_SQE1			* loop if not all done
               S01:00E02B4C:  51 CB FF E6
F00:8100       
F00:8101       	MOVE.l	d1,FAC1_m(a3)		* save result mantissa
               S01:00E02B50:  27 41 05 90
F00:8102       	MOVE.b	FAC1_e(a3),d0		* get exponent (d0 is clear here)
               S01:00E02B54:  10 2B 05 94
F00:8103       	SUB.w		#$80,d0			* normalise
               S01:00E02B58:  90 7C 00 80
F00:8104       	LSR.w		#1,d0				* /2
               S01:00E02B5C:  E2 48
F00:8105       	BCC.s		LAB_SQNA			* skip increment if carry clear
               S01:00E02B5E:  64 02
F00:8106       
F00:8107       	ADDQ.w	#1,d0				* add bit zero back in (allow for half shift)
               S01:00E02B60:  52 40
F00:8108       LAB_SQNA
F00:8109       	ADD.w		#$80,d0			* re-bias to $80
               S01:00E02B62:  D0 7C 00 80
F00:8110       	MOVE.b	d0,FAC1_e(a3)		* save it
               S01:00E02B66:  17 40 05 94
F00:8111       	MOVEM.l	(sp)+,d1-d4			* restore registers
               S01:00E02B6A:  4C DF 00 1E
F00:8112       	BRA		LAB_24D5			* normalise FAC1 & return
               S01:00E02B6E:  60 00 F0 B2
F00:8113       
F00:8114       
F00:8115       *************************************************************************************
F00:8116       *
F00:8117       * perform VARPTR()
F00:8118       
F00:8119       LAB_VARPTR
F00:8120       	MOVE.b	(a5)+,d0			* increment pointer
               S01:00E02B72:  10 1D
F00:8121       	BSR		LAB_GVAR			* get variable address in a0
               S01:00E02B74:  61 00 E5 56
F00:8122       	BSR		LAB_1BFB			* scan for ")", else do syntax error/warm start
               S01:00E02B78:  61 00 E3 2A
F00:8123       	MOVE.l	a0,d0				* get var address
               S01:00E02B7C:  20 08
F00:8124       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E02B7E:  60 00 E8 3C
F00:8125       
F00:8126       
F00:8127       *************************************************************************************
F00:8128       *
F00:8129       * perform RAMBASE
F00:8130       
F00:8131       LAB_RAM
F00:8132       	LEA		ram_base(a3),a0		* get start of EhBASIC RAM
               S01:00E02B82:  41 EB 04 00
F00:8133       	MOVE.l	a0,d0				* copy it
               S01:00E02B86:  20 08
F00:8134       	BRA		LAB_AYFC			* convert d0 to signed longword in FAC1 & return
               S01:00E02B88:  60 00 E8 32
F00:8135       
F00:8136       
F00:8137       *************************************************************************************
F00:8138       *
F00:8139       * perform PI
F00:8140       
F00:8141       LAB_PI
F00:8142       	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* pi mantissa (32 bit)
               S01:00E02B8C:  27 7C C9 0F DA A2 05 90
F00:8143       	MOVE.w	#$8200,FAC1_e(a3)		* pi exponent and sign
               S01:00E02B94:  37 7C 82 00 05 94
F00:8144       	RTS
               S01:00E02B9A:  4E 75
F00:8145       
F00:8146       
F00:8147       *************************************************************************************
F00:8148       *
F00:8149       * perform TWOPI
F00:8150       
F00:8151       LAB_TWOPI
F00:8152       	MOVE.l	#$C90FDAA2,FAC1_m(a3)	* 2pi mantissa (32 bit)
               S01:00E02B9C:  27 7C C9 0F DA A2 05 90
F00:8153       	MOVE.w	#$8300,FAC1_e(a3)		* 2pi exponent and sign
               S01:00E02BA4:  37 7C 83 00 05 94
F00:8154       	RTS
               S01:00E02BAA:  4E 75
F00:8155       
F00:8156       
F00:8157       *************************************************************************************
F00:8158       *
F00:8159       * get ASCII string equivalent into FAC1 as integer32 or float
F00:8160       
F00:8161       * entry is with a5 pointing to the first character of the string
F00:8162       * exit with a5 pointing to the first character after the string
F00:8163       
F00:8164       * d0 is character
F00:8165       * d1 is mantissa
F00:8166       * d2 is partial and table mantissa
F00:8167       * d3 is mantissa exponent (decimal & binary)
F00:8168       * d4 is decimal exponent
F00:8169       
F00:8170       * get FAC1 from string
F00:8171       * this routine now handles hex and binary values from strings
F00:8172       * starting with "$" and "%" respectively
F00:8173       
F00:8174       LAB_2887
F00:8175       	MOVEM.l	d1-d5,-(sp)			* save registers
               S01:00E02BAC:  48 E7 7C 00
F00:8176       	MOVEQ		#$00,d1			* clear temp accumulator
               S01:00E02BB0:  72 00
F00:8177       	MOVE.l	d1,d3				* set mantissa decimal exponent count
               S01:00E02BB2:  26 01
F00:8178       	MOVE.l	d1,d4				* clear decimal exponent
               S01:00E02BB4:  28 01
F00:8179       	MOVE.b	d1,FAC1_s(a3)		* clear sign byte
               S01:00E02BB6:  17 41 05 95
F00:8180       	MOVE.b	d1,Dtypef(a3)		* set float data type
               S01:00E02BBA:  17 41 05 B5
F00:8181       	MOVE.b	d1,expneg(a3)		* clear exponent sign
               S01:00E02BBE:  17 41 05 AF
F00:8182       	BSR		LAB_GBYT			* get first byte back
               S01:00E02BC2:  61 00 E2 F4
F00:8183       	BCS.s		LAB_28FE			* go get floating if 1st character numeric
               S01:00E02BC6:  65 3C
F00:8184       
F00:8185       	CMP.b		#'-',d0			* or is it -ve number
               S01:00E02BC8:  B0 3C 00 2D
F00:8186       	BNE.s		LAB_289A			* branch if not
               S01:00E02BCC:  66 08
F00:8187       
F00:8188       	MOVE.b	#$FF,FAC1_s(a3)		* set sign byte
               S01:00E02BCE:  17 7C 00 FF 05 95
F00:8189       	BRA.s		LAB_289C			* now go scan & check for hex/bin/int
               S01:00E02BD4:  60 06
F00:8190       
F00:8191       LAB_289A
F00:8192       							* first character wasn't numeric or -
F00:8193       	CMP.b		#'+',d0			* compare with '+'
               S01:00E02BD6:  B0 3C 00 2B
F00:8194       	BNE.s		LAB_289D			* branch if not '+', go check for '.'/hex/binary
               S01:00E02BDA:  66 06
F00:8195       							* /integer
F00:8196       	
F00:8197       LAB_289C
F00:8198       							* was "+" or "-" to start, so get next character
F00:8199       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E02BDC:  61 00 E2 D8
F00:8200       	BCS.s		LAB_28FE			* branch if numeric character
               S01:00E02BE0:  65 22
F00:8201       
F00:8202       LAB_289D
F00:8203       	CMP.b		#'.',d0			* else compare with '.'
               S01:00E02BE2:  B0 3C 00 2E
F00:8204       	BEQ		LAB_2904			* branch if '.'
               S01:00E02BE6:  67 00 00 92
F00:8205       
F00:8206       							* code here for hex/binary/integer numbers
F00:8207       	CMP.b		#'$',d0			* compare with '$'
               S01:00E02BEA:  B0 3C 00 24
F00:8208       	BEQ		LAB_CHEX			* branch if '$'
               S01:00E02BEE:  67 00 01 0A
F00:8209       
F00:8210       	CMP.b		#'%',d0			* else compare with '%'
               S01:00E02BF2:  B0 3C 00 25
F00:8211       	BEQ		LAB_CBIN			* branch if '%'
               S01:00E02BF6:  67 00 01 64
F00:8212       
F00:8213       	BRA		LAB_2Y01			* not #.$%& so return 0
               S01:00E02BFA:  60 00 00 8C
F00:8214       
F00:8215       LAB_28FD
F00:8216       	BSR		LAB_IGBY			* get next character
               S01:00E02BFE:  61 00 E2 B6
F00:8217       	BCC.s		LAB_2902			* exit loop if not a digit
               S01:00E02C02:  64 6C
F00:8218       
F00:8219       LAB_28FE
F00:8220       	BSR		d1x10				* multiply d1 by 10 and add character
               S01:00E02C04:  61 00 01 A8
F00:8221       	BCC.s		LAB_28FD			* loop for more if no overflow
               S01:00E02C08:  64 F4
F00:8222       
F00:8223       LAB_28FF
F00:8224       							* overflowed mantissa, count 10s exponent
F00:8225       	ADDQ.l	#1,d3				* increment mantissa decimal exponent count
               S01:00E02C0A:  52 83
F00:8226       	BSR		LAB_IGBY			* get next character
               S01:00E02C0C:  61 00 E2 A8
F00:8227       	BCS.s		LAB_28FF			* loop while numeric character
               S01:00E02C10:  65 F8
F00:8228       
F00:8229       							* done overflow, now flush fraction or do E
F00:8230       	CMP.b		#'.',d0			* else compare with '.'
               S01:00E02C12:  B0 3C 00 2E
F00:8231       	BNE.s		LAB_2901			* branch if not '.'
               S01:00E02C16:  66 06
F00:8232       
F00:8233       LAB_2900
F00:8234       							* flush remaining fraction digits
F00:8235       	BSR		LAB_IGBY			* get next character
               S01:00E02C18:  61 00 E2 9C
F00:8236       	BCS		LAB_2900			* loop while numeric character
               S01:00E02C1C:  65 FA
F00:8237       
F00:8238       LAB_2901
F00:8239       							* done number, only (possible) exponent remains
F00:8240       	CMP.b		#'E',d0			* else compare with 'E'
               S01:00E02C1E:  B0 3C 00 45
F00:8241       	BNE.s		LAB_2Y01			* if not 'E' all done, go evaluate
               S01:00E02C22:  66 64
F00:8242       
F00:8243       							* process exponent
F00:8244       	BSR		LAB_IGBY			* get next character
               S01:00E02C24:  61 00 E2 90
F00:8245       	BCS.s		LAB_2X04			* branch if digit
               S01:00E02C28:  65 28
F00:8246       
F00:8247       	CMP.b		#'-',d0			* or is it -ve number
               S01:00E02C2A:  B0 3C 00 2D
F00:8248       	BEQ.s		LAB_2X01			* branch if so
               S01:00E02C2E:  67 06
F00:8249       
F00:8250       	CMP.b		#TK_MINUS,d0		* or is it -ve number
               S01:00E02C30:  B0 3C 00 C0
F00:8251       	BNE.s		LAB_2X02			* branch if not
               S01:00E02C34:  66 08
F00:8252       
F00:8253       LAB_2X01
F00:8254       	MOVE.b	#$FF,expneg(a3)		* set exponent sign
               S01:00E02C36:  17 7C 00 FF 05 AF
F00:8255       	BRA.s		LAB_2X03			* now go scan & check exponent
               S01:00E02C3C:  60 0E
F00:8256       
F00:8257       LAB_2X02
F00:8258       	CMP.b		#'+',d0			* or is it +ve number
               S01:00E02C3E:  B0 3C 00 2B
F00:8259       	BEQ.s		LAB_2X03			* branch if so
               S01:00E02C42:  67 08
F00:8260       
F00:8261       	CMP.b		#TK_PLUS,d0			* or is it +ve number
               S01:00E02C44:  B0 3C 00 BF
F00:8262       	BNE		LAB_SNER			* wasn't - + TK_MINUS TK_PLUS or # so do error
               S01:00E02C48:  66 00 D6 30
F00:8263       
F00:8264       LAB_2X03
F00:8265       	BSR		LAB_IGBY			* get next character
               S01:00E02C4C:  61 00 E2 68
F00:8266       	BCC.s		LAB_2Y01			* if not digit all done, go evaluate
               S01:00E02C50:  64 36
F00:8267       LAB_2X04
F00:8268       	MULU		#10,d4			* multiply decimal exponent by 10
               S01:00E02C52:  C8 FC 00 0A
F00:8269       	AND.l		#$FF,d0			* mask character
               S01:00E02C56:  C0 BC 00 00 00 FF
F00:8270       	SUB.b		#'0',d0			* convert to value
               S01:00E02C5C:  90 3C 00 30
F00:8271       	ADD.l		d0,d4				* add to decimal exponent
               S01:00E02C60:  D8 80
F00:8272       	CMP.b		#48,d4			* compare with decimal exponent limit+10
               S01:00E02C62:  B8 3C 00 30
F00:8273       	BLE.s		LAB_2X03			* loop if no overflow/underflow
               S01:00E02C66:  6F E4
F00:8274       
F00:8275       LAB_2X05
F00:8276       							* exponent value has overflowed
F00:8277       	BSR		LAB_IGBY			* get next character
               S01:00E02C68:  61 00 E2 4C
F00:8278       	BCS.s		LAB_2X05			* loop while numeric digit
               S01:00E02C6C:  65 FA
F00:8279       
F00:8280       	BRA.s		LAB_2Y01			* all done, go evaluate
               S01:00E02C6E:  60 18
F00:8281       
F00:8282       LAB_2902
F00:8283       	CMP.b		#'.',d0			* else compare with '.'
               S01:00E02C70:  B0 3C 00 2E
F00:8284       	BEQ.s		LAB_2904			* branch if was '.'
               S01:00E02C74:  67 04
F00:8285       
F00:8286       	BRA.s		LAB_2901			* branch if not '.' (go check/do 'E')
               S01:00E02C76:  60 A6
F00:8287       
F00:8288       LAB_2903
F00:8289       	SUBQ.l	#1,d3				* decrement mantissa decimal exponent
               S01:00E02C78:  53 83
F00:8290       LAB_2904
F00:8291       							* was dp so get fraction part
F00:8292       	BSR		LAB_IGBY			* get next character
               S01:00E02C7A:  61 00 E2 3A
F00:8293       	BCC.s		LAB_2901			* exit loop if not a digit (go check/do 'E')
               S01:00E02C7E:  64 9E
F00:8294       
F00:8295       	BSR		d1x10				* multiply d1 by 10 and add character
               S01:00E02C80:  61 00 01 2C
F00:8296       	BCC.s		LAB_2903			* loop for more if no overflow
               S01:00E02C84:  64 F2
F00:8297       
F00:8298       	BRA.s		LAB_2900			* else go flush remaining fraction part
               S01:00E02C86:  60 90
F00:8299       
F00:8300       LAB_2Y01
F00:8301       							* now evaluate result
F00:8302       	TST.b		expneg(a3)			* test exponent sign
               S01:00E02C88:  4A 2B 05 AF
F00:8303       	BPL.s		LAB_2Y02			* branch if sign positive
               S01:00E02C8C:  6A 02
F00:8304       
F00:8305       	NEG.l		d4				* negate decimal exponent
               S01:00E02C8E:  44 84
F00:8306       LAB_2Y02
F00:8307       	ADD.l		d3,d4				* add mantissa decimal exponent
               S01:00E02C90:  D8 83
F00:8308       	MOVEQ		#32,d3			* set up max binary exponent
               S01:00E02C92:  76 20
F00:8309       	TST.l		d1				* test mantissa
               S01:00E02C94:  4A 81
F00:8310       	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
               S01:00E02C96:  67 52
F00:8311       
F00:8312       	BMI.s		LAB_2Y04			* branch if already mormalised
               S01:00E02C98:  6B 08
F00:8313       
F00:8314       	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
               S01:00E02C9A:  53 83
F00:8315       LAB_2Y03
F00:8316       	ADD.l		d1,d1				* shift mantissa
               S01:00E02C9C:  D2 81
F00:8317       	DBMI		d3,LAB_2Y03			* decrement & loop if not normalised
               S01:00E02C9E:  5B CB FF FC
F00:8318       
F00:8319       							* ensure not too big or small
F00:8320       LAB_2Y04
F00:8321       	CMP.l		#38,d4			* compare decimal exponent with max exponent
               S01:00E02CA2:  B8 BC 00 00 00 26
F00:8322       	BGT		LAB_OFER			* if greater do overflow error and warm start
               S01:00E02CA8:  6E 00 D5 C0
F00:8323       
F00:8324       	CMP.l		#-38,d4			* compare decimal exponent with min exponent
               S01:00E02CAC:  B8 BC FF FF FF DA
F00:8325       	BLT.s		LAB_ret0			* if less just return zero
               S01:00E02CB2:  6D 34
F00:8326       
F00:8327       	NEG.l		d4				* negate decimal exponent to go right way
               S01:00E02CB4:  44 84
F00:8328       	MULS		#6,d4				* 6 bytes per entry
               S01:00E02CB6:  C9 FC 00 06
F00:8329       	MOVE.l	a0,-(sp)			* save register
               S01:00E02CBA:  2F 08
F00:8330       	LEA		LAB_P_10(pc),a0		* point to table
               S01:00E02CBC:  41 FA 02 10
F00:8331       	MOVE.b	(a0,d4.w),FAC2_e(a3)	* copy exponent for multiply
               S01:00E02CC0:  17 70 40 00 05 9C
F00:8332       	MOVE.l	2(a0,d4.w),FAC2_m(a3)	* copy table mantissa
               S01:00E02CC6:  27 70 40 02 05 98
F00:8333       	MOVE.l	(sp)+,a0			* restore register
               S01:00E02CCC:  20 5F
F00:8334       
F00:8335       	EORI.b	#$80,d3			* normalise input exponent
               S01:00E02CCE:  0A 03 00 80
F00:8336       	MOVE.l	d1,FAC1_m(a3)		* save input mantissa
               S01:00E02CD2:  27 41 05 90
F00:8337       	MOVE.b	d3,FAC1_e(a3)		* save input exponent
               S01:00E02CD6:  17 43 05 94
F00:8338       	MOVE.b	FAC1_s(a3),FAC_sc(a3)	* set sign as sign compare
               S01:00E02CDA:  17 6B 05 95 05 9E
F00:8339       
F00:8340       	MOVEM.l	(sp)+,d1-d5			* restore registers
               S01:00E02CE0:  4C DF 00 3E
F00:8341       	BRA		LAB_MULTIPLY		* go multiply input by table
               S01:00E02CE4:  60 00 F0 64
F00:8342       
F00:8343       LAB_ret0
F00:8344       	MOVEQ		#0,d1				* clear mantissa
               S01:00E02CE8:  72 00
F00:8345       LAB_rtn0
F00:8346       	MOVE.l	d1,d3				* clear exponent
               S01:00E02CEA:  26 01
F00:8347       	MOVE.b	d3,FAC1_e(a3)		* save exponent
               S01:00E02CEC:  17 43 05 94
F00:8348       	MOVE.l	d1,FAC1_m(a3)		* save mantissa
               S01:00E02CF0:  27 41 05 90
F00:8349       	MOVEM.l	(sp)+,d1-d5			* restore registers
               S01:00E02CF4:  4C DF 00 3E
F00:8350       	RTS
               S01:00E02CF8:  4E 75
F00:8351       
F00:8352       
F00:8353       *************************************************************************************
F00:8354       *
F00:8355       * $ for hex add-on
F00:8356       
F00:8357       * gets here if the first character was "$" for hex
F00:8358       * get hex number
F00:8359       
F00:8360       LAB_CHEX
F00:8361       	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
               S01:00E02CFA:  17 7C 00 40 05 B5
F00:8362       	MOVEQ		#32,d3			* set up max binary exponent
               S01:00E02D00:  76 20
F00:8363       LAB_CHXX
F00:8364       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E02D02:  61 00 E1 B2
F00:8365       	BCS.s		LAB_ISHN			* branch if numeric character
               S01:00E02D06:  65 14
F00:8366       
F00:8367       	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
               S01:00E02D08:  80 3C 00 20
F00:8368       	SUB.b		#'a',d0			* subtract "a"
               S01:00E02D0C:  90 3C 00 61
F00:8369       	BCS.s		LAB_CHX3			* exit if <"a"
               S01:00E02D10:  65 2A
F00:8370       
F00:8371       	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
               S01:00E02D12:  B0 3C 00 06
F00:8372       	BCC.s		LAB_CHX3			* exit if >"f"
               S01:00E02D16:  64 24
F00:8373       
F00:8374       	ADD.b		#$3A,d0			* convert to nibble+"0"
               S01:00E02D18:  D0 3C 00 3A
F00:8375       LAB_ISHN
F00:8376       	BSR.s		d1x16				* multiply d1 by 16 and add character
               S01:00E02D1C:  61 6C
F00:8377       	BCC.s		LAB_CHXX			* loop for more if no overflow
               S01:00E02D1E:  64 E2
F00:8378       
F00:8379       							* overflowed mantissa, count 16s exponent
F00:8380       LAB_CHX1
F00:8381       	ADDQ.l	#4,d3				* increment mantissa exponent count
               S01:00E02D20:  58 83
F00:8382       	BVS		LAB_OFER			* do overflow error if overflowed
               S01:00E02D22:  69 00 D5 46
F00:8383       
F00:8384       	BSR		LAB_IGBY			* get next character
               S01:00E02D26:  61 00 E1 8E
F00:8385       	BCS.s		LAB_CHX1			* loop while numeric character
               S01:00E02D2A:  65 F4
F00:8386       
F00:8387       	OR.b		#$20,d0			* case convert, allow "A" to "F" and "a" to "f"
               S01:00E02D2C:  80 3C 00 20
F00:8388       	SUB.b		#'a',d0			* subtract "a"
               S01:00E02D30:  90 3C 00 61
F00:8389       	BCS.s		LAB_CHX3			* exit if <"a"
               S01:00E02D34:  65 06
F00:8390       
F00:8391       	CMP.b		#$06,d0			* compare normalised with $06 (max+1)
               S01:00E02D36:  B0 3C 00 06
F00:8392       	BCS.s		LAB_CHX1			* loop if <="f"
               S01:00E02D3A:  65 E4
F00:8393       
F00:8394       							* now return value
F00:8395       LAB_CHX3
F00:8396       	TST.l		d1				* test mantissa
               S01:00E02D3C:  4A 81
F00:8397       	BEQ.s		LAB_rtn0			* if mantissa=0 return 0
               S01:00E02D3E:  67 AA
F00:8398       
F00:8399       	BMI.s		LAB_exxf			* branch if already mormalised
               S01:00E02D40:  6B 08
F00:8400       
F00:8401       	SUBQ.l	#1,d3				* decrement bianry exponent for DBMI loop
               S01:00E02D42:  53 83
F00:8402       LAB_CHX2
F00:8403       	ADD.l		d1,d1				* shift mantissa
               S01:00E02D44:  D2 81
F00:8404       	DBMI		d3,LAB_CHX2			* decrement & loop if not normalised
               S01:00E02D46:  5B CB FF FC
F00:8405       
F00:8406       LAB_exxf
F00:8407       	EORI.b	#$80,d3			* normalise exponent
               S01:00E02D4A:  0A 03 00 80
F00:8408       	MOVE.b	d3,FAC1_e(a3)		* save exponent
               S01:00E02D4E:  17 43 05 94
F00:8409       	MOVE.l	d1,FAC1_m(a3)		* save mantissa
               S01:00E02D52:  27 41 05 90
F00:8410       	MOVEM.l	(sp)+,d1-d5			* restore registers
               S01:00E02D56:  4C DF 00 3E
F00:8411       RTS_024
F00:8412       	RTS
               S01:00E02D5A:  4E 75
F00:8413       
F00:8414       
F00:8415       *************************************************************************************
F00:8416       *
F00:8417       * % for binary add-on
F00:8418       
F00:8419       * gets here if the first character was "%" for binary
F00:8420       * get binary number
F00:8421       
F00:8422       LAB_CBIN
F00:8423       	MOVE.b	#$40,Dtypef(a3)		* set integer numeric data type
               S01:00E02D5C:  17 7C 00 40 05 B5
F00:8424       	MOVEQ		#32,d3			* set up max binary exponent
               S01:00E02D62:  76 20
F00:8425       LAB_CBXN
F00:8426       	BSR		LAB_IGBY			* increment & scan memory
               S01:00E02D64:  61 00 E1 50
F00:8427       	BCC.s		LAB_CHX3			* if not numeric character go return value
               S01:00E02D68:  64 D2
F00:8428       
F00:8429       	CMP.b		#'2',d0			* compare with "2" (max+1)
               S01:00E02D6A:  B0 3C 00 32
F00:8430       	BCC.s		LAB_CHX3			* if >="2" go return value
               S01:00E02D6E:  64 CC
F00:8431       
F00:8432       	MOVE.l	d1,d2				* copy value
               S01:00E02D70:  24 01
F00:8433       	BSR.s		d1x02				* multiply d1 by 2 and add character
               S01:00E02D72:  61 24
F00:8434       	BCC.s		LAB_CBXN			* loop for more if no overflow
               S01:00E02D74:  64 EE
F00:8435       
F00:8436       							* overflowed mantissa, count 2s exponent
F00:8437       LAB_CBX1
F00:8438       	ADDQ.l	#1,d3				* increment mantissa exponent count
               S01:00E02D76:  52 83
F00:8439       	BVS		LAB_OFER			* do overflow error if overflowed
               S01:00E02D78:  69 00 D4 F0
F00:8440       
F00:8441       	BSR		LAB_IGBY			* get next character
               S01:00E02D7C:  61 00 E1 38
F00:8442       	BCC.s		LAB_CHX3			* if not numeric character go return value
               S01:00E02D80:  64 BA
F00:8443       
F00:8444       	CMP.b		#'2',d0			* compare with "2" (max+1)
               S01:00E02D82:  B0 3C 00 32
F00:8445       	BCS.s		LAB_CBX1			* loop if <"2"
               S01:00E02D86:  65 EE
F00:8446       
F00:8447       	BRA.s		LAB_CHX3			* if not numeric character go return value
               S01:00E02D88:  60 B2
F00:8448       
F00:8449       * half way decent times 16 and times 2 with overflow checks
F00:8450       
F00:8451       d1x16
F00:8452       	MOVE.l	d1,d2				* copy value
               S01:00E02D8A:  24 01
F00:8453       	ADD.l		d2,d2				* times two
               S01:00E02D8C:  D4 82
F00:8454       	BCS.s		RTS_024			* return if overflow
               S01:00E02D8E:  65 CA
F00:8455       
F00:8456       	ADD.l		d2,d2				* times four
               S01:00E02D90:  D4 82
F00:8457       	BCS.s		RTS_024			* return if overflow
               S01:00E02D92:  65 C6
F00:8458       
F00:8459       	ADD.l		d2,d2				* times eight
               S01:00E02D94:  D4 82
F00:8460       	BCS.s		RTS_024			* return if overflow
               S01:00E02D96:  65 C2
F00:8461       
F00:8462       d1x02
F00:8463       	ADD.l		d2,d2				* times sixteen (ten/two)
               S01:00E02D98:  D4 82
F00:8464       	BCS.s		RTS_024			* return if overflow
               S01:00E02D9A:  65 BE
F00:8465       
F00:8466       * now add in new digit
F00:8467       
F00:8468       	AND.l		#$FF,d0			* mask character
               S01:00E02D9C:  C0 BC 00 00 00 FF
F00:8469       	SUB.b		#'0',d0			* convert to value
               S01:00E02DA2:  90 3C 00 30
F00:8470       	ADD.l		d0,d2				* add to result
               S01:00E02DA6:  D4 80
F00:8471       	BCS.s		RTS_024			* return if overflow, it should never ever do
               S01:00E02DA8:  65 B0
F00:8472       							* this
F00:8473       
F00:8474       	MOVE.l	d2,d1				* copy result
               S01:00E02DAA:  22 02
F00:8475       	RTS
               S01:00E02DAC:  4E 75
F00:8476       
F00:8477       * half way decent times 10 with overflow checks
F00:8478       
F00:8479       d1x10
F00:8480       	MOVE.l	d1,d2				* copy value
               S01:00E02DAE:  24 01
F00:8481       	ADD.l		d2,d2				* times two
               S01:00E02DB0:  D4 82
F00:8482       	BCS.s		RTS_025			* return if overflow
               S01:00E02DB2:  65 08
F00:8483       
F00:8484       	ADD.l		d2,d2				* times four
               S01:00E02DB4:  D4 82
F00:8485       	BCS.s		RTS_025			* return if overflow
               S01:00E02DB6:  65 04
F00:8486       
F00:8487       	ADD.l		d1,d2				* times five
               S01:00E02DB8:  D4 81
F00:8488       	BCC.s		d1x02				* do times two and add in new digit if ok
               S01:00E02DBA:  64 DC
F00:8489       
F00:8490       RTS_025
F00:8491       	RTS
               S01:00E02DBC:  4E 75
F00:8492       
F00:8493       
F00:8494       *************************************************************************************
F00:8495       
F00:8496       * token values needed for BASIC
F00:8497       
F00:8498       TK_END		EQU $80			* $80
F00:8499       TK_FOR		EQU TK_END+1		* $81
F00:8500       TK_NEXT		EQU TK_FOR+1		* $82
F00:8501       TK_DATA		EQU TK_NEXT+1		* $83
F00:8502       TK_INPUT		EQU TK_DATA+1		* $84
F00:8503       TK_DIM		EQU TK_INPUT+1		* $85
F00:8504       TK_READ		EQU TK_DIM+1		* $86
F00:8505       TK_LET		EQU TK_READ+1		* $87
F00:8506       TK_DEC		EQU TK_LET+1		* $88
F00:8507       TK_GOTO		EQU TK_DEC+1		* $89
F00:8508       TK_RUN		EQU TK_GOTO+1		* $8A
F00:8509       TK_IF			EQU TK_RUN+1		* $8B
F00:8510       TK_RESTORE		EQU TK_IF+1			* $8C
F00:8511       TK_GOSUB		EQU TK_RESTORE+1		* $8D
F00:8512       TK_RETURN		EQU TK_GOSUB+1		* $8E
F00:8513       TK_REM		EQU TK_RETURN+1		* $8F
F00:8514       TK_STOP		EQU TK_REM+1		* $90
F00:8515       TK_ON			EQU TK_STOP+1		* $91
F00:8516       TK_NULL		EQU TK_ON+1			* $92
F00:8517       TK_INC		EQU TK_NULL+1		* $93
F00:8518       TK_WAIT		EQU TK_INC+1		* $94
F00:8519       TK_LOAD		EQU TK_WAIT+1		* $95
F00:8520       TK_SAVE		EQU TK_LOAD+1		* $96
F00:8521       TK_DEF		EQU TK_SAVE+1		* $97
F00:8522       TK_POKE		EQU TK_DEF+1		* $98
F00:8523       TK_DOKE		EQU TK_POKE+1		* $99
F00:8524       TK_LOKE		EQU TK_DOKE+1		* $9A
F00:8525       TK_CALL		EQU TK_LOKE+1		* $9B
F00:8526       TK_DO			EQU TK_CALL+1		* $9C
F00:8527       TK_LOOP		EQU TK_DO+1			* $9D
F00:8528       TK_PRINT		EQU TK_LOOP+1		* $9E
F00:8529       TK_CONT		EQU TK_PRINT+1		* $9F
F00:8530       
F00:8531       TK_BUFFER		EQU TK_CONT+1		* $A0 EASy68k graphics extension
F00:8532       TK_CLS		EQU TK_BUFFER+1		* $A1 EASy68k graphics extension
F00:8533       TK_CURSOR		EQU TK_CLS+1		* $A2 EASy68k graphics extension
F00:8534       TK_LINE		EQU TK_CURSOR+1		* $A3 EASy68k graphics extension
F00:8535       TK_FILL		EQU TK_LINE+1		* $A4 EASy68k graphics extension
F00:8536       TK_MOVE		EQU TK_FILL+1		* $A5 EASy68k graphics extension
F00:8537       TK_POINT		EQU TK_MOVE+1		* $A6 EASy68k graphics extension
F00:8538       TK_RECT		EQU TK_POINT+1		* $A7 EASy68k graphics extension
F00:8539       TK_FRECT		EQU TK_RECT+1		* $A8 EASy68k graphics extension
F00:8540       TK_ELLIPSE		EQU TK_FRECT+1		* $A9 EASy68k graphics extension
F00:8541       TK_FELLIPSE		EQU TK_ELLIPSE+1		* $AA EASy68k graphics extension
F00:8542       TK_MODE		EQU TK_FELLIPSE+1		* $AB EASy68k graphics extension
F00:8543       TK_SIZE		EQU TK_MODE+1		* $AC EASy68k graphics extension
F00:8544       
F00:8545       TK_LIST		EQU TK_SIZE+1		* $AD
F00:8546       TK_CLEAR		EQU TK_LIST+1		* $AE
F00:8547       TK_NEW		EQU TK_CLEAR+1		* $AF
F00:8548       TK_WIDTH		EQU TK_NEW+1		* $B0
F00:8549       TK_GET		EQU TK_WIDTH+1		* $B1
F00:8550       TK_SWAP		EQU TK_GET+1		* $B2
F00:8551       TK_BITSET		EQU TK_SWAP+1		* $B3
F00:8552       TK_BITCLR		EQU TK_BITSET+1		* $B4
F00:8553       TK_TAB		EQU TK_BITCLR+1		* $B5
F00:8554       TK_ELSE		EQU TK_TAB+1		* $B6
F00:8555       TK_TO			EQU TK_ELSE+1		* $B7
F00:8556       TK_FN			EQU TK_TO+1			* $B8
F00:8557       TK_SPC		EQU TK_FN+1			* $B9
F00:8558       TK_THEN		EQU TK_SPC+1		* $BA
F00:8559       TK_NOT		EQU TK_THEN+1		* $BB
F00:8560       TK_STEP		EQU TK_NOT+1		* $BC
F00:8561       TK_UNTIL		EQU TK_STEP+1		* $BD
F00:8562       TK_WHILE		EQU TK_UNTIL+1		* $BE
F00:8563       TK_PLUS		EQU TK_WHILE+1		* $BF
F00:8564       TK_MINUS		EQU TK_PLUS+1		* $C0
F00:8565       TK_MULT		EQU TK_MINUS+1		* $C1
F00:8566       TK_DIV		EQU TK_MULT+1		* $C2
F00:8567       TK_POWER		EQU TK_DIV+1		* $C3
F00:8568       TK_AND		EQU TK_POWER+1		* $C4
F00:8569       TK_EOR		EQU TK_AND+1		* $C5
F00:8570       TK_OR			EQU TK_EOR+1		* $C6
F00:8571       TK_RSHIFT		EQU TK_OR+1			* $C7
F00:8572       TK_LSHIFT		EQU TK_RSHIFT+1		* $C8
F00:8573       TK_GT			EQU TK_LSHIFT+1		* $C9
F00:8574       TK_EQUAL		EQU TK_GT+1			* $CA
F00:8575       TK_LT			EQU TK_EQUAL+1		* $CB
F00:8576       TK_SGN		EQU TK_LT+1			* $CC
F00:8577       TK_INT		EQU TK_SGN+1		* $CD
F00:8578       TK_ABS		EQU TK_INT+1		* $CE
F00:8579       TK_USR		EQU TK_ABS+1		* $CF
F00:8580       TK_FRE		EQU TK_USR+1		* $D0
F00:8581       TK_POS		EQU TK_FRE+1		* $D1
F00:8582       TK_SQR		EQU TK_POS+1		* $D2
F00:8583       TK_RND		EQU TK_SQR+1		* $D3
F00:8584       TK_LOG		EQU TK_RND+1		* $D4
F00:8585       TK_EXP		EQU TK_LOG+1		* $D5
F00:8586       TK_COS		EQU TK_EXP+1		* $D6
F00:8587       TK_SIN		EQU TK_COS+1		* $D7
F00:8588       TK_TAN		EQU TK_SIN+1		* $D8
F00:8589       TK_ATN		EQU TK_TAN+1		* $D9
F00:8590       TK_PEEK		EQU TK_ATN+1		* $DA
F00:8591       TK_DEEK		EQU TK_PEEK+1		* $DB
F00:8592       TK_LEEK		EQU TK_DEEK+1		* $DC
F00:8593       TK_LEN		EQU TK_LEEK+1		* $DD
F00:8594       TK_STRS		EQU TK_LEN+1		* $DE
F00:8595       TK_VAL		EQU TK_STRS+1		* $DF
F00:8596       TK_ASC		EQU TK_VAL+1		* $E0
F00:8597       TK_UCASES		EQU TK_ASC+1		* $E1
F00:8598       TK_LCASES		EQU TK_UCASES+1		* $E2
F00:8599       TK_CHRS		EQU TK_LCASES+1		* $E3
F00:8600       TK_HEXS		EQU TK_CHRS+1		* $E4
F00:8601       TK_BINS		EQU TK_HEXS+1		* $E5
F00:8602       TK_BITTST		EQU TK_BINS+1		* $E6
F00:8603       TK_MAX		EQU TK_BITTST+1		* $E7
F00:8604       TK_MIN		EQU TK_MAX+1		* $E8
F00:8605       TK_RAM		EQU TK_MIN+1		* $E9
F00:8606       TK_KEYS		EQU TK_RAM+1		* $EA EASy68k simulator extension
F00:8607       TK_TI			EQU TK_KEYS+1		* $EB EASy68k simulator extension
F00:8608       TK_PI			EQU TK_TI+1			* $EC
F00:8609       TK_TWOPI		EQU TK_PI+1			* $ED
F00:8610       TK_VPTR		EQU TK_TWOPI+1		* $EE
F00:8611       TK_SADD		EQU TK_VPTR+1		* $EF
F00:8612       TK_LEFTS		EQU TK_SADD+1		* $F0
F00:8613       TK_RIGHTS		EQU TK_LEFTS+1		* $F1
F00:8614       TK_MIDS		EQU TK_RIGHTS+1		* $F2
F00:8615       TK_USINGS		EQU TK_MIDS+1		* $F3
F00:8616       
F00:8617       
F00:8618       ************************************************************************************
F00:8619       *
F00:8620       * binary to unsigned decimal table
F00:8621       
F00:8622       Bin2dec
F00:8623       	dc.l	$3B9ACA00				* 1000000000
               S01:00E02DBE:  3B 9A CA 00
F00:8624       	dc.l	$05F5E100				* 100000000
               S01:00E02DC2:  05 F5 E1 00
F00:8625       	dc.l	$00989680				* 10000000
               S01:00E02DC6:  00 98 96 80
F00:8626       	dc.l	$000F4240				* 1000000
               S01:00E02DCA:  00 0F 42 40
F00:8627       	dc.l	$000186A0				* 100000
               S01:00E02DCE:  00 01 86 A0
F00:8628       	dc.l	$00002710				* 10000
               S01:00E02DD2:  00 00 27 10
F00:8629       	dc.l	$000003E8				* 1000
               S01:00E02DD6:  00 00 03 E8
F00:8630       	dc.l	$00000064				* 100
               S01:00E02DDA:  00 00 00 64
F00:8631       	dc.l	$0000000A				* 10
               S01:00E02DDE:  00 00 00 0A
F00:8632       	dc.l	$00000000				* 0 end marker
               S01:00E02DE2:  00 00 00 00
F00:8633       
F00:8634       LAB_RSED
F00:8635       	dc.l	$332E3232				* 858665522
               S01:00E02DE6:  33 2E 32 32
F00:8636       
F00:8637       * string to value exponent table
F00:8638       
F00:8639       	dc.w	255<<8				* 10**38
               S01:00E02DEA:  FF 00
F00:8640       	dc.l	$96769951
               S01:00E02DEC:  96 76 99 51
F00:8641       	dc.w	251<<8				* 10**37
               S01:00E02DF0:  FB 00
F00:8642       	dc.l	$F0BDC21B
               S01:00E02DF2:  F0 BD C2 1B
F00:8643       	dc.w	248<<8				* 10**36
               S01:00E02DF6:  F8 00
F00:8644       	dc.l	$C097CE7C
               S01:00E02DF8:  C0 97 CE 7C
F00:8645       	dc.w	245<<8				* 10**35
               S01:00E02DFC:  F5 00
F00:8646       	dc.l	$9A130B96
               S01:00E02DFE:  9A 13 0B 96
F00:8647       	dc.w	241<<8				* 10**34
               S01:00E02E02:  F1 00
F00:8648       	dc.l	$F684DF57
               S01:00E02E04:  F6 84 DF 57
F00:8649       	dc.w	238<<8				* 10**33
               S01:00E02E08:  EE 00
F00:8650       	dc.l	$C5371912
               S01:00E02E0A:  C5 37 19 12
F00:8651       	dc.w	235<<8				* 10**32
               S01:00E02E0E:  EB 00
F00:8652       	dc.l	$9DC5ADA8
               S01:00E02E10:  9D C5 AD A8
F00:8653       	dc.w	231<<8				* 10**31
               S01:00E02E14:  E7 00
F00:8654       	dc.l	$FC6F7C40
               S01:00E02E16:  FC 6F 7C 40
F00:8655       	dc.w	228<<8				* 10**30
               S01:00E02E1A:  E4 00
F00:8656       	dc.l	$C9F2C9CD
               S01:00E02E1C:  C9 F2 C9 CD
F00:8657       	dc.w	225<<8				* 10**29
               S01:00E02E20:  E1 00
F00:8658       	dc.l	$A18F07D7
               S01:00E02E22:  A1 8F 07 D7
F00:8659       	dc.w	222<<8				* 10**28
               S01:00E02E26:  DE 00
F00:8660       	dc.l	$813F3979
               S01:00E02E28:  81 3F 39 79
F00:8661       	dc.w	218<<8				* 10**27
               S01:00E02E2C:  DA 00
F00:8662       	dc.l	$CECB8F28
               S01:00E02E2E:  CE CB 8F 28
F00:8663       	dc.w	215<<8				* 10**26
               S01:00E02E32:  D7 00
F00:8664       	dc.l	$A56FA5BA
               S01:00E02E34:  A5 6F A5 BA
F00:8665       	dc.w	212<<8				* 10**25
               S01:00E02E38:  D4 00
F00:8666       	dc.l	$84595161
               S01:00E02E3A:  84 59 51 61
F00:8667       	dc.w	208<<8				* 10**24
               S01:00E02E3E:  D0 00
F00:8668       	dc.l	$D3C21BCF
               S01:00E02E40:  D3 C2 1B CF
F00:8669       	dc.w	205<<8				* 10**23
               S01:00E02E44:  CD 00
F00:8670       	dc.l	$A968163F
               S01:00E02E46:  A9 68 16 3F
F00:8671       	dc.w	202<<8				* 10**22
               S01:00E02E4A:  CA 00
F00:8672       	dc.l	$87867832
               S01:00E02E4C:  87 86 78 32
F00:8673       	dc.w	198<<8				* 10**21
               S01:00E02E50:  C6 00
F00:8674       	dc.l	$D8D726B7
               S01:00E02E52:  D8 D7 26 B7
F00:8675       	dc.w	195<<8				* 10**20
               S01:00E02E56:  C3 00
F00:8676       	dc.l	$AD78EBC6
               S01:00E02E58:  AD 78 EB C6
F00:8677       	dc.w	192<<8				* 10**19
               S01:00E02E5C:  C0 00
F00:8678       	dc.l	$8AC72305
               S01:00E02E5E:  8A C7 23 05
F00:8679       	dc.w	188<<8				* 10**18
               S01:00E02E62:  BC 00
F00:8680       	dc.l	$DE0B6B3A
               S01:00E02E64:  DE 0B 6B 3A
F00:8681       	dc.w	185<<8				* 10**17
               S01:00E02E68:  B9 00
F00:8682       	dc.l	$B1A2BC2F
               S01:00E02E6A:  B1 A2 BC 2F
F00:8683       	dc.w	182<<8				* 10**16
               S01:00E02E6E:  B6 00
F00:8684       	dc.l	$8E1BC9BF
               S01:00E02E70:  8E 1B C9 BF
F00:8685       	dc.w	178<<8				* 10**15
               S01:00E02E74:  B2 00
F00:8686       	dc.l	$E35FA932
               S01:00E02E76:  E3 5F A9 32
F00:8687       	dc.w	175<<8				* 10**14
               S01:00E02E7A:  AF 00
F00:8688       	dc.l	$B5E620F5
               S01:00E02E7C:  B5 E6 20 F5
F00:8689       	dc.w	172<<8				* 10**13
               S01:00E02E80:  AC 00
F00:8690       	dc.l	$9184E72A
               S01:00E02E82:  91 84 E7 2A
F00:8691       	dc.w	168<<8				* 10**12
               S01:00E02E86:  A8 00
F00:8692       	dc.l	$E8D4A510
               S01:00E02E88:  E8 D4 A5 10
F00:8693       	dc.w	165<<8				* 10**11
               S01:00E02E8C:  A5 00
F00:8694       	dc.l	$BA43B740
               S01:00E02E8E:  BA 43 B7 40
F00:8695       	dc.w	162<<8				* 10**10
               S01:00E02E92:  A2 00
F00:8696       	dc.l	$9502F900
               S01:00E02E94:  95 02 F9 00
F00:8697       	dc.w	158<<8				* 10**9
               S01:00E02E98:  9E 00
F00:8698       	dc.l	$EE6B2800
               S01:00E02E9A:  EE 6B 28 00
F00:8699       	dc.w	155<<8				* 10**8
               S01:00E02E9E:  9B 00
F00:8700       	dc.l	$BEBC2000
               S01:00E02EA0:  BE BC 20 00
F00:8701       	dc.w	152<<8				* 10**7
               S01:00E02EA4:  98 00
F00:8702       	dc.l	$98968000
               S01:00E02EA6:  98 96 80 00
F00:8703       	dc.w	148<<8				* 10**6
               S01:00E02EAA:  94 00
F00:8704       	dc.l	$F4240000
               S01:00E02EAC:  F4 24 00 00
F00:8705       	dc.w	145<<8				* 10**5
               S01:00E02EB0:  91 00
F00:8706       	dc.l	$C3500000
               S01:00E02EB2:  C3 50 00 00
F00:8707       	dc.w	142<<8				* 10**4
               S01:00E02EB6:  8E 00
F00:8708       	dc.l	$9C400000
               S01:00E02EB8:  9C 40 00 00
F00:8709       	dc.w	138<<8				* 10**3
               S01:00E02EBC:  8A 00
F00:8710       	dc.l	$FA000000
               S01:00E02EBE:  FA 00 00 00
F00:8711       	dc.w	135<<8				* 10**2
               S01:00E02EC2:  87 00
F00:8712       	dc.l	$C8000000
               S01:00E02EC4:  C8 00 00 00
F00:8713       	dc.w	132<<8				* 10**1
               S01:00E02EC8:  84 00
F00:8714       	dc.l	$A0000000
               S01:00E02ECA:  A0 00 00 00
F00:8715       LAB_P_10
F00:8716       	dc.w	129<<8				* 10**0
               S01:00E02ECE:  81 00
F00:8717       	dc.l	$80000000
               S01:00E02ED0:  80 00 00 00
F00:8718       	dc.w	125<<8				* 10**-1
               S01:00E02ED4:  7D 00
F00:8719       	dc.l	$CCCCCCCD
               S01:00E02ED6:  CC CC CC CD
F00:8720       	dc.w	122<<8				* 10**-2
               S01:00E02EDA:  7A 00
F00:8721       	dc.l	$A3D70A3D
               S01:00E02EDC:  A3 D7 0A 3D
F00:8722       	dc.w	119<<8				* 10**-3
               S01:00E02EE0:  77 00
F00:8723       	dc.l	$83126E98
               S01:00E02EE2:  83 12 6E 98
F00:8724       	dc.w	115<<8				* 10**-4
               S01:00E02EE6:  73 00
F00:8725       	dc.l	$D1B71759
               S01:00E02EE8:  D1 B7 17 59
F00:8726       	dc.w	112<<8				* 10**-5
               S01:00E02EEC:  70 00
F00:8727       	dc.l	$A7C5AC47
               S01:00E02EEE:  A7 C5 AC 47
F00:8728       	dc.w	109<<8				* 10**-6
               S01:00E02EF2:  6D 00
F00:8729       	dc.l	$8637BD06
               S01:00E02EF4:  86 37 BD 06
F00:8730       	dc.w	105<<8				* 10**-7
               S01:00E02EF8:  69 00
F00:8731       	dc.l	$D6BF94D6
               S01:00E02EFA:  D6 BF 94 D6
F00:8732       	dc.w	102<<8				* 10**-8
               S01:00E02EFE:  66 00
F00:8733       	dc.l	$ABCC7712
               S01:00E02F00:  AB CC 77 12
F00:8734       	dc.w	99<<8					* 10**-9
               S01:00E02F04:  63 00
F00:8735       	dc.l	$89705F41
               S01:00E02F06:  89 70 5F 41
F00:8736       	dc.w	95<<8					* 10**-10
               S01:00E02F0A:  5F 00
F00:8737       	dc.l	$DBE6FECF
               S01:00E02F0C:  DB E6 FE CF
F00:8738       	dc.w	92<<8					* 10**-11
               S01:00E02F10:  5C 00
F00:8739       	dc.l	$AFEBFF0C
               S01:00E02F12:  AF EB FF 0C
F00:8740       	dc.w	89<<8					* 10**-12
               S01:00E02F16:  59 00
F00:8741       	dc.l	$8CBCCC09
               S01:00E02F18:  8C BC CC 09
F00:8742       	dc.w	85<<8					* 10**-13
               S01:00E02F1C:  55 00
F00:8743       	dc.l	$E12E1342
               S01:00E02F1E:  E1 2E 13 42
F00:8744       	dc.w	82<<8					* 10**-14
               S01:00E02F22:  52 00
F00:8745       	dc.l	$B424DC35
               S01:00E02F24:  B4 24 DC 35
F00:8746       	dc.w	79<<8					* 10**-15
               S01:00E02F28:  4F 00
F00:8747       	dc.l	$901D7CF7
               S01:00E02F2A:  90 1D 7C F7
F00:8748       	dc.w	75<<8					* 10**-16
               S01:00E02F2E:  4B 00
F00:8749       	dc.l	$E69594BF
               S01:00E02F30:  E6 95 94 BF
F00:8750       	dc.w	72<<8					* 10**-17
               S01:00E02F34:  48 00
F00:8751       	dc.l	$B877AA32
               S01:00E02F36:  B8 77 AA 32
F00:8752       	dc.w	69<<8					* 10**-18
               S01:00E02F3A:  45 00
F00:8753       	dc.l	$9392EE8F
               S01:00E02F3C:  93 92 EE 8F
F00:8754       	dc.w	65<<8					* 10**-19
               S01:00E02F40:  41 00
F00:8755       	dc.l	$EC1E4A7E
               S01:00E02F42:  EC 1E 4A 7E
F00:8756       	dc.w	62<<8					* 10**-20
               S01:00E02F46:  3E 00
F00:8757       	dc.l	$BCE50865
               S01:00E02F48:  BC E5 08 65
F00:8758       	dc.w	59<<8					* 10**-21
               S01:00E02F4C:  3B 00
F00:8759       	dc.l	$971DA050
               S01:00E02F4E:  97 1D A0 50
F00:8760       	dc.w	55<<8					* 10**-22
               S01:00E02F52:  37 00
F00:8761       	dc.l	$F1C90081
               S01:00E02F54:  F1 C9 00 81
F00:8762       	dc.w	52<<8					* 10**-23
               S01:00E02F58:  34 00
F00:8763       	dc.l	$C16D9A01
               S01:00E02F5A:  C1 6D 9A 01
F00:8764       	dc.w	49<<8					* 10**-24
               S01:00E02F5E:  31 00
F00:8765       	dc.l	$9ABE14CD
               S01:00E02F60:  9A BE 14 CD
F00:8766       	dc.w	45<<8					* 10**-25
               S01:00E02F64:  2D 00
F00:8767       	dc.l	$F79687AE
               S01:00E02F66:  F7 96 87 AE
F00:8768       	dc.w	42<<8					* 10**-26
               S01:00E02F6A:  2A 00
F00:8769       	dc.l	$C6120625
               S01:00E02F6C:  C6 12 06 25
F00:8770       	dc.w	39<<8					* 10**-27
               S01:00E02F70:  27 00
F00:8771       	dc.l	$9E74D1B8
               S01:00E02F72:  9E 74 D1 B8
F00:8772       	dc.w	35<<8					* 10**-28
               S01:00E02F76:  23 00
F00:8773       	dc.l	$FD87B5F3
               S01:00E02F78:  FD 87 B5 F3
F00:8774       	dc.w	32<<8					* 10**-29
               S01:00E02F7C:  20 00
F00:8775       	dc.l	$CAD2F7F5
               S01:00E02F7E:  CA D2 F7 F5
F00:8776       	dc.w	29<<8					* 10**-30
               S01:00E02F82:  1D 00
F00:8777       	dc.l	$A2425FF7
               S01:00E02F84:  A2 42 5F F7
F00:8778       	dc.w	26<<8					* 10**-31
               S01:00E02F88:  1A 00
F00:8779       	dc.l	$81CEB32C
               S01:00E02F8A:  81 CE B3 2C
F00:8780       	dc.w	22<<8					* 10**-32
               S01:00E02F8E:  16 00
F00:8781       	dc.l	$CFB11EAD
               S01:00E02F90:  CF B1 1E AD
F00:8782       	dc.w	19<<8					* 10**-33
               S01:00E02F94:  13 00
F00:8783       	dc.l	$A6274BBE
               S01:00E02F96:  A6 27 4B BE
F00:8784       	dc.w	16<<8					* 10**-34
               S01:00E02F9A:  10 00
F00:8785       	dc.l	$84EC3C98
               S01:00E02F9C:  84 EC 3C 98
F00:8786       	dc.w	12<<8					* 10**-35
               S01:00E02FA0:  0C 00
F00:8787       	dc.l	$D4AD2DC0
               S01:00E02FA2:  D4 AD 2D C0
F00:8788       	dc.w	9<<8					* 10**-36
               S01:00E02FA6:  09 00
F00:8789       	dc.l	$AA242499
               S01:00E02FA8:  AA 24 24 99
F00:8790       	dc.w	6<<8					* 10**-37
               S01:00E02FAC:  06 00
F00:8791       	dc.l	$881CEA14
               S01:00E02FAE:  88 1C EA 14
F00:8792       	dc.w	2<<8					* 10**-38
               S01:00E02FB2:  02 00
F00:8793       	dc.l	$D9C7DCED
               S01:00E02FB4:  D9 C7 DC ED
F00:8794       
F00:8795       
F00:8796       *************************************************************************************
F00:8797       *
F00:8798       * table of constants for cordic SIN/COS/TAN calculations
F00:8799       * constants are un normalised fractions and are atn(2^-i)/2pi
F00:8800       
F00:8801       	dc.l	$4DBA76D4				* SIN/COS multiply constant
               S01:00E02FB8:  4D BA 76 D4
F00:8802       TAB_SNCO
F00:8803       	dc.l	$20000000				* atn(2^0)/2pi
               S01:00E02FBC:  20 00 00 00
F00:8804       	dc.l	$12E4051E				* atn(2^1)/2pi
               S01:00E02FC0:  12 E4 05 1E
F00:8805       	dc.l	$09FB385C				* atn(2^2)/2pi
               S01:00E02FC4:  09 FB 38 5C
F00:8806       	dc.l	$051111D5				* atn(2^3)/2pi
               S01:00E02FC8:  05 11 11 D5
F00:8807       	dc.l	$028B0D44				* atn(2^4)/2pi
               S01:00E02FCC:  02 8B 0D 44
F00:8808       	dc.l	$0145D7E2				* atn(2^5)/2pi
               S01:00E02FD0:  01 45 D7 E2
F00:8809       	dc.l	$00A2F61F				* atn(2^6)/2pi
               S01:00E02FD4:  00 A2 F6 1F
F00:8810       	dc.l	$00517C56				* atn(2^7)/2pi
               S01:00E02FD8:  00 51 7C 56
F00:8811       	dc.l	$0028BE54				* atn(2^8)/2pi
               S01:00E02FDC:  00 28 BE 54
F00:8812       	dc.l	$00145F2F				* atn(2^9)/2pi
               S01:00E02FE0:  00 14 5F 2F
F00:8813       	dc.l	$000A2F99				* atn(2^10)/2pi
               S01:00E02FE4:  00 0A 2F 99
F00:8814       	dc.l	$000517CD				* atn(2^11)/2pi
               S01:00E02FE8:  00 05 17 CD
F00:8815       	dc.l	$00028BE7				* atn(2^12)/2pi
               S01:00E02FEC:  00 02 8B E7
F00:8816       	dc.l	$000145F4				* atn(2^13)/2pi
               S01:00E02FF0:  00 01 45 F4
F00:8817       	dc.l	$0000A2FA				* atn(2^14)/2pi
               S01:00E02FF4:  00 00 A2 FA
F00:8818       	dc.l	$0000517D				* atn(2^15)/2pi
               S01:00E02FF8:  00 00 51 7D
F00:8819       	dc.l	$000028BF				* atn(2^16)/2pi
               S01:00E02FFC:  00 00 28 BF
F00:8820       	dc.l	$00001460				* atn(2^17)/2pi
               S01:00E03000:  00 00 14 60
F00:8821       	dc.l	$00000A30				* atn(2^18)/2pi
               S01:00E03004:  00 00 0A 30
F00:8822       	dc.l	$00000518				* atn(2^19)/2pi
               S01:00E03008:  00 00 05 18
F00:8823       	dc.l	$0000028C				* atn(2^20)/2pi
               S01:00E0300C:  00 00 02 8C
F00:8824       	dc.l	$00000146				* atn(2^21)/2pi
               S01:00E03010:  00 00 01 46
F00:8825       	dc.l	$000000A3				* atn(2^22)/2pi
               S01:00E03014:  00 00 00 A3
F00:8826       	dc.l	$00000052				* atn(2^23)/2pi
               S01:00E03018:  00 00 00 52
F00:8827       	dc.l	$00000029				* atn(2^24)/2pi
               S01:00E0301C:  00 00 00 29
F00:8828       	dc.l	$00000015				* atn(2^25)/2pi
               S01:00E03020:  00 00 00 15
F00:8829       	dc.l	$0000000B				* atn(2^26)/2pi
               S01:00E03024:  00 00 00 0B
F00:8830       	dc.l	$00000006				* atn(2^27)/2pi
               S01:00E03028:  00 00 00 06
F00:8831       	dc.l	$00000003				* atn(2^28)/2pi
               S01:00E0302C:  00 00 00 03
F00:8832       	dc.l	$00000002				* atn(2^29)/2pi
               S01:00E03030:  00 00 00 02
F00:8833       	dc.l	$00000001				* atn(2^30)/2pi
               S01:00E03034:  00 00 00 01
F00:8834       	dc.l	$00000001				* atn(2^31)/2pi
               S01:00E03038:  00 00 00 01
F00:8835       
F00:8836       
F00:8837       *************************************************************************************
F00:8838       *
F00:8839       * table of constants for cordic ATN calculation
F00:8840       * constants are normalised to two integer bits and are atn(2^-i)
F00:8841       
F00:8842       TAB_ATNC
F00:8843       	dc.l	$1DAC6705				* atn(2^-1)
               S01:00E0303C:  1D AC 67 05
F00:8844       	dc.l	$0FADBAFD				* atn(2^-2)
               S01:00E03040:  0F AD BA FD
F00:8845       	dc.l	$07F56EA7				* atn(2^-3)
               S01:00E03044:  07 F5 6E A7
F00:8846       	dc.l	$03FEAB77				* atn(2^-4)
               S01:00E03048:  03 FE AB 77
F00:8847       	dc.l	$01FFD55C				* atn(2^-5)
               S01:00E0304C:  01 FF D5 5C
F00:8848       	dc.l	$00FFFAAB				* atn(2^-6)
               S01:00E03050:  00 FF FA AB
F00:8849       	dc.l	$007FFF55				* atn(2^-7)
               S01:00E03054:  00 7F FF 55
F00:8850       	dc.l	$003FFFEB				* atn(2^-8)
               S01:00E03058:  00 3F FF EB
F00:8851       	dc.l	$001FFFFD				* atn(2^-9)
               S01:00E0305C:  00 1F FF FD
F00:8852       	dc.l	$00100000				* atn(2^-10)
               S01:00E03060:  00 10 00 00
F00:8853       	dc.l	$00080000				* atn(2^-11)
               S01:00E03064:  00 08 00 00
F00:8854       	dc.l	$00040000				* atn(2^-12)
               S01:00E03068:  00 04 00 00
F00:8855       	dc.l	$00020000				* atn(2^-13)
               S01:00E0306C:  00 02 00 00
F00:8856       	dc.l	$00010000				* atn(2^-14)
               S01:00E03070:  00 01 00 00
F00:8857       	dc.l	$00008000				* atn(2^-15)
               S01:00E03074:  00 00 80 00
F00:8858       	dc.l	$00004000				* atn(2^-16)
               S01:00E03078:  00 00 40 00
F00:8859       	dc.l	$00002000				* atn(2^-17)
               S01:00E0307C:  00 00 20 00
F00:8860       	dc.l	$00001000				* atn(2^-18)
               S01:00E03080:  00 00 10 00
F00:8861       	dc.l	$00000800				* atn(2^-19)
               S01:00E03084:  00 00 08 00
F00:8862       	dc.l	$00000400				* atn(2^-20)
               S01:00E03088:  00 00 04 00
F00:8863       	dc.l	$00000200				* atn(2^-21)
               S01:00E0308C:  00 00 02 00
F00:8864       	dc.l	$00000100				* atn(2^-22)
               S01:00E03090:  00 00 01 00
F00:8865       	dc.l	$00000080				* atn(2^-23)
               S01:00E03094:  00 00 00 80
F00:8866       	dc.l	$00000040				* atn(2^-24)
               S01:00E03098:  00 00 00 40
F00:8867       	dc.l	$00000020				* atn(2^-25)
               S01:00E0309C:  00 00 00 20
F00:8868       	dc.l	$00000010				* atn(2^-26)
               S01:00E030A0:  00 00 00 10
F00:8869       	dc.l	$00000008				* atn(2^-27)
               S01:00E030A4:  00 00 00 08
F00:8870       	dc.l	$00000004				* atn(2^-28)
               S01:00E030A8:  00 00 00 04
F00:8871       	dc.l	$00000002				* atn(2^-29)
               S01:00E030AC:  00 00 00 02
F00:8872       	dc.l	$00000001				* atn(2^-30)
               S01:00E030B0:  00 00 00 01
F00:8873       LAB_1D96
F00:8874       	dc.l	$00000000				* atn(2^-31)
               S01:00E030B4:  00 00 00 00
F00:8875       	dc.l	$00000000				* atn(2^-32)
               S01:00E030B8:  00 00 00 00
F00:8876       
F00:8877       * constants are normalised to n integer bits and are tanh(2^-i)
F00:8878       n	equ	2
F00:8879       TAB_HTHET
F00:8880       	dc.l	$8C9F53D0>>n			* atnh(2^-1)	.549306144
               S01:00E030BC:  E3 27 D4 F4
F00:8881       	dc.l	$4162BBE8>>n			* atnh(2^-2)	.255412812
               S01:00E030C0:  10 58 AE FA
F00:8882       	dc.l	$202B1238>>n			* atnh(2^-3)
               S01:00E030C4:  08 0A C4 8E
F00:8883       	dc.l	$10055888>>n			* atnh(2^-4)
               S01:00E030C8:  04 01 56 22
F00:8884       	dc.l	$0800AAC0>>n			* atnh(2^-5)
               S01:00E030CC:  02 00 2A B0
F00:8885       	dc.l	$04001550>>n			* atnh(2^-6)
               S01:00E030D0:  01 00 05 54
F00:8886       	dc.l	$020002A8>>n			* atnh(2^-7)
               S01:00E030D4:  00 80 00 AA
F00:8887       	dc.l	$01000050>>n			* atnh(2^-8)
               S01:00E030D8:  00 40 00 14
F00:8888       	dc.l	$00800008>>n			* atnh(2^-9)
               S01:00E030DC:  00 20 00 02
F00:8889       	dc.l	$00400000>>n			* atnh(2^-10)
               S01:00E030E0:  00 10 00 00
F00:8890       	dc.l	$00200000>>n			* atnh(2^-11)
               S01:00E030E4:  00 08 00 00
F00:8891       	dc.l	$00100000>>n			* atnh(2^-12)
               S01:00E030E8:  00 04 00 00
F00:8892       	dc.l	$00080000>>n			* atnh(2^-13)
               S01:00E030EC:  00 02 00 00
F00:8893       	dc.l	$00040000>>n			* atnh(2^-14)
               S01:00E030F0:  00 01 00 00
F00:8894       	dc.l	$00020000>>n			* atnh(2^-15)
               S01:00E030F4:  00 00 80 00
F00:8895       	dc.l	$00010000>>n			* atnh(2^-16)
               S01:00E030F8:  00 00 40 00
F00:8896       	dc.l	$00008000>>n			* atnh(2^-17)
               S01:00E030FC:  00 00 20 00
F00:8897       	dc.l	$00004000>>n			* atnh(2^-18)
               S01:00E03100:  00 00 10 00
F00:8898       	dc.l	$00002000>>n			* atnh(2^-19)
               S01:00E03104:  00 00 08 00
F00:8899       	dc.l	$00001000>>n			* atnh(2^-20)
               S01:00E03108:  00 00 04 00
F00:8900       	dc.l	$00000800>>n			* atnh(2^-21)
               S01:00E0310C:  00 00 02 00
F00:8901       	dc.l	$00000400>>n			* atnh(2^-22)
               S01:00E03110:  00 00 01 00
F00:8902       	dc.l	$00000200>>n			* atnh(2^-23)
               S01:00E03114:  00 00 00 80
F00:8903       	dc.l	$00000100>>n			* atnh(2^-24)
               S01:00E03118:  00 00 00 40
F00:8904       	dc.l	$00000080>>n			* atnh(2^-25)
               S01:00E0311C:  00 00 00 20
F00:8905       	dc.l	$00000040>>n			* atnh(2^-26)
               S01:00E03120:  00 00 00 10
F00:8906       	dc.l	$00000020>>n			* atnh(2^-27)
               S01:00E03124:  00 00 00 08
F00:8907       	dc.l	$00000010>>n			* atnh(2^-28)
               S01:00E03128:  00 00 00 04
F00:8908       	dc.l	$00000008>>n			* atnh(2^-29)
               S01:00E0312C:  00 00 00 02
F00:8909       	dc.l	$00000004>>n			* atnh(2^-30)
               S01:00E03130:  00 00 00 01
F00:8910       	dc.l	$00000002>>n			* atnh(2^-31)
               S01:00E03134:  00 00 00 00
F00:8911       	dc.l	$00000001>>n			* atnh(2^-32)
               S01:00E03138:  00 00 00 00
F00:8912       
F00:8913       KFCTSEED	equ	$9A8F4441>>n		* $26A3D110
F00:8914       
F00:8915       
F00:8916       *************************************************************************************
F00:8917       *
F00:8918       * command vector table
F00:8919       
F00:8920       LAB_CTBL
F00:8921       	dc.w	LAB_END-LAB_CTBL			* END
               S01:00E0313C:  D5 AC
F00:8922       	dc.w	LAB_FOR-LAB_CTBL			* FOR
               S01:00E0313E:  D4 E0
F00:8923       	dc.w	LAB_NEXT-LAB_CTBL			* NEXT
               S01:00E03140:  DB 4C
F00:8924       	dc.w	LAB_DATA-LAB_CTBL			* DATA
               S01:00E03142:  D7 00
F00:8925       	dc.w	LAB_INPUT-LAB_CTBL		* INPUT
               S01:00E03144:  DA 40
F00:8926       	dc.w	LAB_DIM-LAB_CTBL			* DIM
               S01:00E03146:  DF 22
F00:8927       	dc.w	LAB_READ-LAB_CTBL			* READ
               S01:00E03148:  DA 66
F00:8928       	dc.w	LAB_LET-LAB_CTBL			* LET
               S01:00E0314A:  D8 72
F00:8929       	dc.w	LAB_DEC-LAB_CTBL			* DEC	
               S01:00E0314C:  D8 10
F00:8930       	dc.w	LAB_GOTO-LAB_CTBL			* GOTO
               S01:00E0314E:  D6 68
F00:8931       	dc.w	LAB_RUN-LAB_CTBL			* RUN
               S01:00E03150:  D6 30
F00:8932       	dc.w	LAB_IF-LAB_CTBL			* IF
               S01:00E03152:  D7 28
F00:8933       	dc.w	LAB_RESTORE-LAB_CTBL		* RESTORE
               S01:00E03154:  D5 DA
F00:8934       	dc.w	LAB_GOSUB-LAB_CTBL		* GOSUB
               S01:00E03156:  D6 56
F00:8935       	dc.w	LAB_RETURN-LAB_CTBL		* RETURN
               S01:00E03158:  D6 EC
F00:8936       	dc.w	LAB_REM-LAB_CTBL			* REM
               S01:00E0315A:  D7 96
F00:8937       	dc.w	LAB_STOP-LAB_CTBL			* STOP
               S01:00E0315C:  D5 B4
F00:8938       	dc.w	LAB_ON-LAB_CTBL			* ON
               S01:00E0315E:  D7 9E
F00:8939       	dc.w	LAB_NULL-LAB_CTBL			* NULL
               S01:00E03160:  D6 08
F00:8940       	dc.w	LAB_INC-LAB_CTBL			* INC	
               S01:00E03162:  D8 16
F00:8941       	dc.w	LAB_WAIT-LAB_CTBL			* WAIT
               S01:00E03164:  E8 20
F00:8942       	dc.w	LAB_LOAD-LAB_CTBL			* LOAD
               S01:00E03166:  E8 0E
F00:8943       	dc.w	LAB_SAVE-LAB_CTBL			* SAVE
               S01:00E03168:  E8 12
F00:8944       	dc.w	LAB_DEF-LAB_CTBL			* DEF
               S01:00E0316A:  E2 B2
F00:8945       	dc.w	LAB_POKE-LAB_CTBL			* POKE
               S01:00E0316C:  E7 8E
F00:8946       	dc.w	LAB_DOKE-LAB_CTBL			* DOKE
               S01:00E0316E:  E7 BE
F00:8947       	dc.w	LAB_LOKE-LAB_CTBL			* LOKE
               S01:00E03170:  E7 C4
F00:8948       	dc.w	LAB_CALL-LAB_CTBL			* CALL
               S01:00E03172:  E8 16
F00:8949       	dc.w	LAB_DO-LAB_CTBL			* DO	
               S01:00E03174:  D6 44
F00:8950       	dc.w	LAB_LOOP-LAB_CTBL			* LOOP
               S01:00E03176:  D6 96
F00:8951       	dc.w	LAB_PRINT-LAB_CTBL		* PRINT
               S01:00E03178:  D9 06
F00:8952       	dc.w	LAB_CONT-LAB_CTBL			* CONT
               S01:00E0317A:  D6 12
F00:8953       
F00:8954       	dc.w	LAB_BUFFER-LAB_CTBL		* BUFFER
               S01:00E0317C:  EA 3C
F00:8955       	dc.w	LAB_CLS-LAB_CTBL			* CLS
               S01:00E0317E:  EA 46
F00:8956       	dc.w	LAB_CURSOR-LAB_CTBL		* CURSOR
               S01:00E03180:  E9 F8
F00:8957       	dc.w	LAB_LINE-LAB_CTBL			* LINE
               S01:00E03182:  E9 12
F00:8958       	dc.w	LAB_FILL-LAB_CTBL			* FILL
               S01:00E03184:  E9 48
F00:8959       	dc.w	LAB_MOVE-LAB_CTBL			* MOVE
               S01:00E03186:  E9 3C
F00:8960       	dc.w	LAB_POINT-LAB_CTBL		* POINT
               S01:00E03188:  E9 44
F00:8961       	dc.w	LAB_RECT-LAB_CTBL			* RECT
               S01:00E0318A:  E9 78
F00:8962       	dc.w	LAB_FRECT-LAB_CTBL		* FRECT
               S01:00E0318C:  E9 7C
F00:8963       	dc.w	LAB_ELLIPSE-LAB_CTBL		* ELLIPSE
               S01:00E0318E:  E9 80
F00:8964       	dc.w	LAB_FELLIPSE-LAB_CTBL		* FELLIPSE
               S01:00E03190:  E9 84
F00:8965       	dc.w	LAB_MODE-LAB_CTBL			* MODE
               S01:00E03192:  E9 D8
F00:8966       	dc.w	LAB_SIZE-LAB_CTBL			* SIZE
               S01:00E03194:  E9 EC
F00:8967       
F00:8968       	dc.w	LAB_LIST-LAB_CTBL			* LIST
               S01:00E03196:  D4 2C
F00:8969       	dc.w	LAB_CLEAR-LAB_CTBL		* CLEAR
               S01:00E03198:  D4 28
F00:8970       	dc.w	LAB_NEW-LAB_CTBL			* NEW
               S01:00E0319A:  D3 D8
F00:8971       	dc.w	LAB_WDTH-LAB_CTBL			* WIDTH
               S01:00E0319C:  F9 54
F00:8972       	dc.w	LAB_GET-LAB_CTBL			* GET
               S01:00E0319E:  D8 CC
F00:8973       	dc.w	LAB_SWAP-LAB_CTBL			* SWAP
               S01:00E031A0:  E7 D8
F00:8974       	dc.w	LAB_BITSET-LAB_CTBL		* BITSET
               S01:00E031A2:  F4 A2
F00:8975       	dc.w	LAB_BITCLR-LAB_CTBL		* BITCLR
               S01:00E031A4:  F4 B2
F00:8976       
F00:8977       
F00:8978       *************************************************************************************
F00:8979       *
F00:8980       * function pre process routine table
F00:8981       
F00:8982       LAB_FTPP
F00:8983       	dc.w	LAB_PPFN-LAB_FTPP			* SGN(n)	process numeric expression in ()
               S01:00E031A6:  DD B6
F00:8984       	dc.w	LAB_PPFN-LAB_FTPP			* INT(n)		"
               S01:00E031A8:  DD B6
F00:8985       	dc.w	LAB_PPFN-LAB_FTPP			* ABS(n)		"
               S01:00E031AA:  DD B6
F00:8986       	dc.w	LAB_EVEZ-LAB_FTPP			* USR(x)	process any expression
               S01:00E031AC:  DB B2
F00:8987       	dc.w	LAB_1BF7-LAB_FTPP			* FRE(x)	process any expression in ()
               S01:00E031AE:  DC FA
F00:8988       	dc.w	LAB_1BF7-LAB_FTPP			* POS(x)		"
               S01:00E031B0:  DC FA
F00:8989       	dc.w	LAB_PPFN-LAB_FTPP			* SQR(n)	process numeric expression in ()
               S01:00E031B2:  DD B6
F00:8990       	dc.w	LAB_PPFN-LAB_FTPP			* RND(n)		"
               S01:00E031B4:  DD B6
F00:8991       	dc.w	LAB_PPFN-LAB_FTPP			* LOG(n)		"
               S01:00E031B6:  DD B6
F00:8992       	dc.w	LAB_PPFN-LAB_FTPP			* EXP(n)		"
               S01:00E031B8:  DD B6
F00:8993       	dc.w	LAB_PPFN-LAB_FTPP			* COS(n)		"
               S01:00E031BA:  DD B6
F00:8994       	dc.w	LAB_PPFN-LAB_FTPP			* SIN(n)		"
               S01:00E031BC:  DD B6
F00:8995       	dc.w	LAB_PPFN-LAB_FTPP			* TAN(n)		"
               S01:00E031BE:  DD B6
F00:8996       	dc.w	LAB_PPFN-LAB_FTPP			* ATN(n)		"
               S01:00E031C0:  DD B6
F00:8997       	dc.w	LAB_PPFN-LAB_FTPP			* PEEK(n)		"
               S01:00E031C2:  DD B6
F00:8998       	dc.w	LAB_PPFN-LAB_FTPP			* DEEK(n)		"
               S01:00E031C4:  DD B6
F00:8999       	dc.w	LAB_PPFN-LAB_FTPP			* LEEK(n)		"
               S01:00E031C6:  DD B6
F00:9000       	dc.w	LAB_PPFS-LAB_FTPP			* LEN($)	process string expression in ()
               S01:00E031C8:  DD A8
F00:9001       	dc.w	LAB_PPFN-LAB_FTPP			* STR$(n)	process numeric expression in ()
               S01:00E031CA:  DD B6
F00:9002       	dc.w	LAB_PPFS-LAB_FTPP			* VAL($)	process string expression in ()
               S01:00E031CC:  DD A8
F00:9003       	dc.w	LAB_PPFS-LAB_FTPP			* ASC($)		"
               S01:00E031CE:  DD A8
F00:9004       	dc.w	LAB_PPFS-LAB_FTPP			* UCASE$($)		"
               S01:00E031D0:  DD A8
F00:9005       	dc.w	LAB_PPFS-LAB_FTPP			* LCASE$($)		"
               S01:00E031D2:  DD A8
F00:9006       	dc.w	LAB_PPFN-LAB_FTPP			* CHR$(n)	process numeric expression in ()
               S01:00E031D4:  DD B6
F00:9007       	dc.w	LAB_BHSS-LAB_FTPP			* HEX$()	bin/hex pre process
               S01:00E031D6:  DD F0
F00:9008       	dc.w	LAB_BHSS-LAB_FTPP			* BIN$()		"
               S01:00E031D8:  DD F0
F00:9009       	dc.w	$0000					* BITTST()	none
               S01:00E031DA:  00 00
F00:9010       	dc.w	$0000					* MAX()		"
               S01:00E031DC:  00 00
F00:9011       	dc.w	$0000					* MIN()		"
               S01:00E031DE:  00 00
F00:9012       	dc.w	LAB_PPBI-LAB_FTPP			* RAMBASE	advance pointer
               S01:00E031E0:  DD C4
F00:9013       	dc.w	LAB_1BF7-LAB_FTPP			* KEYS(x)	process any expression in ()
               S01:00E031E2:  DC FA
F00:9014       	dc.w	LAB_PPBI-LAB_FTPP			* TI		advance pointer
               S01:00E031E4:  DD C4
F00:9015       	dc.w	LAB_PPBI-LAB_FTPP			* PI			"
               S01:00E031E6:  DD C4
F00:9016       	dc.w	LAB_PPBI-LAB_FTPP			* TWOPI		"
               S01:00E031E8:  DD C4
F00:9017       	dc.w	$0000					* VARPTR()	none
               S01:00E031EA:  00 00
F00:9018       	dc.w	$0000					* SADD()		"
               S01:00E031EC:  00 00
F00:9019       	dc.w	LAB_LRMS-LAB_FTPP			* LEFT$()	process string expression
               S01:00E031EE:  DD CE
F00:9020       	dc.w	LAB_LRMS-LAB_FTPP			* RIGHT$()		"
               S01:00E031F0:  DD CE
F00:9021       	dc.w	LAB_LRMS-LAB_FTPP			* MID$()		"
               S01:00E031F2:  DD CE
F00:9022       	dc.w	LAB_EVEZ-LAB_FTPP			* USING$(x)	process any expression
               S01:00E031F4:  DB B2
F00:9023       
F00:9024       
F00:9025       *************************************************************************************
F00:9026       *
F00:9027       * action addresses for functions
F00:9028       
F00:9029       LAB_FTBL
F00:9030       	dc.w	LAB_SGN-LAB_FTBL			* SGN()
               S01:00E031F6:  ED 40
F00:9031       	dc.w	LAB_INT-LAB_FTBL			* INT()
               S01:00E031F8:  ED C2
F00:9032       	dc.w	LAB_ABS-LAB_FTBL			* ABS()
               S01:00E031FA:  ED 52
F00:9033       	dc.w	LAB_USR-LAB_FTBL			* USR()
               S01:00E031FC:  E7 4C
F00:9034       	dc.w	LAB_FRE-LAB_FTBL			* FRE()
               S01:00E031FE:  E1 B0
F00:9035       	dc.w	LAB_POS-LAB_FTBL			* POS()
               S01:00E03200:  E1 E2
F00:9036       	dc.w	LAB_SQR-LAB_FTBL			* SQR()
               S01:00E03202:  F9 1A
F00:9037       	dc.w	LAB_RND-LAB_FTBL			* RND()
               S01:00E03204:  F2 0A
F00:9038       	dc.w	LAB_LOG-LAB_FTBL			* LOG()
               S01:00E03206:  EA 62
F00:9039       	dc.w	LAB_EXP-LAB_FTBL			* EXP()
               S01:00E03208:  F0 F0
F00:9040       	dc.w	LAB_COS-LAB_FTBL			* COS()
               S01:00E0320A:  F2 5E
F00:9041       	dc.w	LAB_SIN-LAB_FTBL			* SIN()
               S01:00E0320C:  F2 76
F00:9042       	dc.w	LAB_TAN-LAB_FTBL			* TAN()
               S01:00E0320E:  F2 3C
F00:9043       	dc.w	LAB_ATN-LAB_FTBL			* ATN()
               S01:00E03210:  F3 36
F00:9044       	dc.w	LAB_PEEK-LAB_FTBL			* PEEK()
               S01:00E03212:  E6 C8
F00:9045       	dc.w	LAB_DEEK-LAB_FTBL			* DEEK()
               S01:00E03214:  E6 DA
F00:9046       	dc.w	LAB_LEEK-LAB_FTBL			* LEEK()
               S01:00E03216:  E6 F0
F00:9047       	dc.w	LAB_LENS-LAB_FTBL			* LEN()
               S01:00E03218:  E6 0C
F00:9048       	dc.w	LAB_STRS-LAB_FTBL			* STR$()
               S01:00E0321A:  E2 D8
F00:9049       	dc.w	LAB_VAL-LAB_FTBL			* VAL()
               S01:00E0321C:  E6 50
F00:9050       	dc.w	LAB_ASC-LAB_FTBL			* ASC()
               S01:00E0321E:  E6 14
F00:9051       	dc.w	LAB_UCASE-LAB_FTBL		* UCASE$()
               S01:00E03220:  E5 C2
F00:9052       	dc.w	LAB_LCASE-LAB_FTBL		* LCASE$()
               S01:00E03222:  E5 92
F00:9053       	dc.w	LAB_CHRS-LAB_FTBL			* CHR$()
               S01:00E03224:  E4 FA
F00:9054       	dc.w	LAB_HEXS-LAB_FTBL			* HEX$()
               S01:00E03226:  F7 BE
F00:9055       	dc.w	LAB_BINS-LAB_FTBL			* BIN$()
               S01:00E03228:  F7 6C
F00:9056       	dc.w	LAB_BTST-LAB_FTBL			* BITTST()
               S01:00E0322A:  F4 08
F00:9057       	dc.w	LAB_MAX-LAB_FTBL			* MAX()
               S01:00E0322C:  F8 2A
F00:9058       	dc.w	LAB_MIN-LAB_FTBL			* MIN()
               S01:00E0322E:  F8 40
F00:9059       	dc.w	LAB_RAM-LAB_FTBL			* RAMBASE
               S01:00E03230:  F9 8C
F00:9060       	dc.w	LAB_KEYS-LAB_FTBL			* KEYS()
               S01:00E03232:  E7 98
F00:9061       	dc.w	LAB_TI-LAB_FTBL			* TI
               S01:00E03234:  E7 8A
F00:9062       	dc.w	LAB_PI-LAB_FTBL			* PI
               S01:00E03236:  F9 96
F00:9063       	dc.w	LAB_TWOPI-LAB_FTBL		* TWOPI
               S01:00E03238:  F9 A6
F00:9064       	dc.w	LAB_VARPTR-LAB_FTBL		* VARPTR()
               S01:00E0323A:  F9 7C
F00:9065       	dc.w	LAB_SADD-LAB_FTBL			* SADD()
               S01:00E0323C:  E5 F4
F00:9066       	dc.w	LAB_LEFT-LAB_FTBL			* LEFT$()
               S01:00E0323E:  E5 0A
F00:9067       	dc.w	LAB_RIGHT-LAB_FTBL		* RIGHT$()
               S01:00E03240:  E5 1E
F00:9068       	dc.w	LAB_MIDS-LAB_FTBL			* MID$()
               S01:00E03242:  E5 4E
F00:9069       	dc.w	LAB_USINGS-LAB_FTBL		* USING$()
               S01:00E03244:  F4 36
F00:9070       
F00:9071       
F00:9072       *************************************************************************************
F00:9073       *
F00:9074       * hierarchy and action addresses for operator
F00:9075       
F00:9076       LAB_OPPT
F00:9077       	dc.w	$0079					* +
               S01:00E03246:  00 79
F00:9078       	dc.w	LAB_ADD-LAB_OPPT
               S01:00E03248:  E9 62
F00:9079       	dc.w	$0079					* -
               S01:00E0324A:  00 79
F00:9080       	dc.w	LAB_SUBTRACT-LAB_OPPT
               S01:00E0324C:  E9 4E
F00:9081       	dc.w	$007B					* *
               S01:00E0324E:  00 7B
F00:9082       	dc.w	LAB_MULTIPLY-LAB_OPPT
               S01:00E03250:  EB 04
F00:9083       	dc.w	$007B					* /
               S01:00E03252:  00 7B
F00:9084       	dc.w	LAB_DIVIDE-LAB_OPPT
               S01:00E03254:  EB 90
F00:9085       	dc.w	$007F					* ^
               S01:00E03256:  00 7F
F00:9086       	dc.w	LAB_POWER-LAB_OPPT
               S01:00E03258:  EF EA
F00:9087       	dc.w	$0050					* AND
               S01:00E0325A:  00 50
F00:9088       	dc.w	LAB_AND-LAB_OPPT
               S01:00E0325C:  DD 90
F00:9089       	dc.w	$0046					* EOR
               S01:00E0325E:  00 46
F00:9090       	dc.w	LAB_EOR-LAB_OPPT
               S01:00E03260:  DD 80
F00:9091       	dc.w	$0046					* OR
               S01:00E03262:  00 46
F00:9092       	dc.w	LAB_OR-LAB_OPPT
               S01:00E03264:  DD 88
F00:9093       	dc.w	$0056					* >>
               S01:00E03266:  00 56
F00:9094       	dc.w	LAB_RSHIFT-LAB_OPPT
               S01:00E03268:  DE 34
F00:9095       	dc.w	$0056					* <<
               S01:00E0326A:  00 56
F00:9096       	dc.w	LAB_LSHIFT-LAB_OPPT
               S01:00E0326C:  DE 24
F00:9097       	dc.w	$007D					* >
               S01:00E0326E:  00 7D
F00:9098       	dc.w	LAB_GTHAN-LAB_OPPT		* used to evaluate -n
               S01:00E03270:  F0 4E
F00:9099       	dc.w	$005A					* =
               S01:00E03272:  00 5A
F00:9100       	dc.w	LAB_EQUAL-LAB_OPPT		* used to evaluate NOT
               S01:00E03274:  DD A6
F00:9101       	dc.w	$0064					* <
               S01:00E03276:  00 64
F00:9102       	dc.w	LAB_LTHAN-LAB_OPPT
               S01:00E03278:  DD B0
F00:9103       
F00:9104       
F00:9105       *************************************************************************************
F00:9106       *
F00:9107       * misc constants
F00:9108       
F00:9109       * This table is used in converting numbers to ASCII.
F00:9110       
F00:9111       LAB_2A9A
F00:9112       	dc.l	$FFF0BDC0				* -1000000
               S01:00E0327A:  FF F0 BD C0
F00:9113       	dc.l	$000186A0				* 100000
               S01:00E0327E:  00 01 86 A0
F00:9114       	dc.l	$FFFFD8F0				* -10000
               S01:00E03282:  FF FF D8 F0
F00:9115       	dc.l	$000003E8				* 1000
               S01:00E03286:  00 00 03 E8
F00:9116       	dc.l	$FFFFFF9C				* -100
               S01:00E0328A:  FF FF FF 9C
F00:9117       	dc.l	$0000000A				* 10
               S01:00E0328E:  00 00 00 0A
F00:9118       	dc.l	$FFFFFFFF				* -1
               S01:00E03292:  FF FF FF FF
F00:9119       LAB_2A9B
F00:9120       
F00:9121       
F00:9122       *************************************************************************************
F00:9123       *
F00:9124       * new keyword tables
F00:9125       
F00:9126       * offsets to keyword tables
F00:9127       
F00:9128       TAB_CHRT
F00:9129       	dc.w	TAB_STAR-TAB_STAR			* "*"	$2A
               S01:00E03296:  00 00
F00:9130       	dc.w	TAB_PLUS-TAB_STAR			* "+"	$2B
               S01:00E03298:  00 02
F00:9131       	dc.w	-1					* "," $2C no keywords
               S01:00E0329A:  FF FF
F00:9132       	dc.w	TAB_MNUS-TAB_STAR			* "-"	$2D
               S01:00E0329C:  00 04
F00:9133       	dc.w	-1					* "." $2E no keywords
               S01:00E0329E:  FF FF
F00:9134       	dc.w	TAB_SLAS-TAB_STAR			* "/"	$2F
               S01:00E032A0:  00 06
F00:9135       	dc.w	-1					* "0" $30 no keywords
               S01:00E032A2:  FF FF
F00:9136       	dc.w	-1					* "1" $31 no keywords
               S01:00E032A4:  FF FF
F00:9137       	dc.w	-1					* "2" $32 no keywords
               S01:00E032A6:  FF FF
F00:9138       	dc.w	-1					* "3" $33 no keywords
               S01:00E032A8:  FF FF
F00:9139       	dc.w	-1					* "4" $34 no keywords
               S01:00E032AA:  FF FF
F00:9140       	dc.w	-1					* "5" $35 no keywords
               S01:00E032AC:  FF FF
F00:9141       	dc.w	-1					* "6" $36 no keywords
               S01:00E032AE:  FF FF
F00:9142       	dc.w	-1					* "7" $37 no keywords
               S01:00E032B0:  FF FF
F00:9143       	dc.w	-1					* "8" $38 no keywords
               S01:00E032B2:  FF FF
F00:9144       	dc.w	-1					* "9" $39 no keywords
               S01:00E032B4:  FF FF
F00:9145       	dc.w	-1					* ";" $3A no keywords
               S01:00E032B6:  FF FF
F00:9146       	dc.w	-1					* ":" $3B no keywords
               S01:00E032B8:  FF FF
F00:9147       	dc.w	TAB_LESS-TAB_STAR			* "<"	$3C
               S01:00E032BA:  00 08
F00:9148       	dc.w	TAB_EQUL-TAB_STAR			* "="	$3D
               S01:00E032BC:  00 0C
F00:9149       	dc.w	TAB_MORE-TAB_STAR			* ">"	$3E
               S01:00E032BE:  00 0E
F00:9150       	dc.w	TAB_QEST-TAB_STAR			* "?"	$3F
               S01:00E032C0:  00 12
F00:9151       	dc.w	-1					* "@" $40 no keywords
               S01:00E032C2:  FF FF
F00:9152       	dc.w	TAB_ASCA-TAB_STAR			* "A"	$41
               S01:00E032C4:  00 14
F00:9153       	dc.w	TAB_ASCB-TAB_STAR			* "B"	$42
               S01:00E032C6:  00 24
F00:9154       	dc.w	TAB_ASCC-TAB_STAR			* "C"	$43
               S01:00E032C8:  00 43
F00:9155       	dc.w	TAB_ASCD-TAB_STAR			* "D"	$44
               S01:00E032CA:  00 63
F00:9156       	dc.w	TAB_ASCE-TAB_STAR			* "E"	$45
               S01:00E032CC:  00 7C
F00:9157       	dc.w	TAB_ASCF-TAB_STAR			* "F"	$46
               S01:00E032CE:  00 9A
F00:9158       	dc.w	TAB_ASCG-TAB_STAR			* "G"	$47
               S01:00E032D0:  00 A8
F00:9159       	dc.w	TAB_ASCH-TAB_STAR			* "H"	$48
               S01:00E032D2:  00 B5
F00:9160       	dc.w	TAB_ASCI-TAB_STAR			* "I"	$49
               S01:00E032D4:  00 BB
F00:9161       	dc.w	-1					* "J" $4A no keywords
               S01:00E032D6:  FF FF
F00:9162       	dc.w	TAB_ASCK-TAB_STAR			* "K" $4B
               S01:00E032D8:  00 CA
F00:9163       	dc.w	TAB_ASCL-TAB_STAR			* "L"	$4C
               S01:00E032DA:  00 D0
F00:9164       	dc.w	TAB_ASCM-TAB_STAR			* "M"	$4D
               S01:00E032DC:  01 02
F00:9165       	dc.w	TAB_ASCN-TAB_STAR			* "N"	$4E
               S01:00E032DE:  01 18
F00:9166       	dc.w	TAB_ASCO-TAB_STAR			* "O"	$4F
               S01:00E032E0:  01 27
F00:9167       	dc.w	TAB_ASCP-TAB_STAR			* "P"	$50
               S01:00E032E2:  01 2C
F00:9168       	dc.w	-1					* "Q" $51 no keywords
               S01:00E032E4:  FF FF
F00:9169       	dc.w	TAB_ASCR-TAB_STAR			* "R"	$52
               S01:00E032E6:  01 46
F00:9170       	dc.w	TAB_ASCS-TAB_STAR			* "S"	$53
               S01:00E032E8:  01 79
F00:9171       	dc.w	TAB_ASCT-TAB_STAR			* "T"	$54
               S01:00E032EA:  01 A8
F00:9172       	dc.w	TAB_ASCU-TAB_STAR			* "U"	$55
               S01:00E032EC:  01 BE
F00:9173       	dc.w	TAB_ASCV-TAB_STAR			* "V"	$56
               S01:00E032EE:  01 D6
F00:9174       	dc.w	TAB_ASCW-TAB_STAR			* "W"	$57
               S01:00E032F0:  01 E2
F00:9175       	dc.w	-1					* "X" $58 no keywords
               S01:00E032F2:  FF FF
F00:9176       	dc.w	-1					* "Y" $59 no keywords
               S01:00E032F4:  FF FF
F00:9177       	dc.w	-1					* "Z" $5A no keywords
               S01:00E032F6:  FF FF
F00:9178       	dc.w	-1					* "[" $5B no keywords
               S01:00E032F8:  FF FF
F00:9179       	dc.w	-1					* "\" $5C no keywords
               S01:00E032FA:  FF FF
F00:9180       	dc.w	-1					* "]" $5D no keywords
               S01:00E032FC:  FF FF
F00:9181       	dc.w	TAB_POWR-TAB_STAR			* "^"	$5E
               S01:00E032FE:  01 F1
F00:9182       
F00:9183       
F00:9184       *************************************************************************************
F00:9185       *
F00:9186       * Table of Basic keywords for LIST command
F00:9187       * [byte]first character,[byte]remaining length -1
F00:9188       * [word]offset from table start
F00:9189       
F00:9190       LAB_KEYT
F00:9191       	dc.b	'E',1
               S01:00E03300:  45
               S01:00E03301:  01
F00:9192       	dc.w	KEY_END-TAB_STAR			* END
               S01:00E03302:  00 80
F00:9193       	dc.b	'F',1
               S01:00E03304:  46
               S01:00E03305:  01
F00:9194       	dc.w	KEY_FOR-TAB_STAR			* FOR
               S01:00E03306:  00 9E
F00:9195       	dc.b	'N',2
               S01:00E03308:  4E
               S01:00E03309:  02
F00:9196       	dc.w	KEY_NEXT-TAB_STAR			* NEXT
               S01:00E0330A:  01 1B
F00:9197       	dc.b	'D',2
               S01:00E0330C:  44
               S01:00E0330D:  02
F00:9198       	dc.w	KEY_DATA-TAB_STAR			* DATA
               S01:00E0330E:  00 63
F00:9199       	dc.b	'I',3
               S01:00E03310:  49
               S01:00E03311:  03
F00:9200       	dc.w	KEY_INPUT-TAB_STAR		* INPUT
               S01:00E03312:  00 C0
F00:9201       	dc.b	'D',1
               S01:00E03314:  44
               S01:00E03315:  01
F00:9202       	dc.w	KEY_DIM-TAB_STAR			* DIM
               S01:00E03316:  00 72
F00:9203       	dc.b	'R',2
               S01:00E03318:  52
               S01:00E03319:  02
F00:9204       	dc.w	KEY_READ-TAB_STAR			* READ
               S01:00E0331A:  01 4D
F00:9205       	dc.b	'L',1
               S01:00E0331C:  4C
               S01:00E0331D:  01
F00:9206       	dc.w	KEY_LET-TAB_STAR			* LET
               S01:00E0331E:  00 E6
F00:9207       	dc.b	'D',1
               S01:00E03320:  44
               S01:00E03321:  01
F00:9208       	dc.w	KEY_DEC-TAB_STAR			* DEC
               S01:00E03322:  00 67
F00:9209       	dc.b	'G',2
               S01:00E03324:  47
               S01:00E03325:  02
F00:9210       	dc.w	KEY_GOTO-TAB_STAR			* GOTO
               S01:00E03326:  00 AB
F00:9211       	dc.b	'R',1
               S01:00E03328:  52
               S01:00E03329:  01
F00:9212       	dc.w	KEY_RUN-TAB_STAR			* RUN
               S01:00E0332A:  01 75
F00:9213       	dc.b	'I',0
               S01:00E0332C:  49
               S01:00E0332D:  00
F00:9214       	dc.w	KEY_IF-TAB_STAR			* IF
               S01:00E0332E:  00 BB
F00:9215       	dc.b	'R',5
               S01:00E03330:  52
               S01:00E03331:  05
F00:9216       	dc.w	KEY_RESTORE-TAB_STAR		* RESTORE
               S01:00E03332:  01 5D
F00:9217       	dc.b	'G',3
               S01:00E03334:  47
               S01:00E03335:  03
F00:9218       	dc.w	KEY_GOSUB-TAB_STAR		* GOSUB
               S01:00E03336:  00 AF
F00:9219       	dc.b	'R',4
               S01:00E03338:  52
               S01:00E03339:  04
F00:9220       	dc.w	KEY_RETURN-TAB_STAR		* RETURN
               S01:00E0333A:  01 64
F00:9221       	dc.b	'R',1
               S01:00E0333C:  52
               S01:00E0333D:  01
F00:9222       	dc.w	KEY_REM-TAB_STAR			* REM
               S01:00E0333E:  01 5A
F00:9223       	dc.b	'S',2
               S01:00E03340:  53
               S01:00E03341:  02
F00:9224       	dc.w	KEY_STOP-TAB_STAR			* STOP
               S01:00E03342:  01 9A
F00:9225       	dc.b	'O',0
               S01:00E03344:  4F
               S01:00E03345:  00
F00:9226       	dc.w	KEY_ON-TAB_STAR			* ON
               S01:00E03346:  01 27
F00:9227       	dc.b	'N',2
               S01:00E03348:  4E
               S01:00E03349:  02
F00:9228       	dc.w	KEY_NULL-TAB_STAR			* NULL
               S01:00E0334A:  01 22
F00:9229       	dc.b	'I',1
               S01:00E0334C:  49
               S01:00E0334D:  01
F00:9230       	dc.w	KEY_INC-TAB_STAR			* INC
               S01:00E0334E:  00 BD
F00:9231       	dc.b	'W',2
               S01:00E03350:  57
               S01:00E03351:  02
F00:9232       	dc.w	KEY_WAIT-TAB_STAR			* WAIT
               S01:00E03352:  01 E2
F00:9233       	dc.b	'L',2
               S01:00E03354:  4C
               S01:00E03355:  02
F00:9234       	dc.w	KEY_LOAD-TAB_STAR			* LOAD
               S01:00E03356:  00 F1
F00:9235       	dc.b	'S',2
               S01:00E03358:  53
               S01:00E03359:  02
F00:9236       	dc.w	KEY_SAVE-TAB_STAR			* SAVE
               S01:00E0335A:  01 7E
F00:9237       	dc.b	'D',1
               S01:00E0335C:  44
               S01:00E0335D:  01
F00:9238       	dc.w	KEY_DEF-TAB_STAR			* DEF
               S01:00E0335E:  00 6F
F00:9239       	dc.b	'P',2
               S01:00E03360:  50
               S01:00E03361:  02
F00:9240       	dc.w	KEY_POKE-TAB_STAR			* POKE
               S01:00E03362:  01 38
F00:9241       	dc.b	'D',2
               S01:00E03364:  44
               S01:00E03365:  02
F00:9242       	dc.w	KEY_DOKE-TAB_STAR			* DOKE
               S01:00E03366:  00 75
F00:9243       	dc.b	'L',2
               S01:00E03368:  4C
               S01:00E03369:  02
F00:9244       	dc.w	KEY_LOKE-TAB_STAR			* LOKE
               S01:00E0336A:  00 F9
F00:9245       	dc.b	'C',2
               S01:00E0336C:  43
               S01:00E0336D:  02
F00:9246       	dc.w	KEY_CALL-TAB_STAR			* CALL
               S01:00E0336E:  00 43
F00:9247       	dc.b	'D',0
               S01:00E03370:  44
               S01:00E03371:  00
F00:9248       	dc.w	KEY_DO-TAB_STAR			* DO
               S01:00E03372:  00 79
F00:9249       	dc.b	'L',2
               S01:00E03374:  4C
               S01:00E03375:  02
F00:9250       	dc.w	KEY_LOOP-TAB_STAR			* LOOP
               S01:00E03376:  00 FD
F00:9251       	dc.b	'P',3
               S01:00E03378:  50
               S01:00E03379:  03
F00:9252       	dc.w	KEY_PRINT-TAB_STAR		* PRINT
               S01:00E0337A:  01 40
F00:9253       	dc.b	'C',2
               S01:00E0337C:  43
               S01:00E0337D:  02
F00:9254       	dc.w	KEY_CONT-TAB_STAR			* CONT
               S01:00E0337E:  00 54
F00:9255       
F00:9256       	dc.b	'B',4
               S01:00E03380:  42
               S01:00E03381:  04
F00:9257       	dc.w	KEY_BUFFER-TAB_STAR		* BUFFER
               S01:00E03382:  00 3C
F00:9258       	dc.b	'C',1
               S01:00E03384:  43
               S01:00E03385:  01
F00:9259       	dc.w	KEY_CLS-TAB_STAR			* CLS
               S01:00E03386:  00 51
F00:9260       	dc.b	'C',4
               S01:00E03388:  43
               S01:00E03389:  04
F00:9261       	dc.w	KEY_CURSOR-TAB_STAR		* CURSOR
               S01:00E0338A:  00 5C
F00:9262       	dc.b	'L',2
               S01:00E0338C:  4C
               S01:00E0338D:  02
F00:9263       	dc.w	KEY_LINE-TAB_STAR			* LINE
               S01:00E0338E:  00 E9
F00:9264       	dc.b	'F',2
               S01:00E03390:  46
               S01:00E03391:  02
F00:9265       	dc.w	KEY_FILL-TAB_STAR			* FILL
               S01:00E03392:  00 9A
F00:9266       	dc.b	'M',2
               S01:00E03394:  4D
               S01:00E03395:  02
F00:9267       	dc.w	KEY_MOVE-TAB_STAR			* MOVE
               S01:00E03396:  01 13
F00:9268       	dc.b	'P',3
               S01:00E03398:  50
               S01:00E03399:  03
F00:9269       	dc.w	KEY_POINT-TAB_STAR		* POINT
               S01:00E0339A:  01 33
F00:9270       	dc.b	'R',2
               S01:00E0339C:  52
               S01:00E0339D:  02
F00:9271       	dc.w	KEY_RECT-TAB_STAR			* RECT
               S01:00E0339E:  01 56
F00:9272       	dc.b	'R',3
               S01:00E033A0:  52
               S01:00E033A1:  03
F00:9273       	dc.w	KEY_FRECT-TAB_STAR		* RECTF
               S01:00E033A2:  01 51
F00:9274       	dc.b	'E',5
               S01:00E033A4:  45
               S01:00E033A5:  05
F00:9275       	dc.w	KEY_ELLIPSE-TAB_STAR		* ELLIPSE
               S01:00E033A6:  00 8B
F00:9276       	dc.b	'E',6
               S01:00E033A8:  45
               S01:00E033A9:  06
F00:9277       	dc.w	KEY_FELLIPSE-TAB_STAR		* ELLIPSEF
               S01:00E033AA:  00 83
F00:9278       	dc.b	'M',2
               S01:00E033AC:  4D
               S01:00E033AD:  02
F00:9279       	dc.w	KEY_MODE-TAB_STAR			* MODE
               S01:00E033AE:  01 0F
F00:9280       	dc.b	'S',2
               S01:00E033B0:  53
               S01:00E033B1:  02
F00:9281       	dc.w	KEY_SIZE-TAB_STAR			* SIZE
               S01:00E033B2:  01 8A
F00:9282       
F00:9283       	dc.b	'L',2
               S01:00E033B4:  4C
               S01:00E033B5:  02
F00:9284       	dc.w	KEY_LIST-TAB_STAR			* LIST
               S01:00E033B6:  00 ED
F00:9285       	dc.b	'C',3
               S01:00E033B8:  43
               S01:00E033B9:  03
F00:9286       	dc.w	KEY_CLEAR-TAB_STAR		* CLEAR
               S01:00E033BA:  00 4C
F00:9287       	dc.b	'N',1
               S01:00E033BC:  4E
               S01:00E033BD:  01
F00:9288       	dc.w	KEY_NEW-TAB_STAR			* NEW
               S01:00E033BE:  01 18
F00:9289       	dc.b	'W',3
               S01:00E033C0:  57
               S01:00E033C1:  03
F00:9290       	dc.w	KEY_WIDTH-TAB_STAR		* WIDTH
               S01:00E033C2:  01 EB
F00:9291       	dc.b	'G',1
               S01:00E033C4:  47
               S01:00E033C5:  01
F00:9292       	dc.w	KEY_GET-TAB_STAR			* GET
               S01:00E033C6:  00 A8
F00:9293       	dc.b	'S',2
               S01:00E033C8:  53
               S01:00E033C9:  02
F00:9294       	dc.w	KEY_SWAP-TAB_STAR			* SWAP
               S01:00E033CA:  01 A3
F00:9295       	dc.b	'B',4
               S01:00E033CC:  42
               S01:00E033CD:  04
F00:9296       	dc.w	KEY_BITSET-TAB_STAR		* BITSET
               S01:00E033CE:  00 2F
F00:9297       	dc.b	'B',4
               S01:00E033D0:  42
               S01:00E033D1:  04
F00:9298       	dc.w	KEY_BITCLR-TAB_STAR		* BITCLR
               S01:00E033D2:  00 29
F00:9299       	dc.b	'T',2
               S01:00E033D4:  54
               S01:00E033D5:  02
F00:9300       	dc.w	KEY_TAB-TAB_STAR			* TAB(
               S01:00E033D6:  01 A8
F00:9301       	dc.b	'E',2
               S01:00E033D8:  45
               S01:00E033D9:  02
F00:9302       	dc.w	KEY_ELSE-TAB_STAR			* ELSE
               S01:00E033DA:  00 7C
F00:9303       	dc.b	'T',0
               S01:00E033DC:  54
               S01:00E033DD:  00
F00:9304       	dc.w	KEY_TO-TAB_STAR			* TO
               S01:00E033DE:  01 B6
F00:9305       	dc.b	'F',0
               S01:00E033E0:  46
               S01:00E033E1:  00
F00:9306       	dc.w	KEY_FN-TAB_STAR			* FN
               S01:00E033E2:  00 A1
F00:9307       	dc.b	'S',2
               S01:00E033E4:  53
               S01:00E033E5:  02
F00:9308       	dc.w	KEY_SPC-TAB_STAR			* SPC(
               S01:00E033E6:  01 8E
F00:9309       	dc.b	'T',2
               S01:00E033E8:  54
               S01:00E033E9:  02
F00:9310       	dc.w	KEY_THEN-TAB_STAR			* THEN
               S01:00E033EA:  01 B0
F00:9311       	dc.b	'N',1
               S01:00E033EC:  4E
               S01:00E033ED:  01
F00:9312       	dc.w	KEY_NOT-TAB_STAR			* NOT
               S01:00E033EE:  01 1F
F00:9313       	dc.b	'S',2
               S01:00E033F0:  53
               S01:00E033F1:  02
F00:9314       	dc.w	KEY_STEP-TAB_STAR			* STEP
               S01:00E033F2:  01 96
F00:9315       	dc.b	'U',3
               S01:00E033F4:  55
               S01:00E033F5:  03
F00:9316       	dc.w	KEY_UNTIL-TAB_STAR		* UNTIL
               S01:00E033F6:  01 C5
F00:9317       	dc.b	'W',3
               S01:00E033F8:  57
               S01:00E033F9:  03
F00:9318       	dc.w	KEY_WHILE-TAB_STAR		* WHILE
               S01:00E033FA:  01 E6
F00:9319       
F00:9320       	dc.b	'+',-1
               S01:00E033FC:  2B
               S01:00E033FD:  FF
F00:9321       	dc.w	KEY_PLUS-TAB_STAR			* +
               S01:00E033FE:  00 02
F00:9322       	dc.b	'-',-1
               S01:00E03400:  2D
               S01:00E03401:  FF
F00:9323       	dc.w	KEY_MINUS-TAB_STAR		* -
               S01:00E03402:  00 04
F00:9324       	dc.b	'*',-1
               S01:00E03404:  2A
               S01:00E03405:  FF
F00:9325       	dc.w	KEY_MULT-TAB_STAR			* *
               S01:00E03406:  00 00
F00:9326       	dc.b	'/',-1
               S01:00E03408:  2F
               S01:00E03409:  FF
F00:9327       	dc.w	KEY_DIV-TAB_STAR			* /
               S01:00E0340A:  00 06
F00:9328       	dc.b	'^',-1
               S01:00E0340C:  5E
               S01:00E0340D:  FF
F00:9329       	dc.w	KEY_POWER-TAB_STAR		* ^
               S01:00E0340E:  01 F1
F00:9330       	dc.b	'A',1
               S01:00E03410:  41
               S01:00E03411:  01
F00:9331       	dc.w	KEY_AND-TAB_STAR			* AND
               S01:00E03412:  00 18
F00:9332       	dc.b	'E',1
               S01:00E03414:  45
               S01:00E03415:  01
F00:9333       	dc.w	KEY_EOR-TAB_STAR			* EOR
               S01:00E03416:  00 92
F00:9334       	dc.b	'O',0
               S01:00E03418:  4F
               S01:00E03419:  00
F00:9335       	dc.w	KEY_OR-TAB_STAR			* OR
               S01:00E0341A:  01 29
F00:9336       	dc.b	'>',0
               S01:00E0341C:  3E
               S01:00E0341D:  00
F00:9337       	dc.w	KEY_RSHIFT-TAB_STAR		* >>
               S01:00E0341E:  00 0E
F00:9338       	dc.b	'<',0
               S01:00E03420:  3C
               S01:00E03421:  00
F00:9339       	dc.w	KEY_LSHIFT-TAB_STAR		* <<
               S01:00E03422:  00 08
F00:9340       	dc.b	'>',-1
               S01:00E03424:  3E
               S01:00E03425:  FF
F00:9341       	dc.w	KEY_GT-TAB_STAR			* >
               S01:00E03426:  00 10
F00:9342       	dc.b	'=',-1
               S01:00E03428:  3D
               S01:00E03429:  FF
F00:9343       	dc.w	KEY_EQUAL-TAB_STAR		* =
               S01:00E0342A:  00 0C
F00:9344       	dc.b	'<',-1
               S01:00E0342C:  3C
               S01:00E0342D:  FF
F00:9345       	dc.w	KEY_LT-TAB_STAR			* <
               S01:00E0342E:  00 0A
F00:9346       
F00:9347       	dc.b	'S',2
               S01:00E03430:  53
               S01:00E03431:  02
F00:9348       	dc.w	KEY_SGN-TAB_STAR			* SGN(
               S01:00E03432:  01 82
F00:9349       	dc.b	'I',2
               S01:00E03434:  49
               S01:00E03435:  02
F00:9350       	dc.w	KEY_INT-TAB_STAR			* INT(
               S01:00E03436:  00 C5
F00:9351       	dc.b	'A',2
               S01:00E03438:  41
               S01:00E03439:  02
F00:9352       	dc.w	KEY_ABS-TAB_STAR			* ABS(
               S01:00E0343A:  00 14
F00:9353       	dc.b	'U',2
               S01:00E0343C:  55
               S01:00E0343D:  02
F00:9354       	dc.w	KEY_USR-TAB_STAR			* USR(
               S01:00E0343E:  01 D1
F00:9355       	dc.b	'F',2
               S01:00E03440:  46
               S01:00E03441:  02
F00:9356       	dc.w	KEY_FRE-TAB_STAR			* FRE(
               S01:00E03442:  00 A3
F00:9357       	dc.b	'P',2
               S01:00E03444:  50
               S01:00E03445:  02
F00:9358       	dc.w	KEY_POS-TAB_STAR			* POS(
               S01:00E03446:  01 3C
F00:9359       	dc.b	'S',2
               S01:00E03448:  53
               S01:00E03449:  02
F00:9360       	dc.w	KEY_SQR-TAB_STAR			* SQR(
               S01:00E0344A:  01 92
F00:9361       	dc.b	'R',2
               S01:00E0344C:  52
               S01:00E0344D:  02
F00:9362       	dc.w	KEY_RND-TAB_STAR			* RND(
               S01:00E0344E:  01 71
F00:9363       	dc.b	'L',2
               S01:00E03450:  4C
               S01:00E03451:  02
F00:9364       	dc.w	KEY_LOG-TAB_STAR			* LOG(
               S01:00E03452:  00 F5
F00:9365       	dc.b	'E',2
               S01:00E03454:  45
               S01:00E03455:  02
F00:9366       	dc.w	KEY_EXP-TAB_STAR			* EXP(
               S01:00E03456:  00 95
F00:9367       	dc.b	'C',2
               S01:00E03458:  43
               S01:00E03459:  02
F00:9368       	dc.w	KEY_COS-TAB_STAR			* COS(
               S01:00E0345A:  00 58
F00:9369       	dc.b	'S',2
               S01:00E0345C:  53
               S01:00E0345D:  02
F00:9370       	dc.w	KEY_SIN-TAB_STAR			* SIN(
               S01:00E0345E:  01 86
F00:9371       	dc.b	'T',2
               S01:00E03460:  54
               S01:00E03461:  02
F00:9372       	dc.w	KEY_TAN-TAB_STAR			* TAN(
               S01:00E03462:  01 AC
F00:9373       	dc.b	'A',2
               S01:00E03464:  41
               S01:00E03465:  02
F00:9374       	dc.w	KEY_ATN-TAB_STAR			* ATN(
               S01:00E03466:  00 1F
F00:9375       	dc.b	'P',3
               S01:00E03468:  50
               S01:00E03469:  03
F00:9376       	dc.w	KEY_PEEK-TAB_STAR			* PEEK(
               S01:00E0346A:  01 2C
F00:9377       	dc.b	'D',3
               S01:00E0346C:  44
               S01:00E0346D:  03
F00:9378       	dc.w	KEY_DEEK-TAB_STAR			* DEEK(
               S01:00E0346E:  00 6A
F00:9379       	dc.b	'L',3
               S01:00E03470:  4C
               S01:00E03471:  03
F00:9380       	dc.w	KEY_LEEK-TAB_STAR			* LEEK(
               S01:00E03472:  00 D7
F00:9381       	dc.b	'L',2
               S01:00E03474:  4C
               S01:00E03475:  02
F00:9382       	dc.w	KEY_LEN-TAB_STAR			* LEN(
               S01:00E03476:  00 E2
F00:9383       	dc.b	'S',3
               S01:00E03478:  53
               S01:00E03479:  03
F00:9384       	dc.w	KEY_STRS-TAB_STAR			* STR$(
               S01:00E0347A:  01 9E
F00:9385       	dc.b	'V',2
               S01:00E0347C:  56
               S01:00E0347D:  02
F00:9386       	dc.w	KEY_VAL-TAB_STAR			* VAL(
               S01:00E0347E:  01 D6
F00:9387       	dc.b	'A',2
               S01:00E03480:  41
               S01:00E03481:  02
F00:9388       	dc.w	KEY_ASC-TAB_STAR			* ASC(
               S01:00E03482:  00 1B
F00:9389       	dc.b	'U',5
               S01:00E03484:  55
               S01:00E03485:  05
F00:9390       	dc.w	KEY_UCASES-TAB_STAR		* UCASE$(
               S01:00E03486:  01 BE
F00:9391       	dc.b	'L',5
               S01:00E03488:  4C
               S01:00E03489:  05
F00:9392       	dc.w	KEY_LCASES-TAB_STAR		* LCASE$(
               S01:00E0348A:  00 D0
F00:9393       	dc.b	'C',3
               S01:00E0348C:  43
               S01:00E0348D:  03
F00:9394       	dc.w	KEY_CHRS-TAB_STAR			* CHR$(
               S01:00E0348E:  00 47
F00:9395       	dc.b	'H',3
               S01:00E03490:  48
               S01:00E03491:  03
F00:9396       	dc.w	KEY_HEXS-TAB_STAR			* HEX$(
               S01:00E03492:  00 B5
F00:9397       	dc.b	'B',3
               S01:00E03494:  42
               S01:00E03495:  03
F00:9398       	dc.w	KEY_BINS-TAB_STAR			* BIN$(
               S01:00E03496:  00 24
F00:9399       	dc.b	'B',5
               S01:00E03498:  42
               S01:00E03499:  05
F00:9400       	dc.w	KEY_BITTST-TAB_STAR		* BITTST(
               S01:00E0349A:  00 35
F00:9401       	dc.b	'M',2
               S01:00E0349C:  4D
               S01:00E0349D:  02
F00:9402       	dc.w	KEY_MAX-TAB_STAR			* MAX(
               S01:00E0349E:  01 02
F00:9403       	dc.b	'M',2
               S01:00E034A0:  4D
               S01:00E034A1:  02
F00:9404       	dc.w	KEY_MIN-TAB_STAR			* MIN(
               S01:00E034A2:  01 0B
F00:9405       	dc.b	'R',5
               S01:00E034A4:  52
               S01:00E034A5:  05
F00:9406       	dc.w	KEY_RAM-TAB_STAR			* RAMBASE
               S01:00E034A6:  01 46
F00:9407       	dc.b	'K',3
               S01:00E034A8:  4B
               S01:00E034A9:  03
F00:9408       	dc.w	KEY_KEYS-TAB_STAR			* KEYS(
               S01:00E034AA:  00 CA
F00:9409       	dc.b	'T',0
               S01:00E034AC:  54
               S01:00E034AD:  00
F00:9410       	dc.w	KEY_TI-TAB_STAR			* TI
               S01:00E034AE:  01 B4
F00:9411       	dc.b	'P',0
               S01:00E034B0:  50
               S01:00E034B1:  00
F00:9412       	dc.w	KEY_PI-TAB_STAR			* PI
               S01:00E034B2:  01 31
F00:9413       	dc.b	'T',3
               S01:00E034B4:  54
               S01:00E034B5:  03
F00:9414       	dc.w	KEY_TWOPI-TAB_STAR		* TWOPI
               S01:00E034B6:  01 B8
F00:9415       	dc.b	'V',5
               S01:00E034B8:  56
               S01:00E034B9:  05
F00:9416       	dc.w	KEY_VPTR-TAB_STAR			* VARPTR(
               S01:00E034BA:  01 DA
F00:9417       	dc.b	'S',3
               S01:00E034BC:  53
               S01:00E034BD:  03
F00:9418       	dc.w	KEY_SADD-TAB_STAR			* SADD(
               S01:00E034BE:  01 79
F00:9419       	dc.b	'L',4
               S01:00E034C0:  4C
               S01:00E034C1:  04
F00:9420       	dc.w	KEY_LEFTS-TAB_STAR		* LEFT$(
               S01:00E034C2:  00 DC
F00:9421       	dc.b	'R',5
               S01:00E034C4:  52
               S01:00E034C5:  05
F00:9422       	dc.w	KEY_RIGHTS-TAB_STAR		* RIGHT$(
               S01:00E034C6:  01 6A
F00:9423       	dc.b	'M',3
               S01:00E034C8:  4D
               S01:00E034C9:  03
F00:9424       	dc.w	KEY_MIDS-TAB_STAR			* MID$(
               S01:00E034CA:  01 06
F00:9425       	dc.b	'U',5
               S01:00E034CC:  55
               S01:00E034CD:  05
F00:9426       	dc.w	KEY_USINGS-TAB_STAR		* USING$(
               S01:00E034CE:  01 CA
F00:9427       
F00:9428       
F00:9429       *************************************************************************************
F00:9430       *
F00:9431       * BASIC error messages
F00:9432       
F00:9433       LAB_BAER
F00:9434       	dc.w	LAB_NF-LAB_BAER			* $00 NEXT without FOR
               S01:00E034D0:  00 2E
F00:9435       	dc.w	LAB_SN-LAB_BAER			* $02 syntax
               S01:00E034D2:  00 3F
F00:9436       	dc.w	LAB_RG-LAB_BAER			* $04 RETURN without GOSUB
               S01:00E034D4:  00 46
F00:9437       	dc.w	LAB_OD-LAB_BAER			* $06 out of data
               S01:00E034D6:  00 5B
F00:9438       	dc.w	LAB_FC-LAB_BAER			* $08 function call
               S01:00E034D8:  00 67
F00:9439       	dc.w	LAB_OV-LAB_BAER			* $0A overflow
               S01:00E034DA:  00 75
F00:9440       	dc.w	LAB_OM-LAB_BAER			* $0C out of memory
               S01:00E034DC:  00 7E
F00:9441       	dc.w	LAB_US-LAB_BAER			* $0E undefined statement
               S01:00E034DE:  00 8C
F00:9442       	dc.w	LAB_BS-LAB_BAER			* $10 array bounds
               S01:00E034E0:  00 A0
F00:9443       	dc.w	LAB_DD-LAB_BAER			* $12 double dimension array
               S01:00E034E2:  00 AD
F00:9444       	dc.w	LAB_D0-LAB_BAER			* $14 divide by 0
               S01:00E034E4:  00 BE
F00:9445       	dc.w	LAB_ID-LAB_BAER			* $16 illegal direct
               S01:00E034E6:  00 CD
F00:9446       	dc.w	LAB_TM-LAB_BAER			* $18 type mismatch
               S01:00E034E8:  00 DC
F00:9447       	dc.w	LAB_LS-LAB_BAER			* $1A long string
               S01:00E034EA:  00 EA
F00:9448       	dc.w	LAB_ST-LAB_BAER			* $1C string too complex
               S01:00E034EC:  00 FA
F00:9449       	dc.w	LAB_CN-LAB_BAER			* $1E continue error
               S01:00E034EE:  01 0D
F00:9450       	dc.w	LAB_UF-LAB_BAER			* $20 undefined function
               S01:00E034F0:  01 1C
F00:9451       	dc.w	LAB_LD-LAB_BAER			* $22 LOOP without DO
               S01:00E034F2:  01 2F
F00:9452       	dc.w	LAB_UV-LAB_BAER			* $24 undefined variable
               S01:00E034F4:  01 3F
F00:9453       	dc.w	LAB_UA-LAB_BAER			* $26 undimensioned array
               S01:00E034F6:  01 52
F00:9454       	dc.w	LAB_WD-LAB_BAER			* $28 wrong dimensions
               S01:00E034F8:  01 66
F00:9455       	dc.w	LAB_AD-LAB_BAER			* $2A address
               S01:00E034FA:  01 77
F00:9456       	dc.w	LAB_FO-LAB_BAER			* $2C format
               S01:00E034FC:  01 7F
F00:9457       
F00:9458       LAB_NF	dc.b	'NEXT without FOR',$00
               S01:00E034FE:  4E 45 58 54 20 77 69 74 68 6F 75 74 20 46 4F 52
               S01:00E0350E:  00
F00:9459       LAB_SN	dc.b	'Syntax',$00
               S01:00E0350F:  53 79 6E 74 61 78
               S01:00E03515:  00
F00:9460       LAB_RG	dc.b	'RETURN without GOSUB',$00
               S01:00E03516:  52 45 54 55 52 4E 20 77 69 74 68 6F 75 74 20 47
               S01:00E03526:  4F 53 55 42
               S01:00E0352A:  00
F00:9461       LAB_OD	dc.b	'Out of DATA',$00
               S01:00E0352B:  4F 75 74 20 6F 66 20 44 41 54 41
               S01:00E03536:  00
F00:9462       LAB_FC	dc.b	'Function call',$00
               S01:00E03537:  46 75 6E 63 74 69 6F 6E 20 63 61 6C 6C
               S01:00E03544:  00
F00:9463       LAB_OV	dc.b	'Overflow',$00
               S01:00E03545:  4F 76 65 72 66 6C 6F 77
               S01:00E0354D:  00
F00:9464       LAB_OM	dc.b	'Out of memory',$00
               S01:00E0354E:  4F 75 74 20 6F 66 20 6D 65 6D 6F 72 79
               S01:00E0355B:  00
F00:9465       LAB_US	dc.b	'Undefined statement',$00
               S01:00E0355C:  55 6E 64 65 66 69 6E 65 64 20 73 74 61 74 65 6D
               S01:00E0356C:  65 6E 74
               S01:00E0356F:  00
F00:9466       LAB_BS	dc.b	'Array bounds',$00
               S01:00E03570:  41 72 72 61 79 20 62 6F 75 6E 64 73
               S01:00E0357C:  00
F00:9467       LAB_DD	dc.b	'Double dimension',$00
               S01:00E0357D:  44 6F 75 62 6C 65 20 64 69 6D 65 6E 73 69 6F 6E
               S01:00E0358D:  00
F00:9468       LAB_D0	dc.b	'Divide by zero',$00
               S01:00E0358E:  44 69 76 69 64 65 20 62 79 20 7A 65 72 6F
               S01:00E0359C:  00
F00:9469       LAB_ID	dc.b	'Illegal direct',$00
               S01:00E0359D:  49 6C 6C 65 67 61 6C 20 64 69 72 65 63 74
               S01:00E035AB:  00
F00:9470       LAB_TM	dc.b	'Type mismatch',$00
               S01:00E035AC:  54 79 70 65 20 6D 69 73 6D 61 74 63 68
               S01:00E035B9:  00
F00:9471       LAB_LS	dc.b	'String too long',$00
               S01:00E035BA:  53 74 72 69 6E 67 20 74 6F 6F 20 6C 6F 6E 67
               S01:00E035C9:  00
F00:9472       LAB_ST	dc.b	'String too complex',$00
               S01:00E035CA:  53 74 72 69 6E 67 20 74 6F 6F 20 63 6F 6D 70 6C
               S01:00E035DA:  65 78
               S01:00E035DC:  00
F00:9473       LAB_CN	dc.b	'Can''t continue',$00
               S01:00E035DD:  43 61 6E 27 74 20 63 6F 6E 74 69 6E 75 65
               S01:00E035EB:  00
F00:9474       LAB_UF	dc.b	'Undefined function',$00
               S01:00E035EC:  55 6E 64 65 66 69 6E 65 64 20 66 75 6E 63 74 69
               S01:00E035FC:  6F 6E
               S01:00E035FE:  00
F00:9475       LAB_LD	dc.b	'LOOP without DO',$00
               S01:00E035FF:  4C 4F 4F 50 20 77 69 74 68 6F 75 74 20 44 4F
               S01:00E0360E:  00
F00:9476       LAB_UV	dc.b	'Undefined variable',$00
               S01:00E0360F:  55 6E 64 65 66 69 6E 65 64 20 76 61 72 69 61 62
               S01:00E0361F:  6C 65
               S01:00E03621:  00
F00:9477       LAB_UA	dc.b	'Undimensioned array',$00
               S01:00E03622:  55 6E 64 69 6D 65 6E 73 69 6F 6E 65 64 20 61 72
               S01:00E03632:  72 61 79
               S01:00E03635:  00
F00:9478       LAB_WD	dc.b	'Wrong dimensions',$00
               S01:00E03636:  57 72 6F 6E 67 20 64 69 6D 65 6E 73 69 6F 6E 73
               S01:00E03646:  00
F00:9479       LAB_AD	dc.b	'Address',$00
               S01:00E03647:  41 64 64 72 65 73 73
               S01:00E0364E:  00
F00:9480       LAB_FO	dc.b	'Format',$00
               S01:00E0364F:  46 6F 72 6D 61 74
               S01:00E03655:  00
F00:9481       
F00:9482       
F00:9483       *************************************************************************************
F00:9484       *
F00:9485       * keyword table for line (un)crunching
F00:9486       
F00:9487       * [keyword,token
F00:9488       * [keyword,token]]
F00:9489       * end marker (#$00)
F00:9490       
F00:9491       TAB_STAR
F00:9492       KEY_MULT
F00:9493       	dc.b TK_MULT,$00				* *
               S01:00E03656:  C1
               S01:00E03657:  00
F00:9494       TAB_PLUS
F00:9495       KEY_PLUS
F00:9496       	dc.b TK_PLUS,$00				* +
               S01:00E03658:  BF
               S01:00E03659:  00
F00:9497       TAB_MNUS
F00:9498       KEY_MINUS
F00:9499       	dc.b TK_MINUS,$00				* -
               S01:00E0365A:  C0
               S01:00E0365B:  00
F00:9500       TAB_SLAS
F00:9501       KEY_DIV
F00:9502       	dc.b TK_DIV,$00				* /
               S01:00E0365C:  C2
               S01:00E0365D:  00
F00:9503       TAB_LESS
F00:9504       KEY_LSHIFT
F00:9505       	dc.b	'<',TK_LSHIFT			* <<
               S01:00E0365E:  3C
               S01:00E0365F:  C8
F00:9506       KEY_LT
F00:9507       	dc.b TK_LT					* <
               S01:00E03660:  CB
F00:9508       	dc.b	$00
               S01:00E03661:  00
F00:9509       TAB_EQUL
F00:9510       KEY_EQUAL
F00:9511       	dc.b TK_EQUAL,$00				* =
               S01:00E03662:  CA
               S01:00E03663:  00
F00:9512       TAB_MORE
F00:9513       KEY_RSHIFT
F00:9514       	dc.b	'>',TK_RSHIFT			* >>
               S01:00E03664:  3E
               S01:00E03665:  C7
F00:9515       KEY_GT
F00:9516       	dc.b TK_GT					* >
               S01:00E03666:  C9
F00:9517       	dc.b	$00
               S01:00E03667:  00
F00:9518       TAB_QEST
F00:9519       	dc.b TK_PRINT,$00				* ?
               S01:00E03668:  9E
               S01:00E03669:  00
F00:9520       TAB_ASCA
F00:9521       KEY_ABS
F00:9522       	dc.b	'BS(',TK_ABS			* ABS(
               S01:00E0366A:  42 53 28
               S01:00E0366D:  CE
F00:9523       KEY_AND
F00:9524       	dc.b	'ND',TK_AND				* AND
               S01:00E0366E:  4E 44
               S01:00E03670:  C4
F00:9525       KEY_ASC
F00:9526       	dc.b	'SC(',TK_ASC			* ASC(
               S01:00E03671:  53 43 28
               S01:00E03674:  E0
F00:9527       KEY_ATN
F00:9528       	dc.b	'TN(',TK_ATN			* ATN(
               S01:00E03675:  54 4E 28
               S01:00E03678:  D9
F00:9529       	dc.b	$00
               S01:00E03679:  00
F00:9530       TAB_ASCB
F00:9531       KEY_BINS
F00:9532       	dc.b	'IN$(',TK_BINS			* BIN$(
               S01:00E0367A:  49 4E 24 28
               S01:00E0367E:  E5
F00:9533       KEY_BITCLR
F00:9534       	dc.b	'ITCLR',TK_BITCLR			* BITCLR
               S01:00E0367F:  49 54 43 4C 52
               S01:00E03684:  B4
F00:9535       KEY_BITSET
F00:9536       	dc.b	'ITSET',TK_BITSET			* BITSET
               S01:00E03685:  49 54 53 45 54
               S01:00E0368A:  B3
F00:9537       KEY_BITTST
F00:9538       	dc.b	'ITTST(',TK_BITTST		* BITTST(
               S01:00E0368B:  49 54 54 53 54 28
               S01:00E03691:  E6
F00:9539       KEY_BUFFER
F00:9540       	dc.b	'UFFER',TK_BUFFER			* BUFFER
               S01:00E03692:  55 46 46 45 52
               S01:00E03697:  A0
F00:9541       	dc.b	$00
               S01:00E03698:  00
F00:9542       TAB_ASCC
F00:9543       KEY_CALL
F00:9544       	dc.b	'ALL',TK_CALL			* CALL
               S01:00E03699:  41 4C 4C
               S01:00E0369C:  9B
F00:9545       KEY_CHRS
F00:9546       	dc.b	'HR$(',TK_CHRS			* CHR$(
               S01:00E0369D:  48 52 24 28
               S01:00E036A1:  E3
F00:9547       KEY_CLEAR
F00:9548       	dc.b	'LEAR',TK_CLEAR			* CLEAR
               S01:00E036A2:  4C 45 41 52
               S01:00E036A6:  AE
F00:9549       KEY_CLS
F00:9550       	dc.b	'LS',TK_CLS				* CLS
               S01:00E036A7:  4C 53
               S01:00E036A9:  A1
F00:9551       KEY_CONT
F00:9552       	dc.b	'ONT',TK_CONT			* CONT
               S01:00E036AA:  4F 4E 54
               S01:00E036AD:  9F
F00:9553       KEY_COS
F00:9554       	dc.b	'OS(',TK_COS			* COS(
               S01:00E036AE:  4F 53 28
               S01:00E036B1:  D6
F00:9555       KEY_CURSOR
F00:9556       	dc.b	'URSOR',TK_CURSOR			* CURSOR
               S01:00E036B2:  55 52 53 4F 52
               S01:00E036B7:  A2
F00:9557       	dc.b	$00
               S01:00E036B8:  00
F00:9558       TAB_ASCD
F00:9559       KEY_DATA
F00:9560       	dc.b	'ATA',TK_DATA			* DATA
               S01:00E036B9:  41 54 41
               S01:00E036BC:  83
F00:9561       KEY_DEC
F00:9562       	dc.b	'EC',TK_DEC				* DEC
               S01:00E036BD:  45 43
               S01:00E036BF:  88
F00:9563       KEY_DEEK
F00:9564       	dc.b	'EEK(',TK_DEEK			* DEEK(
               S01:00E036C0:  45 45 4B 28
               S01:00E036C4:  DB
F00:9565       KEY_DEF
F00:9566       	dc.b	'EF',TK_DEF				* DEF
               S01:00E036C5:  45 46
               S01:00E036C7:  97
F00:9567       KEY_DIM
F00:9568       	dc.b	'IM',TK_DIM				* DIM
               S01:00E036C8:  49 4D
               S01:00E036CA:  85
F00:9569       KEY_DOKE
F00:9570       	dc.b	'OKE',TK_DOKE			* DOKE
               S01:00E036CB:  4F 4B 45
               S01:00E036CE:  99
F00:9571       KEY_DO
F00:9572       	dc.b	'O',TK_DO				* DO
               S01:00E036CF:  4F
               S01:00E036D0:  9C
F00:9573       	dc.b	$00
               S01:00E036D1:  00
F00:9574       TAB_ASCE
F00:9575       KEY_ELSE
F00:9576       	dc.b	'LSE',TK_ELSE			* ELSE
               S01:00E036D2:  4C 53 45
               S01:00E036D5:  B6
F00:9577       KEY_END
F00:9578       	dc.b	'ND',TK_END				* END
               S01:00E036D6:  4E 44
               S01:00E036D8:  80
F00:9579       KEY_FELLIPSE
F00:9580       	dc.b	'LLIPSEF',TK_FELLIPSE		* ELLIPSEF
               S01:00E036D9:  4C 4C 49 50 53 45 46
               S01:00E036E0:  AA
F00:9581       KEY_ELLIPSE
F00:9582       	dc.b	'LLIPSE',TK_ELLIPSE		* ELLIPSE
               S01:00E036E1:  4C 4C 49 50 53 45
               S01:00E036E7:  A9
F00:9583       KEY_EOR
F00:9584       	dc.b	'OR',TK_EOR				* EOR
               S01:00E036E8:  4F 52
               S01:00E036EA:  C5
F00:9585       KEY_EXP
F00:9586       	dc.b	'XP(',TK_EXP			* EXP(
               S01:00E036EB:  58 50 28
               S01:00E036EE:  D5
F00:9587       	dc.b	$00
               S01:00E036EF:  00
F00:9588       TAB_ASCF
F00:9589       KEY_FILL
F00:9590       	dc.b	'ILL',TK_FILL			* FILL
               S01:00E036F0:  49 4C 4C
               S01:00E036F3:  A4
F00:9591       KEY_FOR
F00:9592       	dc.b	'OR',TK_FOR				* FOR
               S01:00E036F4:  4F 52
               S01:00E036F6:  81
F00:9593       KEY_FN
F00:9594       	dc.b	'N',TK_FN				* FN
               S01:00E036F7:  4E
               S01:00E036F8:  B8
F00:9595       KEY_FRE
F00:9596       	dc.b	'RE(',TK_FRE			* FRE(
               S01:00E036F9:  52 45 28
               S01:00E036FC:  D0
F00:9597       	dc.b	$00
               S01:00E036FD:  00
F00:9598       TAB_ASCG
F00:9599       KEY_GET
F00:9600       	dc.b	'ET',TK_GET				* GET
               S01:00E036FE:  45 54
               S01:00E03700:  B1
F00:9601       KEY_GOTO
F00:9602       	dc.b	'OTO',TK_GOTO			* GOTO
               S01:00E03701:  4F 54 4F
               S01:00E03704:  89
F00:9603       KEY_GOSUB
F00:9604       	dc.b	'OSUB',TK_GOSUB			* GOSUB
               S01:00E03705:  4F 53 55 42
               S01:00E03709:  8D
F00:9605       	dc.b	$00
               S01:00E0370A:  00
F00:9606       TAB_ASCH
F00:9607       KEY_HEXS
F00:9608       	dc.b	'EX$(',TK_HEXS,$00		* HEX$(
               S01:00E0370B:  45 58 24 28
               S01:00E0370F:  E4
               S01:00E03710:  00
F00:9609       TAB_ASCI
F00:9610       KEY_IF
F00:9611       	dc.b	'F',TK_IF				* IF
               S01:00E03711:  46
               S01:00E03712:  8B
F00:9612       KEY_INC
F00:9613       	dc.b	'NC',TK_INC				* INC
               S01:00E03713:  4E 43
               S01:00E03715:  93
F00:9614       KEY_INPUT
F00:9615       	dc.b	'NPUT',TK_INPUT			* INPUT
               S01:00E03716:  4E 50 55 54
               S01:00E0371A:  84
F00:9616       KEY_INT
F00:9617       	dc.b	'NT(',TK_INT			* INT(
               S01:00E0371B:  4E 54 28
               S01:00E0371E:  CD
F00:9618       	dc.b	$00
               S01:00E0371F:  00
F00:9619       TAB_ASCK
F00:9620       KEY_KEYS
F00:9621       	dc.b	'EYS(',TK_KEYS			* KEYS(
               S01:00E03720:  45 59 53 28
               S01:00E03724:  EA
F00:9622       	dc.b	$00
               S01:00E03725:  00
F00:9623       TAB_ASCL
F00:9624       KEY_LCASES
F00:9625       	dc.b	'CASE$(',TK_LCASES		* LCASE$(
               S01:00E03726:  43 41 53 45 24 28
               S01:00E0372C:  E2
F00:9626       KEY_LEEK
F00:9627       	dc.b	'EEK(',TK_LEEK			* LEEK(
               S01:00E0372D:  45 45 4B 28
               S01:00E03731:  DC
F00:9628       KEY_LEFTS
F00:9629       	dc.b	'EFT$(',TK_LEFTS			* LEFT$(
               S01:00E03732:  45 46 54 24 28
               S01:00E03737:  F0
F00:9630       KEY_LEN
F00:9631       	dc.b	'EN(',TK_LEN			* LEN(
               S01:00E03738:  45 4E 28
               S01:00E0373B:  DD
F00:9632       KEY_LET
F00:9633       	dc.b	'ET',TK_LET				* LET
               S01:00E0373C:  45 54
               S01:00E0373E:  87
F00:9634       KEY_LINE
F00:9635       	dc.b	'INE',TK_LINE			* LINE
               S01:00E0373F:  49 4E 45
               S01:00E03742:  A3
F00:9636       KEY_LIST
F00:9637       	dc.b	'IST',TK_LIST			* LIST
               S01:00E03743:  49 53 54
               S01:00E03746:  AD
F00:9638       KEY_LOAD
F00:9639       	dc.b	'OAD',TK_LOAD			* LOAD
               S01:00E03747:  4F 41 44
               S01:00E0374A:  95
F00:9640       KEY_LOG
F00:9641       	dc.b	'OG(',TK_LOG			* LOG(
               S01:00E0374B:  4F 47 28
               S01:00E0374E:  D4
F00:9642       KEY_LOKE
F00:9643       	dc.b	'OKE',TK_LOKE			* LOKE
               S01:00E0374F:  4F 4B 45
               S01:00E03752:  9A
F00:9644       KEY_LOOP
F00:9645       	dc.b	'OOP',TK_LOOP			* LOOP
               S01:00E03753:  4F 4F 50
               S01:00E03756:  9D
F00:9646       	dc.b	$00
               S01:00E03757:  00
F00:9647       TAB_ASCM
F00:9648       KEY_MAX
F00:9649       	dc.b	'AX(',TK_MAX			* MAX(
               S01:00E03758:  41 58 28
               S01:00E0375B:  E7
F00:9650       KEY_MIDS
F00:9651       	dc.b	'ID$(',TK_MIDS			* MID$(
               S01:00E0375C:  49 44 24 28
               S01:00E03760:  F2
F00:9652       KEY_MIN
F00:9653       	dc.b	'IN(',TK_MIN			* MIN(
               S01:00E03761:  49 4E 28
               S01:00E03764:  E8
F00:9654       KEY_MODE
F00:9655       	dc.b	'ODE',TK_MODE			* MODE
               S01:00E03765:  4F 44 45
               S01:00E03768:  AB
F00:9656       KEY_MOVE
F00:9657       	dc.b	'OVE',TK_MOVE			* MOVE
               S01:00E03769:  4F 56 45
               S01:00E0376C:  A5
F00:9658       	dc.b	$00
               S01:00E0376D:  00
F00:9659       TAB_ASCN
F00:9660       KEY_NEW
F00:9661       	dc.b	'EW',TK_NEW				* NEW
               S01:00E0376E:  45 57
               S01:00E03770:  AF
F00:9662       KEY_NEXT
F00:9663       	dc.b	'EXT',TK_NEXT			* NEXT
               S01:00E03771:  45 58 54
               S01:00E03774:  82
F00:9664       KEY_NOT
F00:9665       	dc.b	'OT',TK_NOT				* NOT
               S01:00E03775:  4F 54
               S01:00E03777:  BB
F00:9666       KEY_NULL
F00:9667       	dc.b	'ULL',TK_NULL			* NULL
               S01:00E03778:  55 4C 4C
               S01:00E0377B:  92
F00:9668       	dc.b	$00
               S01:00E0377C:  00
F00:9669       TAB_ASCO
F00:9670       KEY_ON
F00:9671       	dc.b	'N',TK_ON				* ON
               S01:00E0377D:  4E
               S01:00E0377E:  91
F00:9672       KEY_OR
F00:9673       	dc.b	'R',TK_OR				* OR
               S01:00E0377F:  52
               S01:00E03780:  C6
F00:9674       	dc.b	$00
               S01:00E03781:  00
F00:9675       TAB_ASCP
F00:9676       KEY_PEEK
F00:9677       	dc.b	'EEK(',TK_PEEK			* PEEK(
               S01:00E03782:  45 45 4B 28
               S01:00E03786:  DA
F00:9678       KEY_PI
F00:9679       	dc.b	'I',TK_PI				* PI
               S01:00E03787:  49
               S01:00E03788:  EC
F00:9680       KEY_POINT
F00:9681       	dc.b	'OINT',TK_POINT			* POINT
               S01:00E03789:  4F 49 4E 54
               S01:00E0378D:  A6
F00:9682       KEY_POKE
F00:9683       	dc.b	'OKE',TK_POKE			* POKE
               S01:00E0378E:  4F 4B 45
               S01:00E03791:  98
F00:9684       KEY_POS
F00:9685       	dc.b	'OS(',TK_POS			* POS(
               S01:00E03792:  4F 53 28
               S01:00E03795:  D1
F00:9686       KEY_PRINT
F00:9687       	dc.b	'RINT',TK_PRINT			* PRINT
               S01:00E03796:  52 49 4E 54
               S01:00E0379A:  9E
F00:9688       	dc.b	$00
               S01:00E0379B:  00
F00:9689       TAB_ASCR
F00:9690       KEY_RAM
F00:9691       	dc.b	'AMBASE',TK_RAM			* RAMBASE
               S01:00E0379C:  41 4D 42 41 53 45
               S01:00E037A2:  E9
F00:9692       KEY_READ
F00:9693       	dc.b	'EAD',TK_READ			* READ
               S01:00E037A3:  45 41 44
               S01:00E037A6:  86
F00:9694       KEY_FRECT
F00:9695       	dc.b	'ECTF',TK_FRECT			* RECTF
               S01:00E037A7:  45 43 54 46
               S01:00E037AB:  A8
F00:9696       KEY_RECT
F00:9697       	dc.b	'ECT',TK_RECT			* RECT
               S01:00E037AC:  45 43 54
               S01:00E037AF:  A7
F00:9698       KEY_REM
F00:9699       	dc.b	'EM',TK_REM				* REM
               S01:00E037B0:  45 4D
               S01:00E037B2:  8F
F00:9700       KEY_RESTORE
F00:9701       	dc.b	'ESTORE',TK_RESTORE		* RESTORE
               S01:00E037B3:  45 53 54 4F 52 45
               S01:00E037B9:  8C
F00:9702       KEY_RETURN
F00:9703       	dc.b	'ETURN',TK_RETURN			* RETURN
               S01:00E037BA:  45 54 55 52 4E
               S01:00E037BF:  8E
F00:9704       KEY_RIGHTS
F00:9705       	dc.b	'IGHT$(',TK_RIGHTS		* RIGHT$(
               S01:00E037C0:  49 47 48 54 24 28
               S01:00E037C6:  F1
F00:9706       KEY_RND
F00:9707       	dc.b	'ND(',TK_RND			* RND(
               S01:00E037C7:  4E 44 28
               S01:00E037CA:  D3
F00:9708       KEY_RUN
F00:9709       	dc.b	'UN',TK_RUN				* RUN
               S01:00E037CB:  55 4E
               S01:00E037CD:  8A
F00:9710       	dc.b	$00
               S01:00E037CE:  00
F00:9711       TAB_ASCS
F00:9712       KEY_SADD
F00:9713       	dc.b	'ADD(',TK_SADD			* SADD(
               S01:00E037CF:  41 44 44 28
               S01:00E037D3:  EF
F00:9714       KEY_SAVE
F00:9715       	dc.b	'AVE',TK_SAVE			* SAVE
               S01:00E037D4:  41 56 45
               S01:00E037D7:  96
F00:9716       KEY_SGN
F00:9717       	dc.b	'GN(',TK_SGN			* SGN(
               S01:00E037D8:  47 4E 28
               S01:00E037DB:  CC
F00:9718       KEY_SIN
F00:9719       	dc.b	'IN(',TK_SIN			* SIN(
               S01:00E037DC:  49 4E 28
               S01:00E037DF:  D7
F00:9720       KEY_SIZE
F00:9721       	dc.b	'IZE',TK_SIZE			* SIZE
               S01:00E037E0:  49 5A 45
               S01:00E037E3:  AC
F00:9722       KEY_SPC
F00:9723       	dc.b	'PC(',TK_SPC			* SPC(
               S01:00E037E4:  50 43 28
               S01:00E037E7:  B9
F00:9724       KEY_SQR
F00:9725       	dc.b	'QR(',TK_SQR			* SQR(
               S01:00E037E8:  51 52 28
               S01:00E037EB:  D2
F00:9726       KEY_STEP
F00:9727       	dc.b	'TEP',TK_STEP			* STEP
               S01:00E037EC:  54 45 50
               S01:00E037EF:  BC
F00:9728       KEY_STOP
F00:9729       	dc.b	'TOP',TK_STOP			* STOP
               S01:00E037F0:  54 4F 50
               S01:00E037F3:  90
F00:9730       KEY_STRS
F00:9731       	dc.b	'TR$(',TK_STRS			* STR$(
               S01:00E037F4:  54 52 24 28
               S01:00E037F8:  DE
F00:9732       KEY_SWAP
F00:9733       	dc.b	'WAP',TK_SWAP			* SWAP
               S01:00E037F9:  57 41 50
               S01:00E037FC:  B2
F00:9734       	dc.b	$00
               S01:00E037FD:  00
F00:9735       TAB_ASCT
F00:9736       KEY_TAB
F00:9737       	dc.b	'AB(',TK_TAB			* TAB(
               S01:00E037FE:  41 42 28
               S01:00E03801:  B5
F00:9738       KEY_TAN
F00:9739       	dc.b	'AN(',TK_TAN			* TAN
               S01:00E03802:  41 4E 28
               S01:00E03805:  D8
F00:9740       KEY_THEN
F00:9741       	dc.b	'HEN',TK_THEN			* THEN
               S01:00E03806:  48 45 4E
               S01:00E03809:  BA
F00:9742       KEY_TI
F00:9743       	dc.b	'I',TK_TI				* TI
               S01:00E0380A:  49
               S01:00E0380B:  EB
F00:9744       KEY_TO
F00:9745       	dc.b	'O',TK_TO				* TO
               S01:00E0380C:  4F
               S01:00E0380D:  B7
F00:9746       KEY_TWOPI
F00:9747       	dc.b	'WOPI',TK_TWOPI			* TWOPI
               S01:00E0380E:  57 4F 50 49
               S01:00E03812:  ED
F00:9748       	dc.b	$00
               S01:00E03813:  00
F00:9749       TAB_ASCU
F00:9750       KEY_UCASES
F00:9751       	dc.b	'CASE$(',TK_UCASES		* UCASE$(
               S01:00E03814:  43 41 53 45 24 28
               S01:00E0381A:  E1
F00:9752       KEY_UNTIL
F00:9753       	dc.b	'NTIL',TK_UNTIL			* UNTIL
               S01:00E0381B:  4E 54 49 4C
               S01:00E0381F:  BD
F00:9754       KEY_USINGS
F00:9755       	dc.b	'SING$(',TK_USINGS		* USING$(
               S01:00E03820:  53 49 4E 47 24 28
               S01:00E03826:  F3
F00:9756       KEY_USR
F00:9757       	dc.b	'SR(',TK_USR			* USR(
               S01:00E03827:  53 52 28
               S01:00E0382A:  CF
F00:9758       	dc.b	$00
               S01:00E0382B:  00
F00:9759       TAB_ASCV
F00:9760       KEY_VAL
F00:9761       	dc.b	'AL(',TK_VAL			* VAL(
               S01:00E0382C:  41 4C 28
               S01:00E0382F:  DF
F00:9762       KEY_VPTR
F00:9763       	dc.b	'ARPTR(',TK_VPTR			* VARPTR(
               S01:00E03830:  41 52 50 54 52 28
               S01:00E03836:  EE
F00:9764       	dc.b	$00
               S01:00E03837:  00
F00:9765       TAB_ASCW
F00:9766       KEY_WAIT
F00:9767       	dc.b	'AIT',TK_WAIT			* WAIT
               S01:00E03838:  41 49 54
               S01:00E0383B:  94
F00:9768       KEY_WHILE
F00:9769       	dc.b	'HILE',TK_WHILE			* WHILE
               S01:00E0383C:  48 49 4C 45
               S01:00E03840:  BE
F00:9770       KEY_WIDTH
F00:9771       	dc.b	'IDTH',TK_WIDTH			* WIDTH
               S01:00E03841:  49 44 54 48
               S01:00E03845:  B0
F00:9772       	dc.b	$00
               S01:00E03846:  00
F00:9773       TAB_POWR
F00:9774       KEY_POWER
F00:9775       	dc.b	TK_POWER,$00			* ^
               S01:00E03847:  C3
               S01:00E03848:  00
F00:9776       
F00:9777       
F00:9778       *************************************************************************************
F00:9779       *
F00:9780       * just messages
F00:9781       
F00:9782       LAB_BMSG
F00:9783       	dc.b	$0D,$0A,'Break',$00
               S01:00E03849:  0D
               S01:00E0384A:  0A
               S01:00E0384B:  42 72 65 61 6B
               S01:00E03850:  00
F00:9784       LAB_EMSG
F00:9785       	dc.b	' Error',$00
               S01:00E03851:  20 45 72 72 6F 72
               S01:00E03857:  00
F00:9786       LAB_LMSG
F00:9787       	dc.b	' in line ',$00
               S01:00E03858:  20 69 6E 20 6C 69 6E 65 20
               S01:00E03861:  00
F00:9788       LAB_IMSG
F00:9789       	dc.b	'Extra ignored',$0D,$0A,$00
               S01:00E03862:  45 78 74 72 61 20 69 67 6E 6F 72 65 64
               S01:00E0386F:  0D
               S01:00E03870:  0A
               S01:00E03871:  00
F00:9790       LAB_REDO
F00:9791       	dc.b	'Redo from start',$0D,$0A,$00
               S01:00E03872:  52 65 64 6F 20 66 72 6F 6D 20 73 74 61 72 74
               S01:00E03881:  0D
               S01:00E03882:  0A
               S01:00E03883:  00
F00:9792       LAB_RMSG
F00:9793       	dc.b	$0D,$0A,'Ready',$0D,$0A,$00
               S01:00E03884:  0D
               S01:00E03885:  0A
               S01:00E03886:  52 65 61 64 79
               S01:00E0388B:  0D
               S01:00E0388C:  0A
               S01:00E0388D:  00
F00:9794       LAB_SMSG
F00:9795       	dc.b	' Bytes free',$0D,$0A,$0A
               S01:00E0388E:  20 42 79 74 65 73 20 66 72 65 65
               S01:00E03899:  0D
               S01:00E0389A:  0A
               S01:00E0389B:  0A
F00:9796       	dc.b	'Enhanced 68k BASIC Version 3.52',$0D,$0A
               S01:00E0389C:  45 6E 68 61 6E 63 65 64 20 36 38 6B 20 42 41 53
               S01:00E038AC:  49 43 20 56 65 72 73 69 6F 6E 20 33 2E 35 32
               S01:00E038BB:  0D
               S01:00E038BC:  0A
F00:9797       	dc.b	'for 68000 prototype, v1.0',$0D,$0A
               S01:00E038BD:  66 6F 72 20 36 38 30 30 30 20 70 72 6F 74 6F 74
               S01:00E038CD:  79 70 65 2C 20 76 31 2E 30
               S01:00E038D6:  0D
               S01:00E038D7:  0A
F00:9798       	dc.b	'Extension commands Version 2.33',$0D,$0A,$00
               S01:00E038D8:  45 78 74 65 6E 73 69 6F 6E 20 63 6F 6D 6D 61 6E
               S01:00E038E8:  64 73 20 56 65 72 73 69 6F 6E 20 32 2E 33 33
               S01:00E038F7:  0D
               S01:00E038F8:  0A
               S01:00E038F9:  00
F00:9799       
F00:9800       *************************************************************************************
F00:9801       * EhBASIC keywords quick reference list								*
F00:9802       *************************************************************************************
F00:9803       
F00:9804       * glossary
F00:9805       
F00:9806       *		<.>		  required
F00:9807       *		{.|.}		  one of required
F00:9808       *		[.]		  optional
F00:9809       *		...		  may repeat as last
F00:9810       
F00:9811       *		any		= anything
F00:9812       *		num		= number
F00:9813       *		state		= statement
F00:9814       *		pint		= positive integer
F00:9815       *		str		= string
F00:9816       *		var		= variable
F00:9817       *		nvar		= numeric variable
F00:9818       *		svar		= string variable
F00:9819       *		expr		= expression
F00:9820       *		nexpr		= numeric expression
F00:9821       *		sexpr		= string expression
F00:9822       
F00:9823       * statement separator
F00:9824       
F00:9825       * :		. [<state>] : [<state>]						* done
F00:9826       
F00:9827       * number bases
F00:9828       
F00:9829       * %		. %<binary num>							* done
F00:9830       * $		. $<hex num>							* done
F00:9831       
F00:9832       * commands
F00:9833       
F00:9834       * END		. END									* done
F00:9835       * FOR		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
F00:9836       * NEXT	. NEXT [<nvar>[,<nvar>]...]					* done
F00:9837       * DATA	. DATA [{num|["]str["]}[,{num|["]str["]}]...]		* done
F00:9838       * INPUT	. INPUT [<">str<">;] <var>[,<var>[,<var>]...]		* done
F00:9839       * DIM		. DIM <var>(<nexpr>[,<nexpr>[,<nexpr>]])			* done
F00:9840       * READ	. READ <var>[,<var>[,<var>]...]				* done
F00:9841       * LET		. [LET] <var>=<expr>						* done
F00:9842       * DEC		. DEC <nvar>[,<nvar>[,<nvar>]...]				* done
F00:9843       * GOTO	. GOTO <pint>							* done
F00:9844       * RUN		. RUN [pint]							* done
F00:9845       * IF		. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
F00:9846       * RESTORE	. RESTORE [pint]							* done
F00:9847       * GOSUB	. GOSUB <pint>							* done
F00:9848       * RETURN	. RETURN								* done
F00:9849       * REM		. REM [any]								* done
F00:9850       * STOP	. STOP								* done
F00:9851       * ON		. ON <nexpr> {GOTO|GOSUB} <pint>[,<pint>[,<pint>]...]	* done
F00:9852       * NULL	. NULL <nexpr>							* done
F00:9853       * INC		. INC <nvar>[,<nvar>[,<nvar>]...]				* done
F00:9854       * WAIT	. WAIT <nexpr>,<nexpr>[,<nexpr>]				* done
F00:9855       * LOAD	. LOAD [<sexpr>]							* done for simulator
F00:9856       * SAVE	. SAVE [<sexpr>][,[<n>][-<n>]]				* done for simulator
F00:9857       * DEF		. DEF FN<var>(<var>)=<expr>					* done
F00:9858       * POKE	. POKE <nexpr>,<nexpr>						* done
F00:9859       * DOKE	. DOKE <nexpr>,<nexpr>						* done
F00:9860       * LOKE	. LOKE <nexpr>,<nexpr>						* done
F00:9861       * CALL	. CALL <nexpr>							* done
F00:9862       * DO		. DO									* done
F00:9863       * LOOP	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
F00:9864       * PRINT	. PRINT [{;|,}][expr][{;|,}[expr][{;|,}[expr]]...]	* done
F00:9865       * CONT	. CONT								* done
F00:9866       * LIST	. LIST [pint][-pint]						* done
F00:9867       * CLEAR	. CLEAR								* done
F00:9868       * NEW		. NEW									* done
F00:9869       * WIDTH	. WIDTH [<pint>][,<pint>]					* done
F00:9870       * GET		. GET <var>								* done
F00:9871       * SWAP	. SWAP <var>,<var>						* done
F00:9872       * BITSET	. BITSET <nexpr>,<nexpr>					* done
F00:9873       * BITCLR	. BITCLR <nexpr>,<nexpr>					* done
F00:9874       
F00:9875       * new graphics commands for EASy68k
F00:9876       
F00:9877       * BUFFER	. BUFFER								* done
F00:9878       * CLS		. CLS									* done
F00:9879       * CURSOR	. CURSOR <nexpr>,<nexpr>					* done
F00:9880       * LINE	. LINE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,][<nexpr>]	* done
F00:9881       * FILL	. FILL <nexpr>,<nexpr>[,][<nexpr>]				* done
F00:9882       * MOVE	. MOVE <nexpr>,<nexpr>						* done
F00:9883       * POINT	. POINT <nexpr>,<nexpr>[,][<nexpr>]				* done
F00:9884       * RECT	. RECT <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]	* done
F00:9885       * RECTF	. RECTF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]	* done
F00:9886       * ELLIPSE	. ELLIPSE <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]	* done
F00:9887       * ELLIPSEF	. ELLIPSEF <nexpr>,<nexpr>[,<nexpr>,<nexpr>][,<nexpr>[,<nexpr>]]	* done
F00:9888       * MODE	. MODE <pint>							* done
F00:9889       * SIZE	. SIZE <pint>							* done
F00:9890       
F00:9891       * sub commands (may not start a statement)
F00:9892       
F00:9893       * TAB		. TAB(<nexpr>)							* done
F00:9894       * ELSE	. IF <expr>{GOTO<n>|THEN<{n|comm}>}[ELSE <{n|comm}>]	* done
F00:9895       * TO		. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
F00:9896       * FN		. FN<var>(<expr>)							* done
F00:9897       * SPC		. SPC(<nexpr>)							* done
F00:9898       * THEN	. IF <nexpr> {THEN {pint|comm}|GOTO <pint>}		* done
F00:9899       * NOT		. NOT <nexpr>							* done
F00:9900       * STEP	. FOR <nvar>=<nexpr> TO <nexpr> [STEP <nexpr>]		* done
F00:9901       * UNTIL	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
F00:9902       * WHILE	. LOOP [{WHILE|UNTIL}<nexpr>]					* done
F00:9903       
F00:9904       * operators
F00:9905       
F00:9906       * +		. [expr] + <expr>							* done
F00:9907       * -		. [nexpr] - <nexpr>						* done
F00:9908       * *		. <nexpr> * <nexpr>						* done fast hardware
F00:9909       * /		. <nexpr> / <nexpr>						* done fast hardware
F00:9910       * ^		. <nexpr> ^ <nexpr>						* done
F00:9911       * AND		. <nexpr> AND <nexpr>						* done
F00:9912       * EOR		. <nexpr> EOR <nexpr>						* done
F00:9913       * OR		. <nexpr> OR <nexpr>						* done
F00:9914       * >>		. <nexpr> >> <nexpr>						* done
F00:9915       * <<		. <nexpr> << <nexpr>						* done
F00:9916       
F00:9917       * compare functions
F00:9918       
F00:9919       * <		. <expr> < <expr>							* done
F00:9920       * =		. <expr> = <expr>							* done
F00:9921       * >		. <expr> > <expr>							* done
F00:9922       
F00:9923       * functions
F00:9924       
F00:9925       * SGN		. SGN(<nexpr>)							* done
F00:9926       * INT		. INT(<nexpr>)							* done
F00:9927       * ABS		. ABS(<nexpr>)							* done
F00:9928       * USR		. USR(<expr>)							* done
F00:9929       * FRE		. FRE(<expr>)							* done
F00:9930       * POS		. POS(<expr>)							* done
F00:9931       * SQR		. SQR(<nexpr>)							* done fast shift/sub
F00:9932       * RND		. RND(<nexpr>)							* done 32 bit PRNG
F00:9933       * LOG		. LOG(<nexpr>)							* done fast cordic
F00:9934       * EXP		. EXP(<nexpr>)							* done fast cordic
F00:9935       * COS		. COS(<nexpr>)							* done fast cordic
F00:9936       * SIN		. SIN(<nexpr>)							* done fast cordic
F00:9937       * TAN		. TAN(<nexpr>)							* done fast cordic
F00:9938       * ATN		. ATN(<nexpr>)							* done fast cordic
F00:9939       * PEEK	. PEEK(<nexpr>)							* done
F00:9940       * DEEK	. DEEK(<nexpr>)							* done
F00:9941       * LEEK	. LEEK(<nexpr>)							* done
F00:9942       * LEN		. LEN(<sexpr>)							* done
F00:9943       * STR$	. STR$(<nexpr>)							* done
F00:9944       * VAL		. VAL(<sexpr>)							* done
F00:9945       * ASC		. ASC(<sexpr>)							* done
F00:9946       * UCASE$	. UCASE$(<sexpr>)							* done
F00:9947       * LCASE$	. LCASE$(<sexpr>)							* done
F00:9948       * CHR$	. CHR$(<nexpr>)							* done
F00:9949       * HEX$	. HEX$(<nexpr>)							* done
F00:9950       * BIN$	. BIN$(<nexpr>)							* done
F00:9951       * BTST	. BTST(<nexpr>,<nexpr>)						* done
F00:9952       * MAX		. MAX(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
F00:9953       * MIN		. MIN(<nexpr>[,<nexpr>[,<nexpr>]...])			* done
F00:9954       * KEYS	. KEYS(<expr>)							* done for simulator
F00:9955       * TI		. TI									* done for simulator
F00:9956       * PI		. PI									* done
F00:9957       * TWOPI	. TWOPI								* done
F00:9958       * VARPTR	. VARPTR(<var>)							* done
F00:9959       * SADD	. SADD(<svar>)							* done
F00:9960       * LEFT$	. LEFT$(<sexpr>,<nexpr>)					* done
F00:9961       * RIGHT$	. RIGHT$(<sexpr>,<nexpr>)					* done
F00:9962       * MID$	. MID$(<sexpr>,<nexpr>[,<nexpr>])				* done
F00:9963       * USING$	. USING$(<sexpr>,<nexpr>[,<nexpr>]...])			* done
F00:9964       
F00:9965       * New functions for EASy68k
F00:9966       
F00:9967       * POINT	. POINT(<nexpr>,<nexpr>)					* done
F00:9968       
F00:9969       
F00:9970       *************************************************************************************
F00:9971       
F00:9972       	END	code_start
F00:9973       
F00:9974       *************************************************************************************
F00:9975       
F00:9976       
F00:9977       
F00:9978       *~Font name~Courier New~
F00:9979       *~Font size~10~
F00:9980       *~Tab type~1~
F00:9981       *~Tab size~8~
F00:9982       


Sections:
S01  CODE


Sources:
F00  basic68k.asm
F01  basic68k.inc


Symbols:
LAB_FO EXPR(14693967=0xe0364f) ABS 
LAB_AD EXPR(14693959=0xe03647) ABS 
LAB_WD EXPR(14693942=0xe03636) ABS 
LAB_UA EXPR(14693922=0xe03622) ABS 
LAB_UV EXPR(14693903=0xe0360f) ABS 
LAB_LD EXPR(14693887=0xe035ff) ABS 
LAB_UF EXPR(14693868=0xe035ec) ABS 
LAB_CN EXPR(14693853=0xe035dd) ABS 
LAB_ST EXPR(14693834=0xe035ca) ABS 
LAB_LS EXPR(14693818=0xe035ba) ABS 
LAB_TM EXPR(14693804=0xe035ac) ABS 
LAB_ID EXPR(14693789=0xe0359d) ABS 
LAB_D0 EXPR(14693774=0xe0358e) ABS 
LAB_DD EXPR(14693757=0xe0357d) ABS 
LAB_BS EXPR(14693744=0xe03570) ABS 
LAB_US EXPR(14693724=0xe0355c) ABS 
LAB_OM EXPR(14693710=0xe0354e) ABS 
LAB_OV EXPR(14693701=0xe03545) ABS 
LAB_FC EXPR(14693687=0xe03537) ABS 
LAB_OD EXPR(14693675=0xe0352b) ABS 
LAB_RG EXPR(14693654=0xe03516) ABS 
LAB_SN EXPR(14693647=0xe0350f) ABS 
LAB_NF EXPR(14693630=0xe034fe) ABS 
KEY_USINGS EXPR(14694432=0xe03820) ABS 
KEY_MIDS EXPR(14694236=0xe0375c) ABS 
KEY_RIGHTS EXPR(14694336=0xe037c0) ABS 
KEY_LEFTS EXPR(14694194=0xe03732) ABS 
KEY_SADD EXPR(14694351=0xe037cf) ABS 
KEY_VPTR EXPR(14694448=0xe03830) ABS 
KEY_TWOPI EXPR(14694414=0xe0380e) ABS 
KEY_PI EXPR(14694279=0xe03787) ABS 
KEY_TI EXPR(14694410=0xe0380a) ABS 
KEY_KEYS EXPR(14694176=0xe03720) ABS 
KEY_RAM EXPR(14694300=0xe0379c) ABS 
KEY_MIN EXPR(14694241=0xe03761) ABS 
KEY_MAX EXPR(14694232=0xe03758) ABS 
KEY_BITTST EXPR(14694027=0xe0368b) ABS 
KEY_BINS EXPR(14694010=0xe0367a) ABS 
KEY_HEXS EXPR(14694155=0xe0370b) ABS 
KEY_CHRS EXPR(14694045=0xe0369d) ABS 
KEY_LCASES EXPR(14694182=0xe03726) ABS 
KEY_UCASES EXPR(14694420=0xe03814) ABS 
KEY_ASC EXPR(14694001=0xe03671) ABS 
KEY_VAL EXPR(14694444=0xe0382c) ABS 
KEY_STRS EXPR(14694388=0xe037f4) ABS 
KEY_LEN EXPR(14694200=0xe03738) ABS 
KEY_LEEK EXPR(14694189=0xe0372d) ABS 
KEY_DEEK EXPR(14694080=0xe036c0) ABS 
KEY_PEEK EXPR(14694274=0xe03782) ABS 
KEY_ATN EXPR(14694005=0xe03675) ABS 
KEY_TAN EXPR(14694402=0xe03802) ABS 
KEY_SIN EXPR(14694364=0xe037dc) ABS 
KEY_COS EXPR(14694062=0xe036ae) ABS 
KEY_EXP EXPR(14694123=0xe036eb) ABS 
KEY_LOG EXPR(14694219=0xe0374b) ABS 
KEY_RND EXPR(14694343=0xe037c7) ABS 
KEY_SQR EXPR(14694376=0xe037e8) ABS 
KEY_POS EXPR(14694290=0xe03792) ABS 
KEY_FRE EXPR(14694137=0xe036f9) ABS 
KEY_USR EXPR(14694439=0xe03827) ABS 
KEY_ABS EXPR(14693994=0xe0366a) ABS 
KEY_INT EXPR(14694171=0xe0371b) ABS 
KEY_SGN EXPR(14694360=0xe037d8) ABS 
KEY_LT EXPR(14693984=0xe03660) ABS 
KEY_EQUAL EXPR(14693986=0xe03662) ABS 
KEY_GT EXPR(14693990=0xe03666) ABS 
KEY_LSHIFT EXPR(14693982=0xe0365e) ABS 
KEY_RSHIFT EXPR(14693988=0xe03664) ABS 
KEY_OR EXPR(14694271=0xe0377f) ABS 
KEY_EOR EXPR(14694120=0xe036e8) ABS 
KEY_AND EXPR(14693998=0xe0366e) ABS 
KEY_POWER EXPR(14694471=0xe03847) ABS 
KEY_DIV EXPR(14693980=0xe0365c) ABS 
KEY_MULT EXPR(14693974=0xe03656) ABS 
KEY_MINUS EXPR(14693978=0xe0365a) ABS 
KEY_PLUS EXPR(14693976=0xe03658) ABS 
KEY_WHILE EXPR(14694460=0xe0383c) ABS 
KEY_UNTIL EXPR(14694427=0xe0381b) ABS 
KEY_STEP EXPR(14694380=0xe037ec) ABS 
KEY_NOT EXPR(14694261=0xe03775) ABS 
KEY_THEN EXPR(14694406=0xe03806) ABS 
KEY_SPC EXPR(14694372=0xe037e4) ABS 
KEY_FN EXPR(14694135=0xe036f7) ABS 
KEY_TO EXPR(14694412=0xe0380c) ABS 
KEY_ELSE EXPR(14694098=0xe036d2) ABS 
KEY_TAB EXPR(14694398=0xe037fe) ABS 
KEY_BITCLR EXPR(14694015=0xe0367f) ABS 
KEY_BITSET EXPR(14694021=0xe03685) ABS 
KEY_SWAP EXPR(14694393=0xe037f9) ABS 
KEY_GET EXPR(14694142=0xe036fe) ABS 
KEY_WIDTH EXPR(14694465=0xe03841) ABS 
KEY_NEW EXPR(14694254=0xe0376e) ABS 
KEY_CLEAR EXPR(14694050=0xe036a2) ABS 
KEY_LIST EXPR(14694211=0xe03743) ABS 
KEY_SIZE EXPR(14694368=0xe037e0) ABS 
KEY_MODE EXPR(14694245=0xe03765) ABS 
KEY_FELLIPSE EXPR(14694105=0xe036d9) ABS 
KEY_ELLIPSE EXPR(14694113=0xe036e1) ABS 
KEY_FRECT EXPR(14694311=0xe037a7) ABS 
KEY_RECT EXPR(14694316=0xe037ac) ABS 
KEY_POINT EXPR(14694281=0xe03789) ABS 
KEY_MOVE EXPR(14694249=0xe03769) ABS 
KEY_FILL EXPR(14694128=0xe036f0) ABS 
KEY_LINE EXPR(14694207=0xe0373f) ABS 
KEY_CURSOR EXPR(14694066=0xe036b2) ABS 
KEY_CLS EXPR(14694055=0xe036a7) ABS 
KEY_BUFFER EXPR(14694034=0xe03692) ABS 
KEY_CONT EXPR(14694058=0xe036aa) ABS 
KEY_PRINT EXPR(14694294=0xe03796) ABS 
KEY_LOOP EXPR(14694227=0xe03753) ABS 
KEY_DO EXPR(14694095=0xe036cf) ABS 
KEY_CALL EXPR(14694041=0xe03699) ABS 
KEY_LOKE EXPR(14694223=0xe0374f) ABS 
KEY_DOKE EXPR(14694091=0xe036cb) ABS 
KEY_POKE EXPR(14694286=0xe0378e) ABS 
KEY_DEF EXPR(14694085=0xe036c5) ABS 
KEY_SAVE EXPR(14694356=0xe037d4) ABS 
KEY_LOAD EXPR(14694215=0xe03747) ABS 
KEY_WAIT EXPR(14694456=0xe03838) ABS 
KEY_INC EXPR(14694163=0xe03713) ABS 
KEY_NULL EXPR(14694264=0xe03778) ABS 
KEY_ON EXPR(14694269=0xe0377d) ABS 
KEY_STOP EXPR(14694384=0xe037f0) ABS 
KEY_REM EXPR(14694320=0xe037b0) ABS 
KEY_RETURN EXPR(14694330=0xe037ba) ABS 
KEY_GOSUB EXPR(14694149=0xe03705) ABS 
KEY_RESTORE EXPR(14694323=0xe037b3) ABS 
KEY_IF EXPR(14694161=0xe03711) ABS 
KEY_RUN EXPR(14694347=0xe037cb) ABS 
KEY_GOTO EXPR(14694145=0xe03701) ABS 
KEY_DEC EXPR(14694077=0xe036bd) ABS 
KEY_LET EXPR(14694204=0xe0373c) ABS 
KEY_READ EXPR(14694307=0xe037a3) ABS 
KEY_DIM EXPR(14694088=0xe036c8) ABS 
KEY_INPUT EXPR(14694166=0xe03716) ABS 
KEY_DATA EXPR(14694073=0xe036b9) ABS 
KEY_NEXT EXPR(14694257=0xe03771) ABS 
KEY_FOR EXPR(14694132=0xe036f4) ABS 
KEY_END EXPR(14694102=0xe036d6) ABS 
TAB_POWR EXPR(14694471=0xe03847) ABS 
TAB_ASCW EXPR(14694456=0xe03838) ABS 
TAB_ASCV EXPR(14694444=0xe0382c) ABS 
TAB_ASCU EXPR(14694420=0xe03814) ABS 
TAB_ASCT EXPR(14694398=0xe037fe) ABS 
TAB_ASCS EXPR(14694351=0xe037cf) ABS 
TAB_ASCR EXPR(14694300=0xe0379c) ABS 
TAB_ASCP EXPR(14694274=0xe03782) ABS 
TAB_ASCO EXPR(14694269=0xe0377d) ABS 
TAB_ASCN EXPR(14694254=0xe0376e) ABS 
TAB_ASCM EXPR(14694232=0xe03758) ABS 
TAB_ASCL EXPR(14694182=0xe03726) ABS 
TAB_ASCK EXPR(14694176=0xe03720) ABS 
TAB_ASCI EXPR(14694161=0xe03711) ABS 
TAB_ASCH EXPR(14694155=0xe0370b) ABS 
TAB_ASCG EXPR(14694142=0xe036fe) ABS 
TAB_ASCF EXPR(14694128=0xe036f0) ABS 
TAB_ASCE EXPR(14694098=0xe036d2) ABS 
TAB_ASCD EXPR(14694073=0xe036b9) ABS 
TAB_ASCC EXPR(14694041=0xe03699) ABS 
TAB_ASCB EXPR(14694010=0xe0367a) ABS 
TAB_ASCA EXPR(14693994=0xe0366a) ABS 
TAB_QEST EXPR(14693992=0xe03668) ABS 
TAB_MORE EXPR(14693988=0xe03664) ABS 
TAB_EQUL EXPR(14693986=0xe03662) ABS 
TAB_LESS EXPR(14693982=0xe0365e) ABS 
TAB_SLAS EXPR(14693980=0xe0365c) ABS 
TAB_MNUS EXPR(14693978=0xe0365a) ABS 
TAB_PLUS EXPR(14693976=0xe03658) ABS 
n EXPR(2=0x2) EQU 
LAB_1D96 EXPR(14692532=0xe030b4) UNUSED ABS 
TK_USINGS EXPR(243=0xf3) EQU 
TK_MIDS EXPR(242=0xf2) EQU 
TK_RIGHTS EXPR(241=0xf1) EQU 
TK_LEFTS EXPR(240=0xf0) EQU 
TK_SADD EXPR(239=0xef) EQU 
TK_VPTR EXPR(238=0xee) EQU 
TK_TWOPI EXPR(237=0xed) EQU 
TK_PI EXPR(236=0xec) EQU 
TK_TI EXPR(235=0xeb) EQU 
TK_KEYS EXPR(234=0xea) EQU 
TK_RAM EXPR(233=0xe9) EQU 
TK_MIN EXPR(232=0xe8) EQU 
TK_MAX EXPR(231=0xe7) EQU 
TK_BITTST EXPR(230=0xe6) EQU 
TK_BINS EXPR(229=0xe5) EQU 
TK_HEXS EXPR(228=0xe4) EQU 
TK_CHRS EXPR(227=0xe3) EQU 
TK_LCASES EXPR(226=0xe2) EQU 
TK_UCASES EXPR(225=0xe1) EQU 
TK_ASC EXPR(224=0xe0) EQU 
TK_VAL EXPR(223=0xdf) EQU 
TK_STRS EXPR(222=0xde) EQU 
TK_LEN EXPR(221=0xdd) EQU 
TK_LEEK EXPR(220=0xdc) EQU 
TK_DEEK EXPR(219=0xdb) EQU 
TK_PEEK EXPR(218=0xda) EQU 
TK_ATN EXPR(217=0xd9) EQU 
TK_TAN EXPR(216=0xd8) EQU 
TK_SIN EXPR(215=0xd7) EQU 
TK_COS EXPR(214=0xd6) EQU 
TK_EXP EXPR(213=0xd5) EQU 
TK_LOG EXPR(212=0xd4) EQU 
TK_RND EXPR(211=0xd3) EQU 
TK_SQR EXPR(210=0xd2) EQU 
TK_POS EXPR(209=0xd1) EQU 
TK_FRE EXPR(208=0xd0) EQU 
TK_USR EXPR(207=0xcf) EQU 
TK_ABS EXPR(206=0xce) EQU 
TK_INT EXPR(205=0xcd) EQU 
TK_LSHIFT EXPR(200=0xc8) EQU 
TK_RSHIFT EXPR(199=0xc7) EQU 
TK_OR EXPR(198=0xc6) EQU 
TK_EOR EXPR(197=0xc5) EQU 
TK_AND EXPR(196=0xc4) EQU 
TK_POWER EXPR(195=0xc3) EQU 
TK_DIV EXPR(194=0xc2) EQU 
TK_MULT EXPR(193=0xc1) EQU 
TK_WHILE EXPR(190=0xbe) EQU 
TK_BITCLR EXPR(180=0xb4) EQU 
TK_BITSET EXPR(179=0xb3) EQU 
TK_SWAP EXPR(178=0xb2) EQU 
TK_GET EXPR(177=0xb1) EQU 
TK_WIDTH EXPR(176=0xb0) EQU 
TK_NEW EXPR(175=0xaf) EQU 
TK_CLEAR EXPR(174=0xae) EQU 
TK_LIST EXPR(173=0xad) EQU 
TK_SIZE EXPR(172=0xac) EQU 
TK_MODE EXPR(171=0xab) EQU 
TK_FELLIPSE EXPR(170=0xaa) EQU 
TK_ELLIPSE EXPR(169=0xa9) EQU 
TK_FRECT EXPR(168=0xa8) EQU 
TK_RECT EXPR(167=0xa7) EQU 
TK_MOVE EXPR(165=0xa5) EQU 
TK_FILL EXPR(164=0xa4) EQU 
TK_LINE EXPR(163=0xa3) EQU 
TK_CURSOR EXPR(162=0xa2) EQU 
TK_CLS EXPR(161=0xa1) EQU 
TK_BUFFER EXPR(160=0xa0) EQU 
TK_CONT EXPR(159=0x9f) EQU 
TK_PRINT EXPR(158=0x9e) EQU 
TK_LOOP EXPR(157=0x9d) EQU 
TK_CALL EXPR(155=0x9b) EQU 
TK_LOKE EXPR(154=0x9a) EQU 
TK_DOKE EXPR(153=0x99) EQU 
TK_POKE EXPR(152=0x98) EQU 
TK_DEF EXPR(151=0x97) EQU 
TK_SAVE EXPR(150=0x96) EQU 
TK_LOAD EXPR(149=0x95) EQU 
TK_WAIT EXPR(148=0x94) EQU 
TK_INC EXPR(147=0x93) EQU 
TK_NULL EXPR(146=0x92) EQU 
TK_ON EXPR(145=0x91) EQU 
TK_STOP EXPR(144=0x90) EQU 
TK_RESTORE EXPR(140=0x8c) EQU 
TK_RUN EXPR(138=0x8a) EQU 
TK_DEC EXPR(136=0x88) EQU 
TK_LET EXPR(135=0x87) EQU 
TK_READ EXPR(134=0x86) EQU 
TK_DIM EXPR(133=0x85) EQU 
TK_INPUT EXPR(132=0x84) EQU 
TK_NEXT EXPR(130=0x82) EQU 
TK_END EXPR(128=0x80) EQU 
RTS_025 EXPR(14691772=0xe02dbc) ABS 
LAB_CBX1 EXPR(14691702=0xe02d76) ABS 
d1x02 EXPR(14691736=0xe02d98) ABS 
LAB_CBXN EXPR(14691684=0xe02d64) ABS 
RTS_024 EXPR(14691674=0xe02d5a) ABS 
LAB_CHX2 EXPR(14691652=0xe02d44) ABS 
LAB_exxf EXPR(14691658=0xe02d4a) ABS 
LAB_CHX1 EXPR(14691616=0xe02d20) ABS 
d1x16 EXPR(14691722=0xe02d8a) ABS 
LAB_CHX3 EXPR(14691644=0xe02d3c) ABS 
LAB_ISHN EXPR(14691612=0xe02d1c) ABS 
LAB_CHXX EXPR(14691586=0xe02d02) ABS 
LAB_ret0 EXPR(14691560=0xe02ce8) ABS 
LAB_2Y03 EXPR(14691484=0xe02c9c) ABS 
LAB_2Y04 EXPR(14691490=0xe02ca2) ABS 
LAB_rtn0 EXPR(14691562=0xe02cea) ABS 
LAB_2Y02 EXPR(14691472=0xe02c90) ABS 
LAB_2903 EXPR(14691448=0xe02c78) ABS 
LAB_2X05 EXPR(14691432=0xe02c68) ABS 
LAB_2X03 EXPR(14691404=0xe02c4c) ABS 
LAB_2X02 EXPR(14691390=0xe02c3e) ABS 
LAB_2X01 EXPR(14691382=0xe02c36) ABS 
LAB_2X04 EXPR(14691410=0xe02c52) ABS 
LAB_2900 EXPR(14691352=0xe02c18) ABS 
LAB_2901 EXPR(14691358=0xe02c1e) ABS 
LAB_28FF EXPR(14691338=0xe02c0a) ABS 
d1x10 EXPR(14691758=0xe02dae) ABS 
LAB_2902 EXPR(14691440=0xe02c70) ABS 
LAB_28FD EXPR(14691326=0xe02bfe) ABS 
LAB_2Y01 EXPR(14691464=0xe02c88) ABS 
LAB_CBIN EXPR(14691676=0xe02d5c) ABS 
LAB_CHEX EXPR(14691578=0xe02cfa) ABS 
LAB_2904 EXPR(14691450=0xe02c7a) ABS 
LAB_289D EXPR(14691298=0xe02be2) ABS 
LAB_289C EXPR(14691292=0xe02bdc) ABS 
LAB_289A EXPR(14691286=0xe02bd6) ABS 
LAB_28FE EXPR(14691332=0xe02c04) ABS 
LAB_TWOPI EXPR(14691228=0xe02b9c) ABS 
LAB_PI EXPR(14691212=0xe02b8c) ABS 
LAB_RAM EXPR(14691202=0xe02b82) ABS 
LAB_VARPTR EXPR(14691186=0xe02b72) ABS 
LAB_SQNA EXPR(14691170=0xe02b62) ABS 
LAB_SQNS EXPR(14691148=0xe02b4c) ABS 
LAB_SQE1 EXPR(14691124=0xe02b34) ABS 
LAB_SQE2 EXPR(14691130=0xe02b3a) ABS 
LAB_SQR EXPR(14691088=0xe02b10) ABS 
RTS_023 EXPR(14691086=0xe02b0e) ABS 
LAB_WDLP EXPR(14691062=0xe02af6) ABS 
LAB_SVTB EXPR(14691042=0xe02ae2) ABS 
WExit EXPR(14691046=0xe02ae6) ABS 
LAB_NSTT EXPR(14690992=0xe02ab0) ABS 
LAB_TBSZ EXPR(14691010=0xe02ac2) ABS 
LAB_WDTH EXPR(14690960=0xe02a90) ABS 
LAB_MMEC EXPR(14690892=0xe02a4c) ABS 
LAB_MINN EXPR(14690882=0xe02a42) ABS 
LAB_MIN EXPR(14690870=0xe02a36) ABS 
LAB_PHFA EXPR(14690906=0xe02a5a) ABS 
LAB_MAXN EXPR(14690860=0xe02a2c) ABS 
LAB_MAX EXPR(14690848=0xe02a20) ABS 
LAB_FB95 EXPR(14690836=0xe02a14) ABS 
LAB_FBA0 EXPR(14690808=0xe029f8) ABS 
RTS_022 EXPR(14690818=0xe02a02) ABS 
NextH1 EXPR(14690756=0xe029c4) ABS 
LAB_HEXS EXPR(14690740=0xe029b4) ABS 
GoPr EXPR(14690736=0xe029b0) ABS 
BinPr EXPR(14690726=0xe029a6) ABS 
NextB2 EXPR(14690712=0xe02998) ABS 
EndBHS EXPR(14690688=0xe02980) ABS 
NextB1 EXPR(14690674=0xe02972) ABS 
LAB_BINS EXPR(14690658=0xe02962) ABS 
LAB_P01E EXPR(14690648=0xe02958) ABS 
LAB_P018 EXPR(14690636=0xe0294c) ABS 
LAB_P010 EXPR(14690610=0xe02932) ABS 
LAB_P00E EXPR(14690606=0xe0292e) ABS 
LAB_P00C EXPR(14690594=0xe02922) ABS 
LAB_P008 EXPR(14690586=0xe0291a) ABS 
LAB_P01A EXPR(14690640=0xe02950) ABS 
LAB_P004 EXPR(14690564=0xe02904) ABS 
LAB_D00E EXPR(14690534=0xe028e6) ABS 
LAB_D00A EXPR(14690518=0xe028d6) ABS 
LAB_D002 EXPR(14690502=0xe028c6) ABS 
LAB_U04C EXPR(14690436=0xe02884) ABS 
LAB_U048 EXPR(14690376=0xe02848) ABS 
LAB_U046 EXPR(14690374=0xe02846) ABS 
LAB_U044 EXPR(14690334=0xe0281e) ABS 
LAB_U04A EXPR(14690386=0xe02852) ABS 
LAB_U040 EXPR(14690318=0xe0280e) ABS 
LAB_U038 EXPR(14690280=0xe027e8) ABS 
LAB_U034 EXPR(14690266=0xe027da) ABS 
LAB_U02E EXPR(14690240=0xe027c0) ABS 
LAB_U030 EXPR(14690244=0xe027c4) ABS 
LAB_U03C EXPR(14690288=0xe027f0) ABS 
LAB_U036 EXPR(14690272=0xe027e0) ABS 
LAB_U02C EXPR(14690222=0xe027ae) ABS 
LAB_U02B EXPR(14690216=0xe027a8) ABS 
LAB_U03E EXPR(14690294=0xe027f6) ABS 
LAB_U02A EXPR(14690192=0xe02790) ABS 
LAB_U026 EXPR(14690182=0xe02786) ABS 
LAB_U020 EXPR(14690160=0xe02770) ABS 
LAB_U01C EXPR(14690148=0xe02764) ABS 
LAB_U022 EXPR(14690166=0xe02776) ABS 
LAB_U018 EXPR(14690126=0xe0274e) ABS 
LAB_U014 EXPR(14690118=0xe02746) ABS 
LAB_U00E EXPR(14690096=0xe02730) ABS 
LAB_U00F EXPR(14690108=0xe0273c) ABS 
LAB_U00D EXPR(14690078=0xe0271e) ABS 
LAB_U00C EXPR(14690074=0xe0271a) ABS 
LAB_U00B EXPR(14690054=0xe02706) ABS 
LAB_U00A EXPR(14690044=0xe026fc) ABS 
LAB_U009 EXPR(14690036=0xe026f4) ABS 
LAB_U008 EXPR(14690002=0xe026d2) ABS 
LAB_U010 EXPR(14690112=0xe02740) ABS 
LAB_U006 EXPR(14689982=0xe026be) ABS 
LAB_U005 EXPR(14689980=0xe026bc) ABS 
LAB_DupFmt EXPR(14690478=0xe028ae) ABS 
LAB_P_10 EXPR(14692046=0xe02ece) ABS 
LAB_U004 EXPR(14689964=0xe026ac) ABS 
LAB_ProcFo EXPR(14690540=0xe028ec) ABS 
LAB_U002 EXPR(14689878=0xe02656) ABS 
LAB_USINGS EXPR(14689836=0xe0262c) ABS 
ofchr EXPR(35=0x23) EQU 
fend EXPR(8=0x8) EQU 
fsdc EXPR(10=0xa) EQU 
fsdpi EXPR(8=0x8) EQU 
fsli EXPR(6=0x6) EQU 
fsti EXPR(4=0x4) EQU 
fsd EXPR(0=0x0) EQU 
LAB_BTST EXPR(14689790=0xe025fe) ABS 
LAB_BITCLR EXPR(14689774=0xe025ee) ABS 
LAB_BITSET EXPR(14689758=0xe025de) ABS 
LAB_CATN EXPR(14689682=0xe02592) ABS 
LAB_ATNP EXPR(14689670=0xe02586) ABS 
LAB_ATCD EXPR(14689676=0xe0258c) ABS 
TAB_ATNC EXPR(14692412=0xe0303c) ABS 
LAB_ATGO EXPR(14689610=0xe0254a) ABS 
LAB_ATLE EXPR(14689640=0xe02568) ABS 
RTS_021 EXPR(14689756=0xe025dc) ABS 
LAB_ATN EXPR(14689580=0xe0252c) ABS 
subexit EXPR(14689568=0xe02520) ABS 
nexta EXPR(14689544=0xe02508) ABS 
subloop EXPR(14689518=0xe024ee) ABS 
mainloop EXPR(14689526=0xe024f6) ABS 
LAB_LTPT EXPR(14689502=0xe024de) ABS 
LAB_LTPF EXPR(14689490=0xe024d2) ABS 
outloop EXPR(14689558=0xe02516) ABS 
LAB_CORD EXPR(14689476=0xe024c4) ABS 
LAB_SCL0 EXPR(14689466=0xe024ba) ABS 
TAB_SNCO EXPR(14692284=0xe02fbc) ABS 
LAB_SCZE EXPR(14689452=0xe024ac) ABS 
LAB_COS EXPR(14689364=0xe02454) ABS 
LAB_SIN EXPR(14689388=0xe0246c) ABS 
LAB_TAN EXPR(14689330=0xe02432) ABS 
Ninc1 EXPR(14689308=0xe0241c) ABS 
Ninc0 EXPR(14689302=0xe02416) ABS 
NextPRN EXPR(14689294=0xe0240e) ABS 
LAB_EXAD EXPR(14689268=0xe023f4) ABS 
LAB_EXNN EXPR(14689222=0xe023c6) ABS 
LAB_EXRN EXPR(14689228=0xe023cc) ABS 
LAB_EXPL EXPR(14689216=0xe023c0) ABS 
LAB_EXCC EXPR(14689242=0xe023da) ABS 
KFCTSEED EXPR(-425471728=0xe6a3d110) EQU 
LAB_ESML EXPR(14689130=0xe0236a) ABS 
LAB_EXPS EXPR(14689054=0xe0231e) ABS 
LAB_EXCM EXPR(14689036=0xe0230c) ABS 
LAB_EXOL EXPR(14688988=0xe022dc) ABS 
LAB_EXOF EXPR(14688966=0xe022c6) ABS 
LAB_EXOU EXPR(14688946=0xe022b2) ABS 
LAB_EX1 EXPR(14688930=0xe022a2) ABS 
RTS_020 EXPR(14688928=0xe022a0) ABS 
LAB_GTHAN EXPR(14688916=0xe02294) ABS 
LAB_EXP EXPR(14688998=0xe022e6) ABS 
LAB_POWP EXPR(14688866=0xe02262) ABS 
LAB_POWER EXPR(14688816=0xe02230) ABS 
LAB_POON EXPR(14688788=0xe02214) ABS 
LAB_27F2 EXPR(14688784=0xe02210) ABS 
LAB_27F3 EXPR(14688786=0xe02212) ABS 
LAB_27F1 EXPR(14688778=0xe0220a) ABS 
LAB_2A91 EXPR(14688752=0xe021f0) ABS 
LAB_2A74 EXPR(14688714=0xe021ca) ABS 
LAB_2A68 EXPR(14688702=0xe021be) ABS 
LAB_2A8C EXPR(14688746=0xe021ea) ABS 
LAB_2A58 EXPR(14688678=0xe021a6) ABS 
LAB_2A4B EXPR(14688658=0xe02192) ABS 
LAB_2A9B EXPR(14693014=0xe03296) ABS 
LAB_2A3B EXPR(14688644=0xe02184) ABS 
LAB_2A21 EXPR(14688612=0xe02164) ABS 
LAB_2A1A EXPR(14688604=0xe0215c) ABS 
LAB_2A18 EXPR(14688602=0xe0215a) ABS 
LAB_29FD EXPR(14688586=0xe0214a) ABS 
LAB_2A9A EXPR(14692986=0xe0327a) ABS 
LAB_29FB EXPR(14688578=0xe02142) ABS 
LAB_29F7 EXPR(14688574=0xe0213e) ABS 
LAB_29E4 EXPR(14688554=0xe0212a) ABS 
LAB_29D9 EXPR(14688536=0xe02118) ABS 
LAB_29B7 EXPR(14688472=0xe020d8) ABS 
LAB_29C0 EXPR(14688486=0xe020e6) ABS 
LAB_29A7 EXPR(14688448=0xe020c0) ABS 
LAB_29C3 EXPR(14688510=0xe020fe) ABS 
LAB_27F0 EXPR(14688756=0xe021f4) ABS 
LAB_29B9 EXPR(14688368=0xe02070) ABS 
LAB_299C EXPR(14688408=0xe02098) ABS 
LAB_2A89 EXPR(14688742=0xe021e6) ABS 
LAB_2989 EXPR(14688324=0xe02044) ABS 
LAB_2978 EXPR(14688308=0xe02034) ABS 
LAB_296A EXPR(14688270=0xe0200e) ABS 
LAB_2968 EXPR(14688242=0xe01ff2) ABS 
LAB_2969 EXPR(14688260=0xe02004) ABS 
LAB_2967 EXPR(14688234=0xe01fea) ABS 
Bin2dec EXPR(14691774=0xe02dbe) ABS 
LAB_LMSG EXPR(14694488=0xe03858) ABS 
LAB_POZE EXPR(14688804=0xe02224) ABS 
LAB_IRTS EXPR(14688208=0xe01fd0) ABS 
LAB_INT EXPR(14688184=0xe01fb8) ABS 
LAB_284L EXPR(14688166=0xe01fa6) ABS 
LAB_284H EXPR(14688176=0xe01fb0) ABS 
LAB_284G EXPR(14688158=0xe01f9e) ABS 
LAB_284J EXPR(14688178=0xe01fb2) ABS 
LAB_282E EXPR(14688118=0xe01f76) UNUSED ABS 
LAB_282F EXPR(14688120=0xe01f78) ABS 
LAB_2828 EXPR(14688112=0xe01f70) ABS 
LAB_ABS EXPR(14688072=0xe01f48) ABS 
LAB_SGN EXPR(14688054=0xe01f36) ABS 
LAB_27D0 EXPR(14688042=0xe01f2a) ABS 
LAB_27CE EXPR(14688038=0xe01f26) ABS 
LAB_27CA EXPR(14688030=0xe01f1e) ABS 
RTS_017 EXPR(14688028=0xe01f1c) ABS 
LAB_27C3 EXPR(14688014=0xe01f0e) ABS 
LAB_27C4 EXPR(14688024=0xe01f18) ABS 
LAB_27BA EXPR(14687986=0xe01ef2) ABS 
LAB_277C EXPR(14687936=0xe01ec0) ABS 
LAB_NB1T EXPR(14687900=0xe01e9c) ABS 
LAB_REMM EXPR(14687868=0xe01e7c) ABS 
L_DDIV EXPR(14687876=0xe01e84) ABS 
LAB_LT_1 EXPR(14687844=0xe01e64) ABS 
LAB_XDIV EXPR(14687806=0xe01e3e) ABS 
LAB_SET1 EXPR(14687790=0xe01e2e) ABS 
L_DIVRND EXPR(14687794=0xe01e32) ABS 
LAB_DIVX EXPR(14687782=0xe01e26) ABS 
LAB_3216 EXPR(14687832=0xe01e58) ABS 
LAB_32_16 EXPR(14687830=0xe01e56) ABS 
AC1gtAC2 EXPR(14687758=0xe01e0e) ABS 
LAB_MAN1 EXPR(14687818=0xe01e4a) ABS 
LAB_DIV0 EXPR(14687824=0xe01e50) ABS 
LAB_MUEX EXPR(14687684=0xe01dc4) ABS 
LAB_MUF3 EXPR(14687680=0xe01dc0) ABS 
LAB_MUF2 EXPR(14687658=0xe01daa) ABS 
LAB_MUF1 EXPR(14687648=0xe01da0) UNUSED ABS 
LAB_MADD EXPR(14687606=0xe01d76) ABS 
LAB_MNOC EXPR(14687600=0xe01d70) ABS 
LAB_MUUF EXPR(14687690=0xe01dca) ABS 
LAB_LOWZ EXPR(14687560=0xe01d48) ABS 
LAB_MULTIPLY EXPR(14687562=0xe01d4a) ABS 
LAB_LONE EXPR(14687502=0xe01d0e) ABS 
LAB_LOXP EXPR(14687492=0xe01d04) ABS 
LAB_LOXO EXPR(14687508=0xe01d14) ABS 
LAB_LOCX EXPR(14687474=0xe01cf2) ABS 
LAB_LOLP EXPR(14687456=0xe01ce0) ABS 
LAB_LAAD EXPR(14687440=0xe01cd0) ABS 
LAB_LOCC EXPR(14687446=0xe01cd6) ABS 
TAB_HTHET EXPR(14692540=0xe030bc) ABS 
LAB_DIVIDE EXPR(14687702=0xe01dd6) ABS 
LAB_LONN EXPR(14687478=0xe01cf6) ABS 
LAB_LOG EXPR(14687320=0xe01c58) ABS 
LAB_24D7 EXPR(14687306=0xe01c4a) ABS 
LAB_24D6 EXPR(14687292=0xe01c3c) ABS 
LAB_24D8 EXPR(14687312=0xe01c50) ABS 
LAB_24D9 EXPR(14687280=0xe01c30) ABS 
LAB_24DA EXPR(14687318=0xe01c56) ABS 
LAB_24B4 EXPR(14687244=0xe01c0c) ABS 
LAB_24F7 EXPR(14687228=0xe01bfc) ABS 
LAB_24F8 EXPR(14687234=0xe01c02) ABS 
LAB_2468 EXPR(14687198=0xe01bde) ABS 
LAB_2467 EXPR(14687194=0xe01bda) ABS 
LAB_249C EXPR(14687180=0xe01bcc) ABS 
LAB_24A8 EXPR(14687202=0xe01be2) ABS 
RTS_016 EXPR(14687232=0xe01c00) ABS 
LAB_SUBTRACT EXPR(14687124=0xe01b94) ABS 
LAB_CLS EXPR(14687106=0xe01b82) ABS 
LAB_BUFFER EXPR(14687096=0xe01b78) ABS 
LAB_CDLP EXPR(14687080=0xe01b68) ABS 
LAB_CRTS EXPR(14687090=0xe01b72) ABS 
LAB_CURSOR EXPR(14687028=0xe01b34) ABS 
LAB_SIZE EXPR(14687016=0xe01b28) ABS 
LAB_MODE EXPR(14686996=0xe01b14) ABS 
LAB_SNFC EXPR(14686938=0xe01ada) ABS 
LAB_FELLIPSE EXPR(14686912=0xe01ac0) ABS 
LAB_ELLIPSE EXPR(14686908=0xe01abc) ABS 
LAB_FRECT EXPR(14686904=0xe01ab8) ABS 
LAB_shape EXPR(14686914=0xe01ac2) ABS 
LAB_RECT EXPR(14686900=0xe01ab4) ABS 
LAB_PNCO EXPR(14686888=0xe01aa8) ABS 
LAB_SELC EXPR(14686886=0xe01aa6) ABS 
LAB_FILL EXPR(14686852=0xe01a84) ABS 
LAB_pixel EXPR(14686854=0xe01a86) ABS 
LAB_POINT EXPR(14686848=0xe01a80) ABS 
LAB_PNCE EXPR(14686892=0xe01aac) ABS 
LAB_MOVE EXPR(14686840=0xe01a78) ABS 
LAB_S2XY EXPR(14686954=0xe01aea) ABS 
LAB_S1XY EXPR(14686970=0xe01afa) ABS 
LAB_SRTS EXPR(14686992=0xe01b10) ABS 
LAB_LNCO EXPR(14686820=0xe01a64) ABS 
LAB_LINE EXPR(14686798=0xe01a4e) ABS 
LAB_SFCO EXPR(14686780=0xe01a3c) ABS 
LAB_SLCO EXPR(14686762=0xe01a2a) ABS 
LAB_GGEX EXPR(14686760=0xe01a28) ABS 
LAB_GGLP EXPR(14686720=0xe01a00) ABS 
LAB_GGPR EXPR(14686718=0xe019fe) ABS 
LAB_ISWD EXPR(14686714=0xe019fa) ABS 
LAB_EVSW EXPR(14686702=0xe019ee) ABS 
LAB_GTSW EXPR(14686694=0xe019e6) ABS 
LAB_KSSS EXPR(14686648=0xe019b8) ABS 
LAB_KKSS EXPR(14686644=0xe019b4) ABS 
LAB_KETT EXPR(14686618=0xe0199a) ABS 
LAB_KEZZ EXPR(14686616=0xe01998) ABS 
LAB_KESS EXPR(14686630=0xe019a6) ABS 
LAB_KEYS EXPR(14686606=0xe0198e) ABS 
LAB_24D5 EXPR(14687266=0xe01c22) ABS 
LAB_TI EXPR(14686592=0xe01980) ABS 
LAB_2445 EXPR(14686582=0xe01976) ABS 
LAB_2441 EXPR(14686578=0xe01972) ABS 
LAB_WAIT EXPR(14686556=0xe0195c) ABS 
LAB_CALL EXPR(14686546=0xe01952) ABS 
LAB_SAVE EXPR(14686542=0xe0194e) ABS 
LAB_LOAD EXPR(14686538=0xe0194a) ABS 
LAB_USR EXPR(14686530=0xe01942) ABS 
LAB_SWAP EXPR(14686484=0xe01914) ABS 
RTS_015 EXPR(14686482=0xe01912) ABS 
LAB_LOKE EXPR(14686464=0xe01900) ABS 
LAB_DOKE EXPR(14686458=0xe018fa) ABS 
LAB_LEEK EXPR(14686438=0xe018e6) ABS 
LAB_DEEK EXPR(14686416=0xe018d0) ABS 
LAB_POKE EXPR(14686410=0xe018ca) ABS 
LAB_PEEK EXPR(14686398=0xe018be) ABS 
LAB_XGADW EXPR(14686370=0xe018a2) ABS 
LAB_GEAD EXPR(14686376=0xe018a8) ABS 
LAB_GADW EXPR(14686344=0xe01888) ABS 
LAB_GADB EXPR(14686324=0xe01874) ABS 
LAB_VALZ EXPR(14686318=0xe0186e) ABS 
LAB_VAL EXPR(14686278=0xe01846) ABS 
LAB_ASC EXPR(14686218=0xe0180a) ABS 
LAB_LENS EXPR(14686210=0xe01802) ABS 
LAB_SADD EXPR(14686186=0xe017ea) ABS 
NoLcase EXPR(14686176=0xe017e0) ABS 
UC_loop EXPR(14686158=0xe017ce) ABS 
LAB_UCASE EXPR(14686136=0xe017b8) ABS 
NoUcase EXPR(14686128=0xe017b0) ABS 
LC_loop EXPR(14686110=0xe0179e) ABS 
NoString EXPR(14686182=0xe017e6) ABS 
LAB_LCASE EXPR(14686088=0xe01788) ABS 
LAB_2368 EXPR(14686080=0xe01780) ABS 
LAB_2358 EXPR(14686048=0xe01760) ABS 
LAB_MIDS EXPR(14686020=0xe01744) ABS 
LAB_2316 EXPR(14685990=0xe01726) UNUSED ABS 
LAB_RIGHT EXPR(14685972=0xe01714) ABS 
LAB_2317 EXPR(14685992=0xe01728) ABS 
LAB_231C EXPR(14685996=0xe0172c) ABS 
LAB_LEFT EXPR(14685952=0xe01700) ABS 
LAB_CHRS EXPR(14685936=0xe016f0) ABS 
LAB_22E6 EXPR(14685926=0xe016e6) ABS 
LAB_22BD EXPR(14685900=0xe016cc) ABS 
LAB_22A0 EXPR(14685872=0xe016b0) ABS 
RTS_013 EXPR(14685884=0xe016bc) ABS 
LAB_229E EXPR(14685860=0xe016a4) ABS 
LAB_224E EXPR(14685792=0xe01660) ABS 
LAB_2212 EXPR(14685764=0xe01644) ABS 
RTS_012 EXPR(14685768=0xe01648) ABS 
LAB_2216 EXPR(14685702=0xe01606) ABS 
LAB_2240 EXPR(14685710=0xe0160e) ABS 
LAB_21D1 EXPR(14685718=0xe01616) ABS 
LAB_21C2 EXPR(14685662=0xe015de) ABS 
LAB_21C4 EXPR(14685666=0xe015e2) ABS 
LAB_2183 EXPR(14685640=0xe015c8) ABS 
LAB_218B EXPR(14685648=0xe015d0) ABS 
LAB_217E EXPR(14685614=0xe015ae) ABS 
LAB_218F EXPR(14685650=0xe015d2) ABS 
LAB_2206 EXPR(14685724=0xe0161c) ABS 
LAB_2161 EXPR(14685596=0xe0159c) ABS 
LAB_2176 EXPR(14685602=0xe015a2) ABS 
LAB_214B EXPR(14685576=0xe01588) ABS 
LAB_2137 EXPR(14685544=0xe01568) ABS 
LAB_2117 EXPR(14685514=0xe0154a) ABS 
LAB_2128 EXPR(14685540=0xe01564) ABS 
LAB_20E0 EXPR(14685458=0xe01512) ABS 
LAB_20D8 EXPR(14685450=0xe0150a) ABS 
LAB_20CB EXPR(14685420=0xe014ec) ABS 
LAB_20D0 EXPR(14685428=0xe014f4) ABS 
LAB_20BE EXPR(14685404=0xe014dc) ABS 
LAB_STRS EXPR(14685390=0xe014ce) ABS 
LAB_2778 EXPR(14687934=0xe01ebe) ABS 
LAB_2044 EXPR(14685366=0xe014b6) ABS 
LAB_204T EXPR(14685364=0xe014b4) ABS 
LAB_2045 EXPR(14685376=0xe014c0) ABS 
LAB_204S EXPR(14685318=0xe01486) ABS 
LAB_2043 EXPR(14685316=0xe01484) ABS 
LAB_DEF EXPR(14685166=0xe013ee) ABS 
LAB_POS EXPR(14685144=0xe013d8) ABS 
LAB_24D0 EXPR(14687256=0xe01c18) ABS 
LAB_1FB4 EXPR(14685104=0xe013b0) ABS 
LAB_FRE EXPR(14685094=0xe013a6) ABS 
LAB_1F6B EXPR(14685052=0xe0137c) ABS 
LAB_1F6A EXPR(14685040=0xe01370) ABS 
LAB_1F5A EXPR(14685000=0xe01348) ABS 
LAB_1F2C EXPR(14684986=0xe0133a) ABS 
RTS_011 EXPR(14685056=0xe01380) ABS 
LAB_1F07 EXPR(14684954=0xe0131a) ABS 
LAB_1ED8 EXPR(14684936=0xe01308) ABS 
LAB_GARB EXPR(14685566=0xe0157e) ABS 
LAB_1ED6 EXPR(14684922=0xe012fa) ABS 
LAB_1F7C EXPR(14685058=0xe01382) ABS 
LAB_1EC0 EXPR(14684878=0xe012ce) ABS 
LAB_1EDF EXPR(14684866=0xe012c2) ABS 
LAB_1F28 EXPR(14684980=0xe01334) ABS 
LAB_1E8D EXPR(14684810=0xe0128a) ABS 
LAB_1EA1 EXPR(14684838=0xe012a6) ABS 
LAB_1E5C EXPR(14684782=0xe0126e) ABS 
LAB_1E1F EXPR(14684724=0xe01234) ABS 
LAB_EVPI EXPR(14684672=0xe01200) ABS 
LAB_EVIN EXPR(14684664=0xe011f8) ABS 
LAB_1DE6 EXPR(14684652=0xe011ec) ABS 
LAB_1DB1 EXPR(14684598=0xe011b6) ABS 
LAB_1DB2 EXPR(14684602=0xe011ba) ABS 
LAB_1DB0 EXPR(14684594=0xe011b2) ABS 
LAB_1DAE EXPR(14684568=0xe01198) ABS 
LAB_1DAC EXPR(14684566=0xe01196) ABS 
LAB_1DAF EXPR(14684580=0xe011a4) ABS 
LAB_1D98 EXPR(14684540=0xe0117c) UNUSED ABS 
LAB_1D94 EXPR(14684530=0xe01172) ABS 
LAB_1DD7 EXPR(14684626=0xe011d2) ABS 
LAB_1D5D EXPR(14684504=0xe01158) ABS 
LAB_1D5E EXPR(14684510=0xe0115e) ABS 
LAB_1D4A EXPR(14684480=0xe01140) ABS 
LAB_1E17 EXPR(14684718=0xe0122e) ABS 
LAB_1D4B EXPR(14684496=0xe01150) ABS 
LAB_1D49 EXPR(14684476=0xe0113c) ABS 
LAB_1D48 EXPR(14684468=0xe01134) ABS 
LAB_1D45 EXPR(14684448=0xe01120) ABS 
LAB_1D44 EXPR(14684432=0xe01110) ABS 
LAB_1D2E EXPR(14684404=0xe010f4) ABS 
LAB_1D2D EXPR(14684392=0xe010e8) ABS 
LAB_1D12 EXPR(14684374=0xe010d6) ABS 
LAB_FVAR EXPR(14684362=0xe010ca) ABS 
LAB_1D8A EXPR(14684348=0xe010bc) ABS 
LAB_CAUC EXPR(14684338=0xe010b2) UNUSED ABS 
LAB_1D83 EXPR(14684354=0xe010c2) ABS 
LAB_CASC EXPR(14684332=0xe010ac) ABS 
LAB_EVBY EXPR(14686242=0xe01822) ABS 
Not2Big EXPR(14684302=0xe0108e) ABS 
LAB_RSHIFT EXPR(14684282=0xe0107a) ABS 
TooBig EXPR(14684308=0xe01094) ABS 
NoShift EXPR(14684278=0xe01076) ABS 
GetPair EXPR(14684314=0xe0109a) ABS 
LAB_LSHIFT EXPR(14684266=0xe0106a) ABS 
LAB_1D10 EXPR(14684370=0xe010d2) ABS 
LAB_DIM EXPR(14684254=0xe0105e) ABS 
LAB_1CFE EXPR(14684250=0xe0105a) ABS 
LAB_27DB EXPR(14688056=0xe01f38) ABS 
LAB_1CDB EXPR(14684226=0xe01042) ABS 
LAB_1CE6 EXPR(14684212=0xe01034) ABS 
LAB_1CD6 EXPR(14684210=0xe01032) ABS 
LAB_1CD4 EXPR(14684202=0xe0102a) ABS 
LAB_1CD5 EXPR(14684208=0xe01030) ABS 
LAB_1CB5 EXPR(14684192=0xe01020) ABS 
LAB_22BA EXPR(14685890=0xe016c2) ABS 
LAB_1CF2 EXPR(14684228=0xe01044) ABS 
LAB_1CAE EXPR(14684162=0xe01002) ABS 
LAB_LTHAN EXPR(14684150=0xe00ff6) ABS 
LAB_EQUAL EXPR(14684140=0xe00fec) ABS 
LAB_279B EXPR(14687972=0xe01ee4) ABS 
LAB_EVIR EXPR(14684680=0xe01208) ABS 
LAB_AND EXPR(14684118=0xe00fd6) ABS 
LAB_OR EXPR(14684110=0xe00fce) ABS 
GetFirst EXPR(14684126=0xe00fde) ABS 
LAB_EOR EXPR(14684102=0xe00fc6) ABS 
LAB_BHCB EXPR(14684092=0xe00fbc) ABS 
LAB_2831 EXPR(14688124=0xe01f7c) ABS 
LAB_BHSS EXPR(14684054=0xe00f96) ABS 
LAB_GTWO EXPR(14686258=0xe01832) ABS 
LAB_LRMS EXPR(14684020=0xe00f74) ABS 
LAB_PPBI EXPR(14684010=0xe00f6a) ABS 
LAB_PPFN EXPR(14683996=0xe00f5c) ABS 
LAB_PPFS EXPR(14683982=0xe00f4e) ABS 
LAB_1C2A EXPR(14683994=0xe00f5a) ABS 
LAB_FTPP EXPR(14692774=0xe031a6) ABS 
LAB_FTBL EXPR(14692854=0xe031f6) ABS 
TK_SGN EXPR(204=0xcc) EQU 
LAB_FPOINT EXPR(14686658=0xe019c2) ABS 
TK_POINT EXPR(166=0xa6) EQU 
LAB_201E EXPR(14685238=0xe01436) ABS 
TK_FN EXPR(184=0xb8) EQU 
LAB_1BE7 EXPR(14683924=0xe00f14) ABS 
TK_NOT EXPR(187=0xbb) EQU 
LAB_AYFC EXPR(14685116=0xe013bc) ABS 
LAB_1C1A EXPR(14683892=0xe00ef4) ABS 
LAB_1C13 EXPR(14683866=0xe00eda) ABS 
LAB_1C11 EXPR(14683860=0xe00ed4) ABS 
RTS_001 EXPR(14683858=0xe00ed2) ABS 
LAB_SCGB EXPR(14683816=0xe00ea8) ABS 
LAB_1BFB EXPR(14683812=0xe00ea4) ABS 
LAB_1BF7 EXPR(14683808=0xe00ea0) ABS 
LAB_1C18 EXPR(14683872=0xe00ee0) ABS 
LAB_1BF3 EXPR(14683802=0xe00e9a) ABS 
LAB_1BD0 EXPR(14683898=0xe00efa) ABS 
LAB_1B84 EXPR(14683702=0xe00e36) ABS 
LAB_1B9D EXPR(14683742=0xe00e5e) ABS 
TK_LT EXPR(203=0xcb) EQU 
LAB_1B86 EXPR(14683706=0xe00e3a) ABS 
LAB_1B7B EXPR(14683690=0xe00e2a) ABS 
LAB_1B3C EXPR(14683674=0xe00e1a) ABS 
LAB_1B1D EXPR(14683628=0xe00dec) ABS 
LAB_1B1C EXPR(14683626=0xe00dea) ABS 
LAB_1B7D EXPR(14683692=0xe00e2c) ABS 
LAB_1B13 EXPR(14683610=0xe00dda) ABS 
LAB_224D EXPR(14685770=0xe0164a) ABS 
LAB_1B0B EXPR(14683602=0xe00dd2) ABS 
TK_PLUS EXPR(191=0xbf) EQU 
LAB_1B78 EXPR(14683686=0xe00e26) ABS 
LAB_1B2A EXPR(14683646=0xe00dfe) ABS 
LAB_1AE0 EXPR(14683554=0xe00da2) ABS 
LAB_1AFA EXPR(14683580=0xe00dbc) ABS 
TK_GT EXPR(201=0xc9) EQU 
LAB_1ADE EXPR(14683532=0xe00d8c) ABS 
LAB_1ADB EXPR(14683528=0xe00d88) ABS 
LAB_OPPT EXPR(14692934=0xe03246) ABS 
LAB_1B43 EXPR(14683488=0xe00d60) ABS 
LAB_1ACD EXPR(14683516=0xe00d7c) ABS 
LAB_EVEZ EXPR(14683480=0xe00d58) ABS 
LAB_1ABA EXPR(14683472=0xe00d50) ABS 
LAB_1A9B EXPR(14683430=0xe00d26) ABS 
LAB_1A90 EXPR(14683416=0xe00d18) ABS 
LAB_27FA EXPR(14688080=0xe01f50) ABS 
LAB_1C19 EXPR(14683876=0xe00ee4) ABS 
LAB_11A5 EXPR(14683304=0xe00ca8) ABS 
LAB_11A6 EXPR(14683306=0xe00caa) ABS 
LAB_11BD EXPR(14683318=0xe00cb6) ABS 
LAB_1A46 EXPR(14683290=0xe00c9a) ABS 
LAB_NEXT EXPR(14683272=0xe00c88) ABS 
LAB_IMSG EXPR(14694498=0xe03862) ABS 
LAB_1A1B EXPR(14683264=0xe00c80) ABS 
LAB_1A0E EXPR(14683258=0xe00c7a) ABS 
LAB_19F6 EXPR(14683228=0xe00c5c) ABS 
LAB_1C01 EXPR(14683820=0xe00eac) ABS 
LAB_1A03 EXPR(14683242=0xe00c6a) ABS 
LAB_19C2 EXPR(14683176=0xe00c28) ABS 
LAB_2887 EXPR(14691244=0xe02bac) ABS 
LAB_19B6 EXPR(14683160=0xe00c18) ABS 
LAB_20B4 EXPR(14685398=0xe014d6) ABS 
LAB_1999 EXPR(14683126=0xe00bf6) ABS 
LAB_19B0 EXPR(14683144=0xe00c08) ABS 
LAB_1985 EXPR(14683102=0xe00bde) ABS 
LAB_1984 EXPR(14683098=0xe00bda) ABS 
LAB_19DD EXPR(14683196=0xe00c3c) ABS 
LAB_1986 EXPR(14683106=0xe00be2) ABS 
LAB_1961 EXPR(14683066=0xe00bba) UNUSED ABS 
LAB_195B EXPR(14683056=0xe00bb0) ABS 
LAB_READ EXPR(14683042=0xe00ba2) ABS 
LAB_1953 EXPR(14683048=0xe00ba8) ABS 
LAB_1BC1 EXPR(14683790=0xe00e8e) ABS 
LAB_1934 EXPR(14683028=0xe00b94) ABS 
LAB_CKRN EXPR(14685156=0xe013e4) ABS 
LAB_INPUT EXPR(14683004=0xe00b7c) ABS 
LAB_REDO EXPR(14694514=0xe03872) ABS 
LAB_1913 EXPR(14682990=0xe00b6e) ABS 
LAB_1904 EXPR(14682972=0xe00b5c) ABS 
LAB_1880 EXPR(14682954=0xe00b4a) ABS 
LAB_1886 EXPR(14682964=0xe00b54) ABS 
LAB_188A EXPR(14682968=0xe00b58) ABS 
LAB_18F7 EXPR(14682930=0xe00b32) ABS 
LAB_18F0 EXPR(14682916=0xe00b24) ABS 
LAB_18F9 EXPR(14682934=0xe00b36) ABS 
LAB_18CD EXPR(14682874=0xe00afa) ABS 
RTS_009 EXPR(14682882=0xe00b02) ABS 
LAB_18B8 EXPR(14682844=0xe00adc) ABS 
LAB_SGBY EXPR(14686234=0xe0181a) ABS 
LAB_18B7 EXPR(14682832=0xe00ad0) ABS 
LAB_1898 EXPR(14682788=0xe00aa4) ABS 
LAB_185E EXPR(14682756=0xe00a84) ABS 
LAB_20AE EXPR(14685394=0xe014d2) ABS 
LAB_2970 EXPR(14688292=0xe02024) ABS 
LAB_18BD EXPR(14682850=0xe00ae2) ABS 
LAB_188B EXPR(14682774=0xe00a96) ABS 
TK_SPC EXPR(185=0xb9) EQU 
LAB_18A2 EXPR(14682798=0xe00aae) ABS 
LAB_1831 EXPR(14682692=0xe00a44) ABS 
LAB_PRINT EXPR(14682690=0xe00a42) ABS 
LAB_182C EXPR(14682686=0xe00a3e) ABS 
LAB_18C6 EXPR(14682864=0xe00af0) ABS 
LAB_1829 EXPR(14682682=0xe00a3a) ABS 
LAB_RTST EXPR(14685464=0xe01518) ABS 
LAB_NoSt EXPR(14682676=0xe00a34) ABS 
LAB_1FD0 EXPR(14685148=0xe013dc) ABS 
INGET EXPR(14690820=0xe02a04) ABS 
LAB_GETS EXPR(14682658=0xe00a22) ABS 
LAB_GET EXPR(14682632=0xe00a08) ABS 
RTS_008 EXPR(14682630=0xe00a06) UNUSED ABS 
LAB_1813 EXPR(14682626=0xe00a02) ABS 
LAB_20C9 EXPR(14685440=0xe01500) ABS 
LAB_1810 EXPR(14682604=0xe009ec) UNUSED ABS 
LAB_1811 EXPR(14682620=0xe009fc) ABS 
LAB_17D6 EXPR(14682586=0xe009da) ABS 
LAB_17D5 EXPR(14682582=0xe009d6) ABS 
LAB_CKTM EXPR(14683458=0xe00d42) ABS 
TK_EQUAL EXPR(202=0xca) EQU 
LAB_SVAR EXPR(14684360=0xe010c8) ABS 
LAB_DECI EXPR(14682538=0xe009aa) ABS 
LAB_INCT EXPR(14682514=0xe00992) ABS 
LAB_PFAC EXPR(14687910=0xe01ea6) ABS 
LAB_ADD EXPR(14687144=0xe01ba8) ABS 
LAB_INCI EXPR(14682528=0xe009a0) ABS 
LAB_GVAR EXPR(14684364=0xe010cc) ABS 
LAB_17B8 EXPR(14682456=0xe00958) ABS 
LAB_INC EXPR(14682450=0xe00952) ABS 
LAB_17B7 EXPR(14682460=0xe0095c) ABS 
LAB_DEC EXPR(14682444=0xe0094c) ABS 
LAB_1785 EXPR(14682394=0xe0091a) ABS 
LAB_1786 EXPR(14682438=0xe00946) ABS 
LAB_1773 EXPR(14682366=0xe008fe) ABS 
LAB_176C EXPR(14682356=0xe008f4) ABS 
LAB_ON EXPR(14682330=0xe008da) ABS 
LAB_REM EXPR(14682322=0xe008d2) ABS 
LAB_1756 EXPR(14682306=0xe008c2) UNUSED ABS 
LAB_1752 EXPR(14682302=0xe008be) ABS 
LAB_1754 EXPR(14682326=0xe008d6) ABS 
LAB_1750 EXPR(14682290=0xe008b2) ABS 
TK_IF EXPR(139=0x8b) EQU 
TK_ELSE EXPR(182=0xb6) EQU 
TK_RETURN EXPR(142=0x8e) EQU 
LAB_174E EXPR(14682282=0xe008aa) ABS 
TK_GOTO EXPR(137=0x89) EQU 
LAB_174B EXPR(14682246=0xe00886) ABS 
TK_THEN EXPR(186=0xba) EQU 
LAB_IF EXPR(14682212=0xe00864) ABS 
LAB_1723 EXPR(14682202=0xe0085a) ABS 
LAB_1725 EXPR(14682206=0xe0085e) ABS 
RTS_007a EXPR(14682198=0xe00856) ABS 
LAB_172C EXPR(14682186=0xe0084a) ABS 
LAB_172D EXPR(14682194=0xe00852) ABS 
RTS_007 EXPR(14682176=0xe00840) ABS 
LAB_RETURN EXPR(14682152=0xe00828) ABS 
LAB_DATA EXPR(14682172=0xe0083c) ABS 
LoopDone EXPR(14682146=0xe00822) ABS 
DoCmp EXPR(14682120=0xe00808) ABS 
LAB_EVEX EXPR(14683478=0xe00d56) ABS 
DoRest EXPR(14682100=0xe007f4) ABS 
TK_UNTIL EXPR(189=0xbd) EQU 
LoopAlways EXPR(14682126=0xe0080e) ABS 
LAB_LOOP EXPR(14682066=0xe007d2) ABS 
LAB_GOTs EXPR(14682036=0xe007b4) ABS 
LAB_16D0 EXPR(14682048=0xe007c0) ABS 
LAB_GOTO EXPR(14682020=0xe007a4) ABS 
TK_GOSUB EXPR(141=0x8d) EQU 
LAB_GOSUB EXPR(14682002=0xe00792) ABS 
TK_DO EXPR(156=0x9c) EQU 
LAB_DO EXPR(14681984=0xe00780) ABS 
LAB_16B0 EXPR(14682012=0xe0079c) ABS 
LAB_RUNn EXPR(14681978=0xe0077a) ABS 
LAB_RUN EXPR(14681964=0xe0076c) ABS 
LAB_CONT EXPR(14681934=0xe0074e) ABS 
LAB_GTBY EXPR(14686238=0xe0181e) ABS 
LAB_NULL EXPR(14681924=0xe00744) ABS 
LAB_RESs EXPR(14681896=0xe00728) ABS 
LAB_GSCH EXPR(14681908=0xe00734) ABS 
LAB_1624 EXPR(14681916=0xe0073c) ABS 
LAB_BMSG EXPR(14694473=0xe03849) ABS 
LAB_1647 EXPR(14681854=0xe006fe) ABS 
LAB_164F EXPR(14681860=0xe00704) ABS 
LAB_STOP EXPR(14681840=0xe006f0) ABS 
LAB_END EXPR(14681832=0xe006e8) ABS 
LAB_1639 EXPR(14681830=0xe006e6) ABS 
LAB_163B EXPR(14681842=0xe006f2) ABS 
LAB_1636 EXPR(14681824=0xe006e0) ABS 
LAB_CTBL EXPR(14692668=0xe0313c) ABS 
TK_TAB EXPR(181=0xb5) EQU 
LAB_1602 EXPR(14681784=0xe006b8) ABS 
RTS_006 EXPR(14681922=0xe00742) ABS 
LAB_15D1 EXPR(14681766=0xe006a6) ABS 
LAB_15FF EXPR(14681780=0xe006b4) ABS 
LAB_15DC EXPR(14681730=0xe00682) ABS 
LAB_15C2 EXPR(14681754=0xe0069a) ABS 
TK_FOR EXPR(129=0x81) EQU 
LAB_15B3 EXPR(14681712=0xe00670) ABS 
TK_STEP EXPR(188=0xbc) EQU 
LAB_EVNM EXPR(14683454=0xe00d3e) ABS 
LAB_CTNM EXPR(14683456=0xe00d40) ABS 
LAB_SCCA EXPR(14683822=0xe00eae) ABS 
TK_TO EXPR(183=0xb7) EQU 
LAB_SNBS EXPR(14682178=0xe00842) ABS 
LAB_LET EXPR(14682542=0xe009ae) ABS 
LAB_FOR EXPR(14681628=0xe0061c) ABS 
LAB_1540 EXPR(14681616=0xe00610) ABS 
LAB_KEYT EXPR(14693120=0xe03300) ABS 
LAB_152E EXPR(14681572=0xe005e4) ABS 
LAB_1519 EXPR(14681560=0xe005d8) ABS 
LAB_150C EXPR(14681546=0xe005ca) ABS 
LAB_14E2 EXPR(14681532=0xe005bc) UNUSED ABS 
LAB_1629 EXPR(14681820=0xe006dc) ABS 
LAB_14D4 EXPR(14681504=0xe005a0) ABS 
TK_MINUS EXPR(192=0xc0) EQU 
LAB_14C0 EXPR(14681472=0xe00580) ABS 
LAB_14BD EXPR(14681468=0xe0057c) ABS 
LAB_CLEAR EXPR(14681444=0xe00564) ABS 
LAB_RESTORE EXPR(14681878=0xe00716) ABS 
RTS_005 EXPR(14681442=0xe00562) ABS 
LAB_NEW EXPR(14681364=0xe00514) ABS 
LAB_145E EXPR(14681358=0xe0050e) ABS 
LAB_145F EXPR(14681344=0xe00500) ABS 
LAB_SCLN EXPR(14681346=0xe00502) ABS 
LAB_142C EXPR(14681332=0xe004f4) ABS 
LAB_141B EXPR(14681298=0xe004d2) ABS 
LAB_1408 EXPR(14681274=0xe004ba) ABS 
TK_REM EXPR(143=0x8f) EQU 
LAB_1401 EXPR(14681262=0xe004ae) ABS 
TK_DATA EXPR(131=0x83) EQU 
LAB_13FF EXPR(14681258=0xe004aa) ABS 
LAB_142A EXPR(14681320=0xe004e8) ABS 
LAB_1417 EXPR(14681296=0xe004d0) ABS 
LAB_13EA EXPR(14681232=0xe00490) ABS 
LAB_13D8 EXPR(14681220=0xe00484) ABS 
LAB_13D6 EXPR(14681214=0xe0047e) ABS 
TAB_STAR EXPR(14693974=0xe03656) ABS 
LAB_141F EXPR(14681314=0xe004e2) ABS 
TAB_CHRT EXPR(14693014=0xe03296) ABS 
LAB_1410 EXPR(14681286=0xe004c6) ABS 
LAB_13AC EXPR(14681132=0xe0042c) ABS 
LAB_13CC EXPR(14681180=0xe0045c) ABS 
LAB_13C6 EXPR(14681174=0xe00456) ABS 
LAB_13EC EXPR(14681234=0xe00492) ABS 
LAB_1392 EXPR(14681072=0xe003f0) ABS 
LAB_137F EXPR(14681062=0xe003e6) ABS 
LAB_138E EXPR(14681068=0xe003ec) ABS 
LAB_1374 EXPR(14681044=0xe003d4) ABS 
LAB_1866 EXPR(14682760=0xe00a88) ABS 
LAB_1378 EXPR(14681050=0xe003da) ABS 
LAB_18E3 EXPR(14682884=0xe00b04) ABS 
LAB_INLN EXPR(14680996=0xe003a4) ABS 
LAB_1359 EXPR(14681012=0xe003b4) ABS 
LAB_PRNA EXPR(14682886=0xe00b06) ABS 
LAB_134B EXPR(14680976=0xe00390) ABS 
LAB_1477 EXPR(14681378=0xe00522) ABS 
LAB_1330 EXPR(14680948=0xe00374) ABS 
LAB_132E EXPR(14680946=0xe00372) ABS 
LAB_1303 EXPR(14680938=0xe0036a) ABS 
LAB_1301 EXPR(14680908=0xe0034c) ABS 
LAB_12FF EXPR(14680906=0xe0034a) ABS 
LAB_1325 EXPR(14680962=0xe00382) ABS 
LAB_12B0 EXPR(14680824=0xe002f8) ABS 
LAB_12AE EXPR(14680822=0xe002f6) ABS 
LAB_12E6 EXPR(14680856=0xe00318) ABS 
LAB_SSLN EXPR(14681338=0xe004fa) ABS 
LAB_GFPN EXPR(14682382=0xe0090e) ABS 
LAB_15F6 EXPR(14681748=0xe00694) ABS 
LAB_13A6 EXPR(14681124=0xe00424) ABS 
LAB_1295 EXPR(14680788=0xe002d4) ABS 
LAB_1357 EXPR(14681006=0xe003ae) ABS 
LAB_127E EXPR(14680768=0xe002c0) ABS 
LAB_127D EXPR(14680754=0xe002b2) ABS 
LAB_RMSG EXPR(14694532=0xe03884) ABS 
LAB_2953 EXPR(14688210=0xe01fd2) ABS 
LAB_1269 EXPR(14680732=0xe0029c) ABS 
LAB_EMSG EXPR(14694481=0xe03851) ABS 
LAB_BAER EXPR(14693584=0xe034d0) ABS 
LAB_1491 EXPR(14681420=0xe0054c) ABS 
LAB_NFER EXPR(14680702=0xe0027e) ABS 
LAB_RGER EXPR(14680694=0xe00276) ABS 
LAB_ODER EXPR(14680690=0xe00272) ABS 
LAB_OFER EXPR(14680682=0xe0026a) ABS 
LAB_OMER EXPR(14680678=0xe00266) ABS 
LAB_USER EXPR(14680674=0xe00262) ABS 
LAB_ABER EXPR(14680670=0xe0025e) ABS 
LAB_DDER EXPR(14680666=0xe0025a) ABS 
LAB_DZER EXPR(14680662=0xe00256) ABS 
LAB_IDER EXPR(14680658=0xe00252) ABS 
LAB_SLER EXPR(14680650=0xe0024a) ABS 
LAB_SCER EXPR(14680646=0xe00246) ABS 
LAB_CCER EXPR(14680642=0xe00242) ABS 
LAB_UFER EXPR(14680638=0xe0023e) ABS 
LAB_LDER EXPR(14680634=0xe0023a) ABS 
LAB_UVER EXPR(14680630=0xe00236) ABS 
LAB_UDER EXPR(14680626=0xe00232) ABS 
LAB_WDER EXPR(14680622=0xe0022e) ABS 
LAB_ADER EXPR(14680618=0xe0022a) ABS 
LAB_XERR EXPR(14680704=0xe00280) ABS 
LAB_FOER EXPR(14680614=0xe00226) ABS 
LAB_RND EXPR(14689280=0xe02400) ABS 
LAB_UFAC EXPR(14687882=0xe01e8a) ABS 
LAB_RSED EXPR(14691814=0xe02de6) ABS 
LAB_18C3 EXPR(14682860=0xe00aec) ABS 
LAB_SMSG EXPR(14694542=0xe0388e) ABS 
LAB_295E EXPR(14688222=0xe01fde) ABS 
LAB_CRLF EXPR(14682766=0xe00a8e) ABS 
LAB_1463 EXPR(14681366=0xe00516) ABS 
LAB_GMEM EXPR(14680510=0xe001be) UNUSED ABS 
VEC_CC EXPR(14690782=0xe029de) ABS 
LAB_sizok EXPR(14680436=0xe00174) ABS 
LAB_COLD EXPR(14680424=0xe00168) ABS 
LAB_LIST EXPR(14681448=0xe00568) ABS 
LAB_IGBY EXPR(14683830=0xe00eb6) ABS 
LAB_SNER EXPR(14680698=0xe0027a) ABS 
SAVE_bas EXPR(14680370=0xe00132) ABS 
LAB_GBYT EXPR(14683832=0xe00eb8) ABS 
SAVE_OUT EXPR(14680388=0xe00144) ABS 
LAB_FCER EXPR(14680686=0xe0026e) ABS 
SAVE_RTN EXPR(14680308=0xe000f4) ABS 
VEC_SV EXPR(14680288=0xe000e0) ABS 
save_title EXPR(14680272=0xe000d0) ABS 
load_title EXPR(14680262=0xe000c6) UNUSED ABS 
file_list EXPR(14680282=0xe000da) ABS 
LAB_22B6 EXPR(14685886=0xe016be) ABS 
name_copy EXPR(14680212=0xe00094) ABS 
LAB_2115 EXPR(14685490=0xe01532) ABS 
LAB_TMER EXPR(14680654=0xe0024e) ABS 
LAB_GVAL EXPR(14683748=0xe00e64) ABS 
get_file EXPR(14680166=0xe00066) ABS 
get_name EXPR(14680230=0xe000a6) ABS 
get_filename EXPR(14680164=0xe00064) UNUSED ABS 
LOAD_eof EXPR(14680142=0xe0004e) UNUSED ABS 
LOAD_in EXPR(14680142=0xe0004e) UNUSED ABS 
LAB_1274 EXPR(14680746=0xe002aa) ABS 
LAB_147A EXPR(14681384=0xe00528) ABS 
LOAD_exit EXPR(14680134=0xe00046) UNUSED ABS 
VEC_LD EXPR(14680134=0xe00046) ABS 
RXNOTREADY EXPR(14680124=0xe0003c) ABS 
VEC_IN EXPR(14680094=0xe0001e) ABS 
TXNOTREADY EXPR(14680078=0xe0000e) ABS 
VEC_OUT EXPR(14680068=0xe00004) ABS 
start_here EXPR(14680414=0xe0015e) ABS 
code_start EXPR(14680064=0xe00000) UNUSED ABS 
ram_size EXPR(1048576=0x100000) EQU 
ram_addr EXPR(12582912=0xc00000) EQU 
prg_strt EXPR(1522=0x5f2) 
file_id EXPR(1516=0x5ec) 
file_byte EXPR(1515=0x5eb) 
ccnull EXPR(1514=0x5ea) 
ccbyte EXPR(1513=0x5e9) 
ccflag EXPR(1512=0x5e8) 
Iclim EXPR(1511=0x5e7) 
TWidth EXPR(1510=0x5e6) 
TPos EXPR(1509=0x5e5) 
Nullct EXPR(1508=0x5e4) 
comp_f EXPR(1507=0x5e3) 
TabSiz EXPR(1506=0x5e2) 
Cflag EXPR(1505=0x5e1) 
Imode EXPR(1504=0x5e0) 
Sufnxf EXPR(1503=0x5df) 
Gclctd EXPR(1502=0x5de) 
Oquote EXPR(1501=0x5dd) 
Breakf EXPR(1500=0x5dc) 
Dimcnt EXPR(1499=0x5db) 
Asrch EXPR(1498=0x5da) 
tpower EXPR(1497=0x5d9) 
prstk EXPR(1496=0x5d8) 
BHsend EXPR(1494=0x5d6) 
Hexss EXPR(1486=0x5ce) 
Usdss EXPR(1484=0x5cc) 
Decss EXPR(1478=0x5c6) 
Binss EXPR(1462=0x5b6) 
Dtypef EXPR(1461=0x5b5) EQU 
cosout EXPR(1460=0x5b4) EQU 
Defdim EXPR(1460=0x5b4) 
func_l EXPR(1456=0x5b0) 
expneg EXPR(1455=0x5af) EQU 
expcnt EXPR(1453=0x5ad) EQU 
numexp EXPR(1452=0x5ac) EQU 
Astrtl EXPR(1452=0x5ac) 
Asptl EXPR(1448=0x5a8) 
ut1_pl EXPR(1444=0x5a4) UNUSED 
PRNlword EXPR(1440=0x5a0) 
flag EXPR(1439=0x59f) EQU 
FAC_sc EXPR(1438=0x59e) EQU 
FAC2_s EXPR(1437=0x59d) EQU 
FAC2_e EXPR(1436=0x59c) 
FAC2_m EXPR(1432=0x598) 
FAC1_s EXPR(1429=0x595) EQU 
FAC1_e EXPR(1428=0x594) 
FAC1_m EXPR(1424=0x590) 
Ibuffe EXPR(1424=0x590) 
Ibuffs EXPR(1168=0x490) 
des_sk EXPR(1166=0x48e) 
des_sk_e EXPR(1142=0x476) 
Lvarpl EXPR(1138=0x472) 
Cvaral EXPR(1134=0x46e) UNUSED 
Varname EXPR(1130=0x46a) 
Rdptrl EXPR(1126=0x466) 
Dptrl EXPR(1122=0x462) 
Dlinel EXPR(1118=0x45e) 
Cpntrl EXPR(1114=0x45a) 
Blinel EXPR(1110=0x456) 
Clinel EXPR(1106=0x452) 
Sutill EXPR(1102=0x44e) 
Ememl EXPR(1098=0x44a) 
Sstorl EXPR(1094=0x446) 
Earryl EXPR(1090=0x442) 
Sarryl EXPR(1086=0x43e) 
Sstrl EXPR(1082=0x43a) 
Svarl EXPR(1078=0x436) 
Sfncl EXPR(1074=0x432) 
Smeml EXPR(1070=0x42e) 
Itemp EXPR(1066=0x42a) 
V_CTLCv EXPR(1062=0x426) UNUSED 
V_CTLC EXPR(1060=0x424) 
V_SAVEv EXPR(1056=0x420) UNUSED 
V_SAVE EXPR(1054=0x41e) 
V_LOADv EXPR(1050=0x41a) UNUSED 
V_LOAD EXPR(1048=0x418) 
V_OUTPv EXPR(1044=0x414) 
V_OUTP EXPR(1042=0x412) 
V_INPTv EXPR(1038=0x40e) 
V_INPT EXPR(1036=0x40c) 
Usrjpv EXPR(1032=0x408) UNUSED 
Usrjmp EXPR(1030=0x406) 
Wrmjpv EXPR(1026=0x402) 
LAB_WARM EXPR(1024=0x400) 
ram_base EXPR(1024=0x400) 
ram_strt EXPR(0=0x0) UNUSED 
nobrk EXPR(0=0x0) EQU 
novar EXPR(0=0x0) EQU 
LSR EXPR(10=0xa) EQU 
THR EXPR(0=0x0) EQU 
RHR EXPR(0=0x0) EQU 
ACIA_1 EXPR(10485760=0xa00000) EQU 
RAMBASE EXPR(14680064=0xe00000) UNUSED EQU 
SERIALIN EXPR(262144=0x40000) UNUSED EQU 
SERIALOUT EXPR(327680=0x50000) UNUSED EQU 
STATUS EXPR(393216=0x60000) UNUSED EQU 
LED EXPR(458752=0x70000) UNUSED EQU 
_MOVEMBYTES EXPR(20=0x14) INTERNAL 
 MOVEMSIZE EXPR(4=0x4) INTERNAL 
_MOVEMREGS EXPR(62=0x3e) INTERNAL 
__LINE__ EXPR(9972=0x26f4) INTERNAL 
__FO EXPR(0=0x0) INTERNAL 
__RS EXPR(0=0x0) INTERNAL 
REPTN EXPR(-1=0xffffffff) INTERNAL 
__VASM EXPR(1=0x1) INTERNAL 

There have been no errors.
